# AUTO-GENERATED FILE - DO NOT EDIT
# This file was automatically generated by the XDK build tool.
# Any manual changes will be overwritten on the next generation.

"""
Auto-generated users client for the X API.

This module provides a client for interacting with the users endpoints of the X API.

All methods, parameters, and response models are generated from the OpenAPI specification.

Generated automatically - do not edit manually.
"""

from __future__ import annotations
from typing import Dict, List, Optional, Any, Union, cast, TYPE_CHECKING, Iterator
import requests
import time
import urllib.parse

if TYPE_CHECKING:
    from ..client import Client
from .models import (
    GetMeResponse,
    UnfollowListResponse,
    RepostPostRequest,
    RepostPostResponse,
    GetFollowingResponse,
    FollowUserRequest,
    FollowUserResponse,
    GetByIdsResponse,
    BlockDmsResponse,
    UnmuteUserResponse,
    GetBookmarksResponse,
    CreateBookmarkRequest,
    CreateBookmarkResponse,
    GetLikedPostsResponse,
    GetPinnedListsResponse,
    PinListRequest,
    PinListResponse,
    GetMentionsResponse,
    GetBookmarkFoldersResponse,
    GetRepostsOfMeResponse,
    GetListMembershipsResponse,
    GetBlockingResponse,
    UnpinListResponse,
    UnrepostPostResponse,
    GetMutingResponse,
    MuteUserRequest,
    MuteUserResponse,
    GetByUsernameResponse,
    GetTimelineResponse,
    GetBookmarksByFolderIdResponse,
    GetFollowersResponse,
    DeleteBookmarkResponse,
    UnlikePostResponse,
    GetOwnedListsResponse,
    SearchResponse,
    UnblockDmsResponse,
    UnfollowUserResponse,
    LikePostRequest,
    LikePostResponse,
    GetByUsernamesResponse,
    GetAffiliatesResponse,
    GetByIdResponse,
    GetPostsResponse,
    GetFollowedListsResponse,
    FollowListRequest,
    FollowListResponse,
)


class UsersClient:
    """Client for users operations"""


    def __init__(self, client: Client):
        self.client = client


    def get_me(
        self,
        user_fields: List = None,
        expansions: List = None,
        tweet_fields: List = None,
    ) -> GetMeResponse:
        """
        Get my User
        Retrieves details of the authenticated user.
        Args:
            user_fields: A comma separated list of User fields to display.
            expansions: A comma separated list of fields to expand.
            tweet_fields: A comma separated list of Tweet fields to display.
            Returns:
            GetMeResponse: Response data
        """
        url = self.client.base_url + "/2/users/me"
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        # UserToken: OAuth1.0a authentication - header will be built dynamically in request
        # OAuth1 header must be built per-request with method, URL, and body
        # This is handled in the request logic below
        params = {}
        if user_fields is not None:
            params["user.fields"] = ",".join(str(item) for item in user_fields)
        if expansions is not None:
            params["expansions"] = ",".join(str(item) for item in expansions)
        if tweet_fields is not None:
            params["tweet.fields"] = ",".join(str(item) for item in tweet_fields)
        headers = {}
        # Prepare request data
        json_data = None
        # Select authentication method based on endpoint requirements and available credentials
        # Priority strategy (matches TypeScript):
        # 1. If endpoint only accepts one method, use that (if available)
        # 2. If endpoint accepts multiple methods:
        #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
        #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
        # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
        selected_auth = None
        # Check what auth methods we have available
        available_bearer = bool(self.client.bearer_token)
        available_oauth2 = bool(self.client.access_token)
        available_oauth1 = bool(self.client.auth and self.client.auth.access_token)
        # Count acceptable schemes
        acceptable_schemes = []
        acceptable_schemes.append("OAuth2UserToken")
        acceptable_schemes.append("UserToken")
        # If only one scheme is acceptable, use it if available
        if len(acceptable_schemes) == 1:
            scheme = acceptable_schemes[0]
            if scheme == "BearerToken" and available_bearer:
                selected_auth = "bearer_token"
            elif scheme == "OAuth2UserToken" and available_oauth2:
                selected_auth = "oauth2_user_context"
            elif scheme == "UserToken" and available_oauth1:
                selected_auth = "oauth1"
        # Multiple schemes acceptable - use priority based on operation type
        elif len(acceptable_schemes) > 1:
            is_write_operation = "get" in ["POST", "PUT", "DELETE", "PATCH"]
            if is_write_operation:
                # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                if "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
            else:
                # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                if "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
        # Apply selected authentication
        if selected_auth == "oauth1":
            # OAuth1 authentication - build proper OAuth1 header dynamically
            # Build OAuth1 header with method, URL, and body
            # For OAuth1, we need to include query params in the URL for signature
            full_url = url
            if params:
                query_string = urllib.parse.urlencode(params)
                full_url = f"{url}?{query_string}" if query_string else url
            # Prepare body for OAuth1 signature (form-encoded, not JSON)
            body_string = ""
            # Build OAuth1 authorization header
            oauth_header = self.client.auth.build_request_header(
                method="get", url=full_url, body=body_string
            )
            headers["Authorization"] = oauth_header
        elif selected_auth == "bearer_token":
            # Bearer token authentication
            if self.client.bearer_token:
                headers["Authorization"] = f"Bearer {self.client.bearer_token}"
            elif self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
        elif selected_auth == "oauth2_user_context":
            # OAuth2 User Token authentication
            if self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
                # Check if token needs refresh
                if self.client.oauth2_auth and self.client.token:
                    if self.client.is_token_expired():
                        self.client.refresh_token()
                        if self.client.access_token:
                            headers["Authorization"] = (
                                f"Bearer {self.client.access_token}"
                            )
        # Make the request
        if not selected_auth:
            # No suitable auth method found - validate authentication
            required_schemes = (
                acceptable_schemes if "acceptable_schemes" in locals() else []
            )
            if required_schemes:
                available = []
                if available_bearer and "BearerToken" in required_schemes:
                    available.append("BearerToken")
                if available_oauth2 and "OAuth2UserToken" in required_schemes:
                    available.append("OAuth2UserToken")
                if available_oauth1 and "UserToken" in required_schemes:
                    available.append("UserToken")
                if not available:
                    raise ValueError(
                        f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and available_bearer) or (s == 'OAuth2UserToken' and available_oauth2) or (s == 'UserToken' and available_oauth1)]}"
                    )
        response = self.client.session.get(
            url,
            params=params,
            headers=headers,
        )
        # Check for errors
        response.raise_for_status()
        # Parse the response data
        response_data = response.json()
        # Convert to Pydantic model if applicable
        return GetMeResponse.model_validate(response_data)


    def unfollow_list(self, id: Any, list_id: Any) -> UnfollowListResponse:
        """
        Unfollow List
        Causes the authenticated user to unfollow a specific List by its ID.
        Args:
            id: The ID of the authenticated source User that will unfollow the List.
            list_id: The ID of the List to unfollow.
            Returns:
            UnfollowListResponse: Response data
        """
        url = self.client.base_url + "/2/users/{id}/followed_lists/{list_id}"
        url = url.replace("{id}", str(id))
        url = url.replace("{list_id}", str(list_id))
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        # UserToken: OAuth1.0a authentication - header will be built dynamically in request
        # OAuth1 header must be built per-request with method, URL, and body
        # This is handled in the request logic below
        params = {}
        headers = {}
        # Prepare request data
        json_data = None
        # Select authentication method based on endpoint requirements and available credentials
        # Priority strategy (matches TypeScript):
        # 1. If endpoint only accepts one method, use that (if available)
        # 2. If endpoint accepts multiple methods:
        #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
        #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
        # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
        selected_auth = None
        # Check what auth methods we have available
        available_bearer = bool(self.client.bearer_token)
        available_oauth2 = bool(self.client.access_token)
        available_oauth1 = bool(self.client.auth and self.client.auth.access_token)
        # Count acceptable schemes
        acceptable_schemes = []
        acceptable_schemes.append("OAuth2UserToken")
        acceptable_schemes.append("UserToken")
        # If only one scheme is acceptable, use it if available
        if len(acceptable_schemes) == 1:
            scheme = acceptable_schemes[0]
            if scheme == "BearerToken" and available_bearer:
                selected_auth = "bearer_token"
            elif scheme == "OAuth2UserToken" and available_oauth2:
                selected_auth = "oauth2_user_context"
            elif scheme == "UserToken" and available_oauth1:
                selected_auth = "oauth1"
        # Multiple schemes acceptable - use priority based on operation type
        elif len(acceptable_schemes) > 1:
            is_write_operation = "delete" in ["POST", "PUT", "DELETE", "PATCH"]
            if is_write_operation:
                # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                if "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
            else:
                # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                if "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
        # Apply selected authentication
        if selected_auth == "oauth1":
            # OAuth1 authentication - build proper OAuth1 header dynamically
            # Build OAuth1 header with method, URL, and body
            # For OAuth1, we need to include query params in the URL for signature
            full_url = url
            if params:
                query_string = urllib.parse.urlencode(params)
                full_url = f"{url}?{query_string}" if query_string else url
            # Prepare body for OAuth1 signature (form-encoded, not JSON)
            body_string = ""
            # Build OAuth1 authorization header
            oauth_header = self.client.auth.build_request_header(
                method="delete", url=full_url, body=body_string
            )
            headers["Authorization"] = oauth_header
        elif selected_auth == "bearer_token":
            # Bearer token authentication
            if self.client.bearer_token:
                headers["Authorization"] = f"Bearer {self.client.bearer_token}"
            elif self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
        elif selected_auth == "oauth2_user_context":
            # OAuth2 User Token authentication
            if self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
                # Check if token needs refresh
                if self.client.oauth2_auth and self.client.token:
                    if self.client.is_token_expired():
                        self.client.refresh_token()
                        if self.client.access_token:
                            headers["Authorization"] = (
                                f"Bearer {self.client.access_token}"
                            )
        # Make the request
        if not selected_auth:
            # No suitable auth method found - validate authentication
            required_schemes = (
                acceptable_schemes if "acceptable_schemes" in locals() else []
            )
            if required_schemes:
                available = []
                if available_bearer and "BearerToken" in required_schemes:
                    available.append("BearerToken")
                if available_oauth2 and "OAuth2UserToken" in required_schemes:
                    available.append("OAuth2UserToken")
                if available_oauth1 and "UserToken" in required_schemes:
                    available.append("UserToken")
                if not available:
                    raise ValueError(
                        f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and available_bearer) or (s == 'OAuth2UserToken' and available_oauth2) or (s == 'UserToken' and available_oauth1)]}"
                    )
        response = self.client.session.delete(
            url,
            params=params,
            headers=headers,
        )
        # Check for errors
        response.raise_for_status()
        # Parse the response data
        response_data = response.json()
        # Convert to Pydantic model if applicable
        return UnfollowListResponse.model_validate(response_data)


    def repost_post(
        self, id: Any, body: Optional[RepostPostRequest] = None
    ) -> RepostPostResponse:
        """
        Repost Post
        Causes the authenticated user to repost a specific Post by its ID.
        Args:
            id: The ID of the authenticated source User that is requesting to repost the Post.
            body: Request body
        Returns:
            RepostPostResponse: Response data
        """
        url = self.client.base_url + "/2/users/{id}/retweets"
        url = url.replace("{id}", str(id))
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        # UserToken: OAuth1.0a authentication - header will be built dynamically in request
        # OAuth1 header must be built per-request with method, URL, and body
        # This is handled in the request logic below
        params = {}
        headers = {}
        headers["Content-Type"] = "application/json"
        # Prepare request data
        json_data = None
        if body is not None:
            json_data = (
                body.model_dump(exclude_none=True)
                if hasattr(body, "model_dump")
                else body
            )
        # Select authentication method based on endpoint requirements and available credentials
        # Priority strategy (matches TypeScript):
        # 1. If endpoint only accepts one method, use that (if available)
        # 2. If endpoint accepts multiple methods:
        #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
        #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
        # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
        selected_auth = None
        # Check what auth methods we have available
        available_bearer = bool(self.client.bearer_token)
        available_oauth2 = bool(self.client.access_token)
        available_oauth1 = bool(self.client.auth and self.client.auth.access_token)
        # Count acceptable schemes
        acceptable_schemes = []
        acceptable_schemes.append("OAuth2UserToken")
        acceptable_schemes.append("UserToken")
        # If only one scheme is acceptable, use it if available
        if len(acceptable_schemes) == 1:
            scheme = acceptable_schemes[0]
            if scheme == "BearerToken" and available_bearer:
                selected_auth = "bearer_token"
            elif scheme == "OAuth2UserToken" and available_oauth2:
                selected_auth = "oauth2_user_context"
            elif scheme == "UserToken" and available_oauth1:
                selected_auth = "oauth1"
        # Multiple schemes acceptable - use priority based on operation type
        elif len(acceptable_schemes) > 1:
            is_write_operation = "post" in ["POST", "PUT", "DELETE", "PATCH"]
            if is_write_operation:
                # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                if "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
            else:
                # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                if "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
        # Apply selected authentication
        if selected_auth == "oauth1":
            # OAuth1 authentication - build proper OAuth1 header dynamically
            # Build OAuth1 header with method, URL, and body
            # For OAuth1, we need to include query params in the URL for signature
            full_url = url
            if params:
                query_string = urllib.parse.urlencode(params)
                full_url = f"{url}?{query_string}" if query_string else url
            # Prepare body for OAuth1 signature (form-encoded, not JSON)
            body_string = ""
            if json_data:
                # OAuth1 spec: JSON bodies are NOT included in signature
                # But we still need to pass the body for the request
                body_string = ""
            # Build OAuth1 authorization header
            oauth_header = self.client.auth.build_request_header(
                method="post", url=full_url, body=body_string
            )
            headers["Authorization"] = oauth_header
        elif selected_auth == "bearer_token":
            # Bearer token authentication
            if self.client.bearer_token:
                headers["Authorization"] = f"Bearer {self.client.bearer_token}"
            elif self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
        elif selected_auth == "oauth2_user_context":
            # OAuth2 User Token authentication
            if self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
                # Check if token needs refresh
                if self.client.oauth2_auth and self.client.token:
                    if self.client.is_token_expired():
                        self.client.refresh_token()
                        if self.client.access_token:
                            headers["Authorization"] = (
                                f"Bearer {self.client.access_token}"
                            )
        # Make the request
        if not selected_auth:
            # No suitable auth method found - validate authentication
            required_schemes = (
                acceptable_schemes if "acceptable_schemes" in locals() else []
            )
            if required_schemes:
                available = []
                if available_bearer and "BearerToken" in required_schemes:
                    available.append("BearerToken")
                if available_oauth2 and "OAuth2UserToken" in required_schemes:
                    available.append("OAuth2UserToken")
                if available_oauth1 and "UserToken" in required_schemes:
                    available.append("UserToken")
                if not available:
                    raise ValueError(
                        f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and available_bearer) or (s == 'OAuth2UserToken' and available_oauth2) or (s == 'UserToken' and available_oauth1)]}"
                    )
        response = self.client.session.post(
            url,
            params=params,
            headers=headers,
            json=json_data,
        )
        # Check for errors
        response.raise_for_status()
        # Parse the response data
        response_data = response.json()
        # Convert to Pydantic model if applicable
        return RepostPostResponse.model_validate(response_data)


    def get_following(
        self,
        id: Any,
        max_results: int = None,
        pagination_token: Any = None,
        user_fields: List = None,
        expansions: List = None,
        tweet_fields: List = None,
    ) -> Iterator[GetFollowingResponse]:
        """
        Get following
        Retrieves a list of Users followed by a specific User by their ID.
        Args:
            id: The ID of the User to lookup.
            max_results: The maximum number of results.
            pagination_token: This parameter is used to get a specified 'page' of results.
            user_fields: A comma separated list of User fields to display.
            expansions: A comma separated list of fields to expand.
            tweet_fields: A comma separated list of Tweet fields to display.
            Yields:
            GetFollowingResponse: One page of results at a time. Automatically handles pagination using next_token.
        Note:
            This method automatically paginates through all results. To get just the first page,
            you can call it once and break, or use the pagination_token parameter to start at a specific page.
        """
        url = self.client.base_url + "/2/users/{id}/following"
        url = url.replace("{id}", str(id))
        # Priority: bearer_token > access_token (matches TypeScript behavior)
        if self.client.bearer_token:
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.bearer_token}"
            )
        elif self.client.access_token:
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        # UserToken: OAuth1.0a authentication - header will be built dynamically in request
        # OAuth1 header must be built per-request with method, URL, and body
        # This is handled in the request logic below
        headers = {}
        # Prepare request data
        json_data = None
        # Determine pagination parameter name
        pagination_param_name = "pagination_token"
        # Start with provided pagination_token, or None for first page
        # Check if pagination_token parameter exists in the method signature
        current_pagination_token = pagination_token
        while True:
            # Build query parameters for this page
            page_params = {}
            if max_results is not None:
                page_params["max_results"] = max_results
            if user_fields is not None:
                page_params["user.fields"] = ",".join(str(item) for item in user_fields)
            if expansions is not None:
                page_params["expansions"] = ",".join(str(item) for item in expansions)
            if tweet_fields is not None:
                page_params["tweet.fields"] = ",".join(
                    str(item) for item in tweet_fields
                )
            # Add pagination token for this page
            if current_pagination_token:
                page_params[pagination_param_name] = current_pagination_token
            # Select authentication method (same logic as regular_request)
            # Priority strategy (matches TypeScript):
            # 1. If endpoint only accepts one method, use that (if available)
            # 2. If endpoint accepts multiple methods:
            #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
            #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
            # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
            page_selected_auth = None
            # Check what auth methods we have available
            page_available_bearer = bool(self.client.bearer_token)
            page_available_oauth2 = bool(self.client.access_token)
            page_available_oauth1 = bool(
                self.client.auth and self.client.auth.access_token
            )
            # Count acceptable schemes
            page_acceptable_schemes = []
            page_acceptable_schemes.append("BearerToken")
            page_acceptable_schemes.append("OAuth2UserToken")
            page_acceptable_schemes.append("UserToken")
            # If only one scheme is acceptable, use it if available
            if len(page_acceptable_schemes) == 1:
                scheme = page_acceptable_schemes[0]
                if scheme == "BearerToken" and page_available_bearer:
                    page_selected_auth = "bearer_token"
                elif scheme == "OAuth2UserToken" and page_available_oauth2:
                    page_selected_auth = "oauth2_user_context"
                elif scheme == "UserToken" and page_available_oauth1:
                    page_selected_auth = "oauth1"
            # Multiple schemes acceptable - use priority based on operation type
            elif len(page_acceptable_schemes) > 1:
                is_write_operation = "get" in ["POST", "PUT", "DELETE", "PATCH"]
                if is_write_operation:
                    # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                    if "UserToken" in page_acceptable_schemes and page_available_oauth1:
                        page_selected_auth = "oauth1"
                    elif (
                        "OAuth2UserToken" in page_acceptable_schemes
                        and page_available_oauth2
                    ):
                        page_selected_auth = "oauth2_user_context"
                    elif (
                        "BearerToken" in page_acceptable_schemes
                        and page_available_bearer
                    ):
                        page_selected_auth = "bearer_token"
                else:
                    # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                    if (
                        "BearerToken" in page_acceptable_schemes
                        and page_available_bearer
                    ):
                        page_selected_auth = "bearer_token"
                    elif (
                        "OAuth2UserToken" in page_acceptable_schemes
                        and page_available_oauth2
                    ):
                        page_selected_auth = "oauth2_user_context"
                    elif (
                        "UserToken" in page_acceptable_schemes and page_available_oauth1
                    ):
                        page_selected_auth = "oauth1"
            # Apply selected authentication for this page
            page_headers = headers.copy()
            if page_selected_auth == "oauth1":
                # OAuth1 authentication - build proper OAuth1 header dynamically
                # Build OAuth1 header with method, URL, and body
                # For OAuth1, we need to include query params in the URL for signature
                full_url = url
                if page_params:
                    query_string = urllib.parse.urlencode(page_params)
                    full_url = f"{url}?{query_string}" if query_string else url
                # Prepare body for OAuth1 signature (form-encoded, not JSON)
                body_string = ""
                # Build OAuth1 authorization header
                oauth_header = self.client.auth.build_request_header(
                    method="get", url=full_url, body=body_string
                )
                page_headers["Authorization"] = oauth_header
            elif page_selected_auth == "bearer_token":
                # Bearer token authentication
                if self.client.bearer_token:
                    page_headers["Authorization"] = f"Bearer {self.client.bearer_token}"
                elif self.client.access_token:
                    page_headers["Authorization"] = f"Bearer {self.client.access_token}"
            elif page_selected_auth == "oauth2_user_context":
                # OAuth2 User Token authentication
                if self.client.access_token:
                    page_headers["Authorization"] = f"Bearer {self.client.access_token}"
                    # Check if token needs refresh
                    if self.client.oauth2_auth and self.client.token:
                        if self.client.is_token_expired():
                            self.client.refresh_token()
                            if self.client.access_token:
                                page_headers["Authorization"] = (
                                    f"Bearer {self.client.access_token}"
                                )
            # Make the request
            if not page_selected_auth:
                # No suitable auth method found - validate authentication
                required_schemes = (
                    page_acceptable_schemes
                    if "page_acceptable_schemes" in locals()
                    else []
                )
                if required_schemes:
                    available = []
                    if page_available_bearer and "BearerToken" in required_schemes:
                        available.append("BearerToken")
                    if page_available_oauth2 and "OAuth2UserToken" in required_schemes:
                        available.append("OAuth2UserToken")
                    if page_available_oauth1 and "UserToken" in required_schemes:
                        available.append("UserToken")
                    if not available:
                        raise ValueError(
                            f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and page_available_bearer) or (s == 'OAuth2UserToken' and page_available_oauth2) or (s == 'UserToken' and page_available_oauth1)]}"
                        )
            response = self.client.session.get(
                url,
                params=page_params,
                headers=page_headers,
            )
            # Check for errors
            response.raise_for_status()
            # Parse the response data
            response_data = response.json()
            # Convert to Pydantic model if applicable
            page_response = GetFollowingResponse.model_validate(response_data)
            # Yield this page
            yield page_response
            # Extract next_token from response
            next_token = None
            try:
                # Try response.meta.next_token (most common pattern)
                if hasattr(page_response, "meta") and page_response.meta is not None:
                    meta = page_response.meta
                    # If meta is a Pydantic model, try to dump it
                    if hasattr(meta, "model_dump"):
                        try:
                            meta_dict = meta.model_dump()
                            next_token = meta_dict.get("next_token")
                        except (AttributeError, TypeError):
                            pass
                    # Otherwise try attribute access
                    if not next_token and hasattr(meta, "next_token"):
                        next_token = getattr(meta, "next_token", None)
                    # If meta is a dict, access it directly
                    if not next_token and isinstance(meta, dict):
                        next_token = meta.get("next_token")
            except (AttributeError, TypeError):
                pass
            # Try dict access if we have a dict
            if not next_token and isinstance(response_data, dict):
                try:
                    meta = response_data.get("meta")
                    if meta and isinstance(meta, dict):
                        next_token = meta.get("next_token")
                except (AttributeError, TypeError, KeyError):
                    pass
            # If no next_token, we're done
            if not next_token:
                break
            # Update token for next iteration
            current_pagination_token = next_token

            # Optional: Add rate limit backoff here if needed
            # time.sleep(0.1)  # Small delay to avoid rate limits


    def follow_user(
        self, id: Any, body: Optional[FollowUserRequest] = None
    ) -> FollowUserResponse:
        """
        Follow User
        Causes the authenticated user to follow a specific user by their ID.
        Args:
            id: The ID of the authenticated source User that is requesting to follow the target User.
            body: Request body
        Returns:
            FollowUserResponse: Response data
        """
        url = self.client.base_url + "/2/users/{id}/following"
        url = url.replace("{id}", str(id))
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        # UserToken: OAuth1.0a authentication - header will be built dynamically in request
        # OAuth1 header must be built per-request with method, URL, and body
        # This is handled in the request logic below
        params = {}
        headers = {}
        headers["Content-Type"] = "application/json"
        # Prepare request data
        json_data = None
        if body is not None:
            json_data = (
                body.model_dump(exclude_none=True)
                if hasattr(body, "model_dump")
                else body
            )
        # Select authentication method based on endpoint requirements and available credentials
        # Priority strategy (matches TypeScript):
        # 1. If endpoint only accepts one method, use that (if available)
        # 2. If endpoint accepts multiple methods:
        #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
        #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
        # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
        selected_auth = None
        # Check what auth methods we have available
        available_bearer = bool(self.client.bearer_token)
        available_oauth2 = bool(self.client.access_token)
        available_oauth1 = bool(self.client.auth and self.client.auth.access_token)
        # Count acceptable schemes
        acceptable_schemes = []
        acceptable_schemes.append("OAuth2UserToken")
        acceptable_schemes.append("UserToken")
        # If only one scheme is acceptable, use it if available
        if len(acceptable_schemes) == 1:
            scheme = acceptable_schemes[0]
            if scheme == "BearerToken" and available_bearer:
                selected_auth = "bearer_token"
            elif scheme == "OAuth2UserToken" and available_oauth2:
                selected_auth = "oauth2_user_context"
            elif scheme == "UserToken" and available_oauth1:
                selected_auth = "oauth1"
        # Multiple schemes acceptable - use priority based on operation type
        elif len(acceptable_schemes) > 1:
            is_write_operation = "post" in ["POST", "PUT", "DELETE", "PATCH"]
            if is_write_operation:
                # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                if "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
            else:
                # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                if "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
        # Apply selected authentication
        if selected_auth == "oauth1":
            # OAuth1 authentication - build proper OAuth1 header dynamically
            # Build OAuth1 header with method, URL, and body
            # For OAuth1, we need to include query params in the URL for signature
            full_url = url
            if params:
                query_string = urllib.parse.urlencode(params)
                full_url = f"{url}?{query_string}" if query_string else url
            # Prepare body for OAuth1 signature (form-encoded, not JSON)
            body_string = ""
            if json_data:
                # OAuth1 spec: JSON bodies are NOT included in signature
                # But we still need to pass the body for the request
                body_string = ""
            # Build OAuth1 authorization header
            oauth_header = self.client.auth.build_request_header(
                method="post", url=full_url, body=body_string
            )
            headers["Authorization"] = oauth_header
        elif selected_auth == "bearer_token":
            # Bearer token authentication
            if self.client.bearer_token:
                headers["Authorization"] = f"Bearer {self.client.bearer_token}"
            elif self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
        elif selected_auth == "oauth2_user_context":
            # OAuth2 User Token authentication
            if self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
                # Check if token needs refresh
                if self.client.oauth2_auth and self.client.token:
                    if self.client.is_token_expired():
                        self.client.refresh_token()
                        if self.client.access_token:
                            headers["Authorization"] = (
                                f"Bearer {self.client.access_token}"
                            )
        # Make the request
        if not selected_auth:
            # No suitable auth method found - validate authentication
            required_schemes = (
                acceptable_schemes if "acceptable_schemes" in locals() else []
            )
            if required_schemes:
                available = []
                if available_bearer and "BearerToken" in required_schemes:
                    available.append("BearerToken")
                if available_oauth2 and "OAuth2UserToken" in required_schemes:
                    available.append("OAuth2UserToken")
                if available_oauth1 and "UserToken" in required_schemes:
                    available.append("UserToken")
                if not available:
                    raise ValueError(
                        f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and available_bearer) or (s == 'OAuth2UserToken' and available_oauth2) or (s == 'UserToken' and available_oauth1)]}"
                    )
        response = self.client.session.post(
            url,
            params=params,
            headers=headers,
            json=json_data,
        )
        # Check for errors
        response.raise_for_status()
        # Parse the response data
        response_data = response.json()
        # Convert to Pydantic model if applicable
        return FollowUserResponse.model_validate(response_data)


    def get_by_ids(
        self,
        ids: List,
        user_fields: List = None,
        expansions: List = None,
        tweet_fields: List = None,
    ) -> GetByIdsResponse:
        """
        Get Users by IDs
        Retrieves details of multiple Users by their IDs.
        Args:
            ids: A list of User IDs, comma-separated. You can specify up to 100 IDs.
            user_fields: A comma separated list of User fields to display.
            expansions: A comma separated list of fields to expand.
            tweet_fields: A comma separated list of Tweet fields to display.
            Returns:
            GetByIdsResponse: Response data
        """
        url = self.client.base_url + "/2/users"
        # Priority: bearer_token > access_token (matches TypeScript behavior)
        if self.client.bearer_token:
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.bearer_token}"
            )
        elif self.client.access_token:
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        # UserToken: OAuth1.0a authentication - header will be built dynamically in request
        # OAuth1 header must be built per-request with method, URL, and body
        # This is handled in the request logic below
        params = {}
        if ids is not None:
            params["ids"] = ",".join(str(item) for item in ids)
        if user_fields is not None:
            params["user.fields"] = ",".join(str(item) for item in user_fields)
        if expansions is not None:
            params["expansions"] = ",".join(str(item) for item in expansions)
        if tweet_fields is not None:
            params["tweet.fields"] = ",".join(str(item) for item in tweet_fields)
        headers = {}
        # Prepare request data
        json_data = None
        # Select authentication method based on endpoint requirements and available credentials
        # Priority strategy (matches TypeScript):
        # 1. If endpoint only accepts one method, use that (if available)
        # 2. If endpoint accepts multiple methods:
        #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
        #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
        # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
        selected_auth = None
        # Check what auth methods we have available
        available_bearer = bool(self.client.bearer_token)
        available_oauth2 = bool(self.client.access_token)
        available_oauth1 = bool(self.client.auth and self.client.auth.access_token)
        # Count acceptable schemes
        acceptable_schemes = []
        acceptable_schemes.append("BearerToken")
        acceptable_schemes.append("OAuth2UserToken")
        acceptable_schemes.append("UserToken")
        # If only one scheme is acceptable, use it if available
        if len(acceptable_schemes) == 1:
            scheme = acceptable_schemes[0]
            if scheme == "BearerToken" and available_bearer:
                selected_auth = "bearer_token"
            elif scheme == "OAuth2UserToken" and available_oauth2:
                selected_auth = "oauth2_user_context"
            elif scheme == "UserToken" and available_oauth1:
                selected_auth = "oauth1"
        # Multiple schemes acceptable - use priority based on operation type
        elif len(acceptable_schemes) > 1:
            is_write_operation = "get" in ["POST", "PUT", "DELETE", "PATCH"]
            if is_write_operation:
                # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                if "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
            else:
                # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                if "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
        # Apply selected authentication
        if selected_auth == "oauth1":
            # OAuth1 authentication - build proper OAuth1 header dynamically
            # Build OAuth1 header with method, URL, and body
            # For OAuth1, we need to include query params in the URL for signature
            full_url = url
            if params:
                query_string = urllib.parse.urlencode(params)
                full_url = f"{url}?{query_string}" if query_string else url
            # Prepare body for OAuth1 signature (form-encoded, not JSON)
            body_string = ""
            # Build OAuth1 authorization header
            oauth_header = self.client.auth.build_request_header(
                method="get", url=full_url, body=body_string
            )
            headers["Authorization"] = oauth_header
        elif selected_auth == "bearer_token":
            # Bearer token authentication
            if self.client.bearer_token:
                headers["Authorization"] = f"Bearer {self.client.bearer_token}"
            elif self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
        elif selected_auth == "oauth2_user_context":
            # OAuth2 User Token authentication
            if self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
                # Check if token needs refresh
                if self.client.oauth2_auth and self.client.token:
                    if self.client.is_token_expired():
                        self.client.refresh_token()
                        if self.client.access_token:
                            headers["Authorization"] = (
                                f"Bearer {self.client.access_token}"
                            )
        # Make the request
        if not selected_auth:
            # No suitable auth method found - validate authentication
            required_schemes = (
                acceptable_schemes if "acceptable_schemes" in locals() else []
            )
            if required_schemes:
                available = []
                if available_bearer and "BearerToken" in required_schemes:
                    available.append("BearerToken")
                if available_oauth2 and "OAuth2UserToken" in required_schemes:
                    available.append("OAuth2UserToken")
                if available_oauth1 and "UserToken" in required_schemes:
                    available.append("UserToken")
                if not available:
                    raise ValueError(
                        f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and available_bearer) or (s == 'OAuth2UserToken' and available_oauth2) or (s == 'UserToken' and available_oauth1)]}"
                    )
        response = self.client.session.get(
            url,
            params=params,
            headers=headers,
        )
        # Check for errors
        response.raise_for_status()
        # Parse the response data
        response_data = response.json()
        # Convert to Pydantic model if applicable
        return GetByIdsResponse.model_validate(response_data)


    def block_dms(self, id: Any) -> BlockDmsResponse:
        """
        Block DMs
        Blocks direct messages to or from a specific User by their ID for the authenticated user.
        Args:
            id: The ID of the target User that the authenticated user requesting to block dms for.
            Returns:
            BlockDmsResponse: Response data
        """
        url = self.client.base_url + "/2/users/{id}/dm/block"
        url = url.replace("{id}", str(id))
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        # UserToken: OAuth1.0a authentication - header will be built dynamically in request
        # OAuth1 header must be built per-request with method, URL, and body
        # This is handled in the request logic below
        params = {}
        headers = {}
        # Prepare request data
        json_data = None
        # Select authentication method based on endpoint requirements and available credentials
        # Priority strategy (matches TypeScript):
        # 1. If endpoint only accepts one method, use that (if available)
        # 2. If endpoint accepts multiple methods:
        #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
        #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
        # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
        selected_auth = None
        # Check what auth methods we have available
        available_bearer = bool(self.client.bearer_token)
        available_oauth2 = bool(self.client.access_token)
        available_oauth1 = bool(self.client.auth and self.client.auth.access_token)
        # Count acceptable schemes
        acceptable_schemes = []
        acceptable_schemes.append("OAuth2UserToken")
        acceptable_schemes.append("UserToken")
        # If only one scheme is acceptable, use it if available
        if len(acceptable_schemes) == 1:
            scheme = acceptable_schemes[0]
            if scheme == "BearerToken" and available_bearer:
                selected_auth = "bearer_token"
            elif scheme == "OAuth2UserToken" and available_oauth2:
                selected_auth = "oauth2_user_context"
            elif scheme == "UserToken" and available_oauth1:
                selected_auth = "oauth1"
        # Multiple schemes acceptable - use priority based on operation type
        elif len(acceptable_schemes) > 1:
            is_write_operation = "post" in ["POST", "PUT", "DELETE", "PATCH"]
            if is_write_operation:
                # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                if "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
            else:
                # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                if "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
        # Apply selected authentication
        if selected_auth == "oauth1":
            # OAuth1 authentication - build proper OAuth1 header dynamically
            # Build OAuth1 header with method, URL, and body
            # For OAuth1, we need to include query params in the URL for signature
            full_url = url
            if params:
                query_string = urllib.parse.urlencode(params)
                full_url = f"{url}?{query_string}" if query_string else url
            # Prepare body for OAuth1 signature (form-encoded, not JSON)
            body_string = ""
            # Build OAuth1 authorization header
            oauth_header = self.client.auth.build_request_header(
                method="post", url=full_url, body=body_string
            )
            headers["Authorization"] = oauth_header
        elif selected_auth == "bearer_token":
            # Bearer token authentication
            if self.client.bearer_token:
                headers["Authorization"] = f"Bearer {self.client.bearer_token}"
            elif self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
        elif selected_auth == "oauth2_user_context":
            # OAuth2 User Token authentication
            if self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
                # Check if token needs refresh
                if self.client.oauth2_auth and self.client.token:
                    if self.client.is_token_expired():
                        self.client.refresh_token()
                        if self.client.access_token:
                            headers["Authorization"] = (
                                f"Bearer {self.client.access_token}"
                            )
        # Make the request
        if not selected_auth:
            # No suitable auth method found - validate authentication
            required_schemes = (
                acceptable_schemes if "acceptable_schemes" in locals() else []
            )
            if required_schemes:
                available = []
                if available_bearer and "BearerToken" in required_schemes:
                    available.append("BearerToken")
                if available_oauth2 and "OAuth2UserToken" in required_schemes:
                    available.append("OAuth2UserToken")
                if available_oauth1 and "UserToken" in required_schemes:
                    available.append("UserToken")
                if not available:
                    raise ValueError(
                        f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and available_bearer) or (s == 'OAuth2UserToken' and available_oauth2) or (s == 'UserToken' and available_oauth1)]}"
                    )
        response = self.client.session.post(
            url,
            params=params,
            headers=headers,
        )
        # Check for errors
        response.raise_for_status()
        # Parse the response data
        response_data = response.json()
        # Convert to Pydantic model if applicable
        return BlockDmsResponse.model_validate(response_data)


    def unmute_user(
        self, source_user_id: Any, target_user_id: Any
    ) -> UnmuteUserResponse:
        """
        Unmute User
        Causes the authenticated user to unmute a specific user by their ID.
        Args:
            source_user_id: The ID of the authenticated source User that is requesting to unmute the target User.
            target_user_id: The ID of the User that the source User is requesting to unmute.
            Returns:
            UnmuteUserResponse: Response data
        """
        url = self.client.base_url + "/2/users/{source_user_id}/muting/{target_user_id}"
        url = url.replace("{source_user_id}", str(source_user_id))
        url = url.replace("{target_user_id}", str(target_user_id))
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        # UserToken: OAuth1.0a authentication - header will be built dynamically in request
        # OAuth1 header must be built per-request with method, URL, and body
        # This is handled in the request logic below
        params = {}
        headers = {}
        # Prepare request data
        json_data = None
        # Select authentication method based on endpoint requirements and available credentials
        # Priority strategy (matches TypeScript):
        # 1. If endpoint only accepts one method, use that (if available)
        # 2. If endpoint accepts multiple methods:
        #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
        #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
        # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
        selected_auth = None
        # Check what auth methods we have available
        available_bearer = bool(self.client.bearer_token)
        available_oauth2 = bool(self.client.access_token)
        available_oauth1 = bool(self.client.auth and self.client.auth.access_token)
        # Count acceptable schemes
        acceptable_schemes = []
        acceptable_schemes.append("OAuth2UserToken")
        acceptable_schemes.append("UserToken")
        # If only one scheme is acceptable, use it if available
        if len(acceptable_schemes) == 1:
            scheme = acceptable_schemes[0]
            if scheme == "BearerToken" and available_bearer:
                selected_auth = "bearer_token"
            elif scheme == "OAuth2UserToken" and available_oauth2:
                selected_auth = "oauth2_user_context"
            elif scheme == "UserToken" and available_oauth1:
                selected_auth = "oauth1"
        # Multiple schemes acceptable - use priority based on operation type
        elif len(acceptable_schemes) > 1:
            is_write_operation = "delete" in ["POST", "PUT", "DELETE", "PATCH"]
            if is_write_operation:
                # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                if "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
            else:
                # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                if "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
        # Apply selected authentication
        if selected_auth == "oauth1":
            # OAuth1 authentication - build proper OAuth1 header dynamically
            # Build OAuth1 header with method, URL, and body
            # For OAuth1, we need to include query params in the URL for signature
            full_url = url
            if params:
                query_string = urllib.parse.urlencode(params)
                full_url = f"{url}?{query_string}" if query_string else url
            # Prepare body for OAuth1 signature (form-encoded, not JSON)
            body_string = ""
            # Build OAuth1 authorization header
            oauth_header = self.client.auth.build_request_header(
                method="delete", url=full_url, body=body_string
            )
            headers["Authorization"] = oauth_header
        elif selected_auth == "bearer_token":
            # Bearer token authentication
            if self.client.bearer_token:
                headers["Authorization"] = f"Bearer {self.client.bearer_token}"
            elif self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
        elif selected_auth == "oauth2_user_context":
            # OAuth2 User Token authentication
            if self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
                # Check if token needs refresh
                if self.client.oauth2_auth and self.client.token:
                    if self.client.is_token_expired():
                        self.client.refresh_token()
                        if self.client.access_token:
                            headers["Authorization"] = (
                                f"Bearer {self.client.access_token}"
                            )
        # Make the request
        if not selected_auth:
            # No suitable auth method found - validate authentication
            required_schemes = (
                acceptable_schemes if "acceptable_schemes" in locals() else []
            )
            if required_schemes:
                available = []
                if available_bearer and "BearerToken" in required_schemes:
                    available.append("BearerToken")
                if available_oauth2 and "OAuth2UserToken" in required_schemes:
                    available.append("OAuth2UserToken")
                if available_oauth1 and "UserToken" in required_schemes:
                    available.append("UserToken")
                if not available:
                    raise ValueError(
                        f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and available_bearer) or (s == 'OAuth2UserToken' and available_oauth2) or (s == 'UserToken' and available_oauth1)]}"
                    )
        response = self.client.session.delete(
            url,
            params=params,
            headers=headers,
        )
        # Check for errors
        response.raise_for_status()
        # Parse the response data
        response_data = response.json()
        # Convert to Pydantic model if applicable
        return UnmuteUserResponse.model_validate(response_data)


    def get_bookmarks(
        self,
        id: Any,
        max_results: int = None,
        pagination_token: Any = None,
        tweet_fields: List = None,
        expansions: List = None,
        media_fields: List = None,
        poll_fields: List = None,
        user_fields: List = None,
        place_fields: List = None,
    ) -> Iterator[GetBookmarksResponse]:
        """
        Get Bookmarks
        Retrieves a list of Posts bookmarked by the authenticated user.
        Args:
            id: The ID of the authenticated source User for whom to return results.
            max_results: The maximum number of results.
            pagination_token: This parameter is used to get the next 'page' of results.
            tweet_fields: A comma separated list of Tweet fields to display.
            expansions: A comma separated list of fields to expand.
            media_fields: A comma separated list of Media fields to display.
            poll_fields: A comma separated list of Poll fields to display.
            user_fields: A comma separated list of User fields to display.
            place_fields: A comma separated list of Place fields to display.
            Yields:
            GetBookmarksResponse: One page of results at a time. Automatically handles pagination using next_token.
        Note:
            This method automatically paginates through all results. To get just the first page,
            you can call it once and break, or use the pagination_token parameter to start at a specific page.
        """
        url = self.client.base_url + "/2/users/{id}/bookmarks"
        url = url.replace("{id}", str(id))
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        headers = {}
        # Prepare request data
        json_data = None
        # Determine pagination parameter name
        pagination_param_name = "pagination_token"
        # Start with provided pagination_token, or None for first page
        # Check if pagination_token parameter exists in the method signature
        current_pagination_token = pagination_token
        while True:
            # Build query parameters for this page
            page_params = {}
            if max_results is not None:
                page_params["max_results"] = max_results
            if tweet_fields is not None:
                page_params["tweet.fields"] = ",".join(
                    str(item) for item in tweet_fields
                )
            if expansions is not None:
                page_params["expansions"] = ",".join(str(item) for item in expansions)
            if media_fields is not None:
                page_params["media.fields"] = ",".join(
                    str(item) for item in media_fields
                )
            if poll_fields is not None:
                page_params["poll.fields"] = ",".join(str(item) for item in poll_fields)
            if user_fields is not None:
                page_params["user.fields"] = ",".join(str(item) for item in user_fields)
            if place_fields is not None:
                page_params["place.fields"] = ",".join(
                    str(item) for item in place_fields
                )
            # Add pagination token for this page
            if current_pagination_token:
                page_params[pagination_param_name] = current_pagination_token
            # Select authentication method (same logic as regular_request)
            # Priority strategy (matches TypeScript):
            # 1. If endpoint only accepts one method, use that (if available)
            # 2. If endpoint accepts multiple methods:
            #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
            #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
            # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
            page_selected_auth = None
            # Check what auth methods we have available
            page_available_bearer = bool(self.client.bearer_token)
            page_available_oauth2 = bool(self.client.access_token)
            page_available_oauth1 = bool(
                self.client.auth and self.client.auth.access_token
            )
            # Count acceptable schemes
            page_acceptable_schemes = []
            page_acceptable_schemes.append("OAuth2UserToken")
            # If only one scheme is acceptable, use it if available
            if len(page_acceptable_schemes) == 1:
                scheme = page_acceptable_schemes[0]
                if scheme == "BearerToken" and page_available_bearer:
                    page_selected_auth = "bearer_token"
                elif scheme == "OAuth2UserToken" and page_available_oauth2:
                    page_selected_auth = "oauth2_user_context"
                elif scheme == "UserToken" and page_available_oauth1:
                    page_selected_auth = "oauth1"
            # Multiple schemes acceptable - use priority based on operation type
            elif len(page_acceptable_schemes) > 1:
                is_write_operation = "get" in ["POST", "PUT", "DELETE", "PATCH"]
                if is_write_operation:
                    # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                    if "UserToken" in page_acceptable_schemes and page_available_oauth1:
                        page_selected_auth = "oauth1"
                    elif (
                        "OAuth2UserToken" in page_acceptable_schemes
                        and page_available_oauth2
                    ):
                        page_selected_auth = "oauth2_user_context"
                    elif (
                        "BearerToken" in page_acceptable_schemes
                        and page_available_bearer
                    ):
                        page_selected_auth = "bearer_token"
                else:
                    # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                    if (
                        "BearerToken" in page_acceptable_schemes
                        and page_available_bearer
                    ):
                        page_selected_auth = "bearer_token"
                    elif (
                        "OAuth2UserToken" in page_acceptable_schemes
                        and page_available_oauth2
                    ):
                        page_selected_auth = "oauth2_user_context"
                    elif (
                        "UserToken" in page_acceptable_schemes and page_available_oauth1
                    ):
                        page_selected_auth = "oauth1"
            # Apply selected authentication for this page
            page_headers = headers.copy()
            if page_selected_auth == "oauth1":
                # OAuth1 authentication - build proper OAuth1 header dynamically
                # Build OAuth1 header with method, URL, and body
                # For OAuth1, we need to include query params in the URL for signature
                full_url = url
                if page_params:
                    query_string = urllib.parse.urlencode(page_params)
                    full_url = f"{url}?{query_string}" if query_string else url
                # Prepare body for OAuth1 signature (form-encoded, not JSON)
                body_string = ""
                # Build OAuth1 authorization header
                oauth_header = self.client.auth.build_request_header(
                    method="get", url=full_url, body=body_string
                )
                page_headers["Authorization"] = oauth_header
            elif page_selected_auth == "bearer_token":
                # Bearer token authentication
                if self.client.bearer_token:
                    page_headers["Authorization"] = f"Bearer {self.client.bearer_token}"
                elif self.client.access_token:
                    page_headers["Authorization"] = f"Bearer {self.client.access_token}"
            elif page_selected_auth == "oauth2_user_context":
                # OAuth2 User Token authentication
                if self.client.access_token:
                    page_headers["Authorization"] = f"Bearer {self.client.access_token}"
                    # Check if token needs refresh
                    if self.client.oauth2_auth and self.client.token:
                        if self.client.is_token_expired():
                            self.client.refresh_token()
                            if self.client.access_token:
                                page_headers["Authorization"] = (
                                    f"Bearer {self.client.access_token}"
                                )
            # Make the request
            if not page_selected_auth:
                # No suitable auth method found - validate authentication
                required_schemes = (
                    page_acceptable_schemes
                    if "page_acceptable_schemes" in locals()
                    else []
                )
                if required_schemes:
                    available = []
                    if page_available_bearer and "BearerToken" in required_schemes:
                        available.append("BearerToken")
                    if page_available_oauth2 and "OAuth2UserToken" in required_schemes:
                        available.append("OAuth2UserToken")
                    if page_available_oauth1 and "UserToken" in required_schemes:
                        available.append("UserToken")
                    if not available:
                        raise ValueError(
                            f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and page_available_bearer) or (s == 'OAuth2UserToken' and page_available_oauth2) or (s == 'UserToken' and page_available_oauth1)]}"
                        )
            response = self.client.session.get(
                url,
                params=page_params,
                headers=page_headers,
            )
            # Check for errors
            response.raise_for_status()
            # Parse the response data
            response_data = response.json()
            # Convert to Pydantic model if applicable
            page_response = GetBookmarksResponse.model_validate(response_data)
            # Yield this page
            yield page_response
            # Extract next_token from response
            next_token = None
            try:
                # Try response.meta.next_token (most common pattern)
                if hasattr(page_response, "meta") and page_response.meta is not None:
                    meta = page_response.meta
                    # If meta is a Pydantic model, try to dump it
                    if hasattr(meta, "model_dump"):
                        try:
                            meta_dict = meta.model_dump()
                            next_token = meta_dict.get("next_token")
                        except (AttributeError, TypeError):
                            pass
                    # Otherwise try attribute access
                    if not next_token and hasattr(meta, "next_token"):
                        next_token = getattr(meta, "next_token", None)
                    # If meta is a dict, access it directly
                    if not next_token and isinstance(meta, dict):
                        next_token = meta.get("next_token")
            except (AttributeError, TypeError):
                pass
            # Try dict access if we have a dict
            if not next_token and isinstance(response_data, dict):
                try:
                    meta = response_data.get("meta")
                    if meta and isinstance(meta, dict):
                        next_token = meta.get("next_token")
                except (AttributeError, TypeError, KeyError):
                    pass
            # If no next_token, we're done
            if not next_token:
                break
            # Update token for next iteration
            current_pagination_token = next_token

            # Optional: Add rate limit backoff here if needed
            # time.sleep(0.1)  # Small delay to avoid rate limits


    def create_bookmark(
        self, id: Any, body: CreateBookmarkRequest
    ) -> CreateBookmarkResponse:
        """
        Create Bookmark
        Adds a post to the authenticated users bookmarks.
        Args:
            id: The ID of the authenticated source User for whom to add bookmarks.
            body: Request body
        Returns:
            CreateBookmarkResponse: Response data
        """
        url = self.client.base_url + "/2/users/{id}/bookmarks"
        url = url.replace("{id}", str(id))
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        params = {}
        headers = {}
        headers["Content-Type"] = "application/json"
        # Prepare request data
        json_data = None
        if body is not None:
            json_data = (
                body.model_dump(exclude_none=True)
                if hasattr(body, "model_dump")
                else body
            )
        # Select authentication method based on endpoint requirements and available credentials
        # Priority strategy (matches TypeScript):
        # 1. If endpoint only accepts one method, use that (if available)
        # 2. If endpoint accepts multiple methods:
        #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
        #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
        # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
        selected_auth = None
        # Check what auth methods we have available
        available_bearer = bool(self.client.bearer_token)
        available_oauth2 = bool(self.client.access_token)
        available_oauth1 = bool(self.client.auth and self.client.auth.access_token)
        # Count acceptable schemes
        acceptable_schemes = []
        acceptable_schemes.append("OAuth2UserToken")
        # If only one scheme is acceptable, use it if available
        if len(acceptable_schemes) == 1:
            scheme = acceptable_schemes[0]
            if scheme == "BearerToken" and available_bearer:
                selected_auth = "bearer_token"
            elif scheme == "OAuth2UserToken" and available_oauth2:
                selected_auth = "oauth2_user_context"
            elif scheme == "UserToken" and available_oauth1:
                selected_auth = "oauth1"
        # Multiple schemes acceptable - use priority based on operation type
        elif len(acceptable_schemes) > 1:
            is_write_operation = "post" in ["POST", "PUT", "DELETE", "PATCH"]
            if is_write_operation:
                # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                if "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
            else:
                # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                if "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
        # Apply selected authentication
        if selected_auth == "oauth1":
            # OAuth1 authentication - build proper OAuth1 header dynamically
            # Build OAuth1 header with method, URL, and body
            # For OAuth1, we need to include query params in the URL for signature
            full_url = url
            if params:
                query_string = urllib.parse.urlencode(params)
                full_url = f"{url}?{query_string}" if query_string else url
            # Prepare body for OAuth1 signature (form-encoded, not JSON)
            body_string = ""
            if json_data:
                # OAuth1 spec: JSON bodies are NOT included in signature
                # But we still need to pass the body for the request
                body_string = ""
            # Build OAuth1 authorization header
            oauth_header = self.client.auth.build_request_header(
                method="post", url=full_url, body=body_string
            )
            headers["Authorization"] = oauth_header
        elif selected_auth == "bearer_token":
            # Bearer token authentication
            if self.client.bearer_token:
                headers["Authorization"] = f"Bearer {self.client.bearer_token}"
            elif self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
        elif selected_auth == "oauth2_user_context":
            # OAuth2 User Token authentication
            if self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
                # Check if token needs refresh
                if self.client.oauth2_auth and self.client.token:
                    if self.client.is_token_expired():
                        self.client.refresh_token()
                        if self.client.access_token:
                            headers["Authorization"] = (
                                f"Bearer {self.client.access_token}"
                            )
        # Make the request
        if not selected_auth:
            # No suitable auth method found - validate authentication
            required_schemes = (
                acceptable_schemes if "acceptable_schemes" in locals() else []
            )
            if required_schemes:
                available = []
                if available_bearer and "BearerToken" in required_schemes:
                    available.append("BearerToken")
                if available_oauth2 and "OAuth2UserToken" in required_schemes:
                    available.append("OAuth2UserToken")
                if available_oauth1 and "UserToken" in required_schemes:
                    available.append("UserToken")
                if not available:
                    raise ValueError(
                        f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and available_bearer) or (s == 'OAuth2UserToken' and available_oauth2) or (s == 'UserToken' and available_oauth1)]}"
                    )
        response = self.client.session.post(
            url,
            params=params,
            headers=headers,
            json=json_data,
        )
        # Check for errors
        response.raise_for_status()
        # Parse the response data
        response_data = response.json()
        # Convert to Pydantic model if applicable
        return CreateBookmarkResponse.model_validate(response_data)


    def get_liked_posts(
        self,
        id: Any,
        max_results: int = None,
        pagination_token: Any = None,
        tweet_fields: List = None,
        expansions: List = None,
        media_fields: List = None,
        poll_fields: List = None,
        user_fields: List = None,
        place_fields: List = None,
    ) -> Iterator[GetLikedPostsResponse]:
        """
        Get liked Posts
        Retrieves a list of Posts liked by a specific User by their ID.
        Args:
            id: The ID of the User to lookup.
            max_results: The maximum number of results.
            pagination_token: This parameter is used to get the next 'page' of results.
            tweet_fields: A comma separated list of Tweet fields to display.
            expansions: A comma separated list of fields to expand.
            media_fields: A comma separated list of Media fields to display.
            poll_fields: A comma separated list of Poll fields to display.
            user_fields: A comma separated list of User fields to display.
            place_fields: A comma separated list of Place fields to display.
            Yields:
            GetLikedPostsResponse: One page of results at a time. Automatically handles pagination using next_token.
        Note:
            This method automatically paginates through all results. To get just the first page,
            you can call it once and break, or use the pagination_token parameter to start at a specific page.
        """
        url = self.client.base_url + "/2/users/{id}/liked_tweets"
        url = url.replace("{id}", str(id))
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        # UserToken: OAuth1.0a authentication - header will be built dynamically in request
        # OAuth1 header must be built per-request with method, URL, and body
        # This is handled in the request logic below
        headers = {}
        # Prepare request data
        json_data = None
        # Determine pagination parameter name
        pagination_param_name = "pagination_token"
        # Start with provided pagination_token, or None for first page
        # Check if pagination_token parameter exists in the method signature
        current_pagination_token = pagination_token
        while True:
            # Build query parameters for this page
            page_params = {}
            if max_results is not None:
                page_params["max_results"] = max_results
            if tweet_fields is not None:
                page_params["tweet.fields"] = ",".join(
                    str(item) for item in tweet_fields
                )
            if expansions is not None:
                page_params["expansions"] = ",".join(str(item) for item in expansions)
            if media_fields is not None:
                page_params["media.fields"] = ",".join(
                    str(item) for item in media_fields
                )
            if poll_fields is not None:
                page_params["poll.fields"] = ",".join(str(item) for item in poll_fields)
            if user_fields is not None:
                page_params["user.fields"] = ",".join(str(item) for item in user_fields)
            if place_fields is not None:
                page_params["place.fields"] = ",".join(
                    str(item) for item in place_fields
                )
            # Add pagination token for this page
            if current_pagination_token:
                page_params[pagination_param_name] = current_pagination_token
            # Select authentication method (same logic as regular_request)
            # Priority strategy (matches TypeScript):
            # 1. If endpoint only accepts one method, use that (if available)
            # 2. If endpoint accepts multiple methods:
            #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
            #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
            # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
            page_selected_auth = None
            # Check what auth methods we have available
            page_available_bearer = bool(self.client.bearer_token)
            page_available_oauth2 = bool(self.client.access_token)
            page_available_oauth1 = bool(
                self.client.auth and self.client.auth.access_token
            )
            # Count acceptable schemes
            page_acceptable_schemes = []
            page_acceptable_schemes.append("OAuth2UserToken")
            page_acceptable_schemes.append("UserToken")
            # If only one scheme is acceptable, use it if available
            if len(page_acceptable_schemes) == 1:
                scheme = page_acceptable_schemes[0]
                if scheme == "BearerToken" and page_available_bearer:
                    page_selected_auth = "bearer_token"
                elif scheme == "OAuth2UserToken" and page_available_oauth2:
                    page_selected_auth = "oauth2_user_context"
                elif scheme == "UserToken" and page_available_oauth1:
                    page_selected_auth = "oauth1"
            # Multiple schemes acceptable - use priority based on operation type
            elif len(page_acceptable_schemes) > 1:
                is_write_operation = "get" in ["POST", "PUT", "DELETE", "PATCH"]
                if is_write_operation:
                    # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                    if "UserToken" in page_acceptable_schemes and page_available_oauth1:
                        page_selected_auth = "oauth1"
                    elif (
                        "OAuth2UserToken" in page_acceptable_schemes
                        and page_available_oauth2
                    ):
                        page_selected_auth = "oauth2_user_context"
                    elif (
                        "BearerToken" in page_acceptable_schemes
                        and page_available_bearer
                    ):
                        page_selected_auth = "bearer_token"
                else:
                    # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                    if (
                        "BearerToken" in page_acceptable_schemes
                        and page_available_bearer
                    ):
                        page_selected_auth = "bearer_token"
                    elif (
                        "OAuth2UserToken" in page_acceptable_schemes
                        and page_available_oauth2
                    ):
                        page_selected_auth = "oauth2_user_context"
                    elif (
                        "UserToken" in page_acceptable_schemes and page_available_oauth1
                    ):
                        page_selected_auth = "oauth1"
            # Apply selected authentication for this page
            page_headers = headers.copy()
            if page_selected_auth == "oauth1":
                # OAuth1 authentication - build proper OAuth1 header dynamically
                # Build OAuth1 header with method, URL, and body
                # For OAuth1, we need to include query params in the URL for signature
                full_url = url
                if page_params:
                    query_string = urllib.parse.urlencode(page_params)
                    full_url = f"{url}?{query_string}" if query_string else url
                # Prepare body for OAuth1 signature (form-encoded, not JSON)
                body_string = ""
                # Build OAuth1 authorization header
                oauth_header = self.client.auth.build_request_header(
                    method="get", url=full_url, body=body_string
                )
                page_headers["Authorization"] = oauth_header
            elif page_selected_auth == "bearer_token":
                # Bearer token authentication
                if self.client.bearer_token:
                    page_headers["Authorization"] = f"Bearer {self.client.bearer_token}"
                elif self.client.access_token:
                    page_headers["Authorization"] = f"Bearer {self.client.access_token}"
            elif page_selected_auth == "oauth2_user_context":
                # OAuth2 User Token authentication
                if self.client.access_token:
                    page_headers["Authorization"] = f"Bearer {self.client.access_token}"
                    # Check if token needs refresh
                    if self.client.oauth2_auth and self.client.token:
                        if self.client.is_token_expired():
                            self.client.refresh_token()
                            if self.client.access_token:
                                page_headers["Authorization"] = (
                                    f"Bearer {self.client.access_token}"
                                )
            # Make the request
            if not page_selected_auth:
                # No suitable auth method found - validate authentication
                required_schemes = (
                    page_acceptable_schemes
                    if "page_acceptable_schemes" in locals()
                    else []
                )
                if required_schemes:
                    available = []
                    if page_available_bearer and "BearerToken" in required_schemes:
                        available.append("BearerToken")
                    if page_available_oauth2 and "OAuth2UserToken" in required_schemes:
                        available.append("OAuth2UserToken")
                    if page_available_oauth1 and "UserToken" in required_schemes:
                        available.append("UserToken")
                    if not available:
                        raise ValueError(
                            f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and page_available_bearer) or (s == 'OAuth2UserToken' and page_available_oauth2) or (s == 'UserToken' and page_available_oauth1)]}"
                        )
            response = self.client.session.get(
                url,
                params=page_params,
                headers=page_headers,
            )
            # Check for errors
            response.raise_for_status()
            # Parse the response data
            response_data = response.json()
            # Convert to Pydantic model if applicable
            page_response = GetLikedPostsResponse.model_validate(response_data)
            # Yield this page
            yield page_response
            # Extract next_token from response
            next_token = None
            try:
                # Try response.meta.next_token (most common pattern)
                if hasattr(page_response, "meta") and page_response.meta is not None:
                    meta = page_response.meta
                    # If meta is a Pydantic model, try to dump it
                    if hasattr(meta, "model_dump"):
                        try:
                            meta_dict = meta.model_dump()
                            next_token = meta_dict.get("next_token")
                        except (AttributeError, TypeError):
                            pass
                    # Otherwise try attribute access
                    if not next_token and hasattr(meta, "next_token"):
                        next_token = getattr(meta, "next_token", None)
                    # If meta is a dict, access it directly
                    if not next_token and isinstance(meta, dict):
                        next_token = meta.get("next_token")
            except (AttributeError, TypeError):
                pass
            # Try dict access if we have a dict
            if not next_token and isinstance(response_data, dict):
                try:
                    meta = response_data.get("meta")
                    if meta and isinstance(meta, dict):
                        next_token = meta.get("next_token")
                except (AttributeError, TypeError, KeyError):
                    pass
            # If no next_token, we're done
            if not next_token:
                break
            # Update token for next iteration
            current_pagination_token = next_token

            # Optional: Add rate limit backoff here if needed
            # time.sleep(0.1)  # Small delay to avoid rate limits


    def get_pinned_lists(
        self,
        id: Any,
        list_fields: List = None,
        expansions: List = None,
        user_fields: List = None,
    ) -> GetPinnedListsResponse:
        """
        Get pinned Lists
        Retrieves a list of Lists pinned by the authenticated user.
        Args:
            id: The ID of the authenticated source User for whom to return results.
            list_fields: A comma separated list of List fields to display.
            expansions: A comma separated list of fields to expand.
            user_fields: A comma separated list of User fields to display.
            Returns:
            GetPinnedListsResponse: Response data
        """
        url = self.client.base_url + "/2/users/{id}/pinned_lists"
        url = url.replace("{id}", str(id))
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        # UserToken: OAuth1.0a authentication - header will be built dynamically in request
        # OAuth1 header must be built per-request with method, URL, and body
        # This is handled in the request logic below
        params = {}
        if list_fields is not None:
            params["list.fields"] = ",".join(str(item) for item in list_fields)
        if expansions is not None:
            params["expansions"] = ",".join(str(item) for item in expansions)
        if user_fields is not None:
            params["user.fields"] = ",".join(str(item) for item in user_fields)
        headers = {}
        # Prepare request data
        json_data = None
        # Select authentication method based on endpoint requirements and available credentials
        # Priority strategy (matches TypeScript):
        # 1. If endpoint only accepts one method, use that (if available)
        # 2. If endpoint accepts multiple methods:
        #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
        #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
        # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
        selected_auth = None
        # Check what auth methods we have available
        available_bearer = bool(self.client.bearer_token)
        available_oauth2 = bool(self.client.access_token)
        available_oauth1 = bool(self.client.auth and self.client.auth.access_token)
        # Count acceptable schemes
        acceptable_schemes = []
        acceptable_schemes.append("OAuth2UserToken")
        acceptable_schemes.append("UserToken")
        # If only one scheme is acceptable, use it if available
        if len(acceptable_schemes) == 1:
            scheme = acceptable_schemes[0]
            if scheme == "BearerToken" and available_bearer:
                selected_auth = "bearer_token"
            elif scheme == "OAuth2UserToken" and available_oauth2:
                selected_auth = "oauth2_user_context"
            elif scheme == "UserToken" and available_oauth1:
                selected_auth = "oauth1"
        # Multiple schemes acceptable - use priority based on operation type
        elif len(acceptable_schemes) > 1:
            is_write_operation = "get" in ["POST", "PUT", "DELETE", "PATCH"]
            if is_write_operation:
                # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                if "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
            else:
                # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                if "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
        # Apply selected authentication
        if selected_auth == "oauth1":
            # OAuth1 authentication - build proper OAuth1 header dynamically
            # Build OAuth1 header with method, URL, and body
            # For OAuth1, we need to include query params in the URL for signature
            full_url = url
            if params:
                query_string = urllib.parse.urlencode(params)
                full_url = f"{url}?{query_string}" if query_string else url
            # Prepare body for OAuth1 signature (form-encoded, not JSON)
            body_string = ""
            # Build OAuth1 authorization header
            oauth_header = self.client.auth.build_request_header(
                method="get", url=full_url, body=body_string
            )
            headers["Authorization"] = oauth_header
        elif selected_auth == "bearer_token":
            # Bearer token authentication
            if self.client.bearer_token:
                headers["Authorization"] = f"Bearer {self.client.bearer_token}"
            elif self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
        elif selected_auth == "oauth2_user_context":
            # OAuth2 User Token authentication
            if self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
                # Check if token needs refresh
                if self.client.oauth2_auth and self.client.token:
                    if self.client.is_token_expired():
                        self.client.refresh_token()
                        if self.client.access_token:
                            headers["Authorization"] = (
                                f"Bearer {self.client.access_token}"
                            )
        # Make the request
        if not selected_auth:
            # No suitable auth method found - validate authentication
            required_schemes = (
                acceptable_schemes if "acceptable_schemes" in locals() else []
            )
            if required_schemes:
                available = []
                if available_bearer and "BearerToken" in required_schemes:
                    available.append("BearerToken")
                if available_oauth2 and "OAuth2UserToken" in required_schemes:
                    available.append("OAuth2UserToken")
                if available_oauth1 and "UserToken" in required_schemes:
                    available.append("UserToken")
                if not available:
                    raise ValueError(
                        f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and available_bearer) or (s == 'OAuth2UserToken' and available_oauth2) or (s == 'UserToken' and available_oauth1)]}"
                    )
        response = self.client.session.get(
            url,
            params=params,
            headers=headers,
        )
        # Check for errors
        response.raise_for_status()
        # Parse the response data
        response_data = response.json()
        # Convert to Pydantic model if applicable
        return GetPinnedListsResponse.model_validate(response_data)


    def pin_list(self, id: Any, body: PinListRequest) -> PinListResponse:
        """
        Pin List
        Causes the authenticated user to pin a specific List by its ID.
        Args:
            id: The ID of the authenticated source User that will pin the List.
            body: Request body
        Returns:
            PinListResponse: Response data
        """
        url = self.client.base_url + "/2/users/{id}/pinned_lists"
        url = url.replace("{id}", str(id))
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        # UserToken: OAuth1.0a authentication - header will be built dynamically in request
        # OAuth1 header must be built per-request with method, URL, and body
        # This is handled in the request logic below
        params = {}
        headers = {}
        headers["Content-Type"] = "application/json"
        # Prepare request data
        json_data = None
        if body is not None:
            json_data = (
                body.model_dump(exclude_none=True)
                if hasattr(body, "model_dump")
                else body
            )
        # Select authentication method based on endpoint requirements and available credentials
        # Priority strategy (matches TypeScript):
        # 1. If endpoint only accepts one method, use that (if available)
        # 2. If endpoint accepts multiple methods:
        #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
        #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
        # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
        selected_auth = None
        # Check what auth methods we have available
        available_bearer = bool(self.client.bearer_token)
        available_oauth2 = bool(self.client.access_token)
        available_oauth1 = bool(self.client.auth and self.client.auth.access_token)
        # Count acceptable schemes
        acceptable_schemes = []
        acceptable_schemes.append("OAuth2UserToken")
        acceptable_schemes.append("UserToken")
        # If only one scheme is acceptable, use it if available
        if len(acceptable_schemes) == 1:
            scheme = acceptable_schemes[0]
            if scheme == "BearerToken" and available_bearer:
                selected_auth = "bearer_token"
            elif scheme == "OAuth2UserToken" and available_oauth2:
                selected_auth = "oauth2_user_context"
            elif scheme == "UserToken" and available_oauth1:
                selected_auth = "oauth1"
        # Multiple schemes acceptable - use priority based on operation type
        elif len(acceptable_schemes) > 1:
            is_write_operation = "post" in ["POST", "PUT", "DELETE", "PATCH"]
            if is_write_operation:
                # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                if "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
            else:
                # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                if "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
        # Apply selected authentication
        if selected_auth == "oauth1":
            # OAuth1 authentication - build proper OAuth1 header dynamically
            # Build OAuth1 header with method, URL, and body
            # For OAuth1, we need to include query params in the URL for signature
            full_url = url
            if params:
                query_string = urllib.parse.urlencode(params)
                full_url = f"{url}?{query_string}" if query_string else url
            # Prepare body for OAuth1 signature (form-encoded, not JSON)
            body_string = ""
            if json_data:
                # OAuth1 spec: JSON bodies are NOT included in signature
                # But we still need to pass the body for the request
                body_string = ""
            # Build OAuth1 authorization header
            oauth_header = self.client.auth.build_request_header(
                method="post", url=full_url, body=body_string
            )
            headers["Authorization"] = oauth_header
        elif selected_auth == "bearer_token":
            # Bearer token authentication
            if self.client.bearer_token:
                headers["Authorization"] = f"Bearer {self.client.bearer_token}"
            elif self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
        elif selected_auth == "oauth2_user_context":
            # OAuth2 User Token authentication
            if self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
                # Check if token needs refresh
                if self.client.oauth2_auth and self.client.token:
                    if self.client.is_token_expired():
                        self.client.refresh_token()
                        if self.client.access_token:
                            headers["Authorization"] = (
                                f"Bearer {self.client.access_token}"
                            )
        # Make the request
        if not selected_auth:
            # No suitable auth method found - validate authentication
            required_schemes = (
                acceptable_schemes if "acceptable_schemes" in locals() else []
            )
            if required_schemes:
                available = []
                if available_bearer and "BearerToken" in required_schemes:
                    available.append("BearerToken")
                if available_oauth2 and "OAuth2UserToken" in required_schemes:
                    available.append("OAuth2UserToken")
                if available_oauth1 and "UserToken" in required_schemes:
                    available.append("UserToken")
                if not available:
                    raise ValueError(
                        f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and available_bearer) or (s == 'OAuth2UserToken' and available_oauth2) or (s == 'UserToken' and available_oauth1)]}"
                    )
        response = self.client.session.post(
            url,
            params=params,
            headers=headers,
            json=json_data,
        )
        # Check for errors
        response.raise_for_status()
        # Parse the response data
        response_data = response.json()
        # Convert to Pydantic model if applicable
        return PinListResponse.model_validate(response_data)


    def get_mentions(
        self,
        id: Any,
        since_id: Any = None,
        until_id: Any = None,
        max_results: int = None,
        pagination_token: Any = None,
        start_time: str = None,
        end_time: str = None,
        tweet_fields: List = None,
        expansions: List = None,
        media_fields: List = None,
        poll_fields: List = None,
        user_fields: List = None,
        place_fields: List = None,
    ) -> Iterator[GetMentionsResponse]:
        """
        Get mentions
        Retrieves a list of Posts that mention a specific User by their ID.
        Args:
            id: The ID of the User to lookup.
            since_id: The minimum Post ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
            until_id: The maximum Post ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
            max_results: The maximum number of results.
            pagination_token: This parameter is used to get the next 'page' of results.
            start_time: YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Posts will be provided. The since_id parameter takes precedence if it is also specified.
            end_time: YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Posts will be provided. The until_id parameter takes precedence if it is also specified.
            tweet_fields: A comma separated list of Tweet fields to display.
            expansions: A comma separated list of fields to expand.
            media_fields: A comma separated list of Media fields to display.
            poll_fields: A comma separated list of Poll fields to display.
            user_fields: A comma separated list of User fields to display.
            place_fields: A comma separated list of Place fields to display.
            Yields:
            GetMentionsResponse: One page of results at a time. Automatically handles pagination using next_token.
        Note:
            This method automatically paginates through all results. To get just the first page,
            you can call it once and break, or use the pagination_token parameter to start at a specific page.
        """
        url = self.client.base_url + "/2/users/{id}/mentions"
        url = url.replace("{id}", str(id))
        # Priority: bearer_token > access_token (matches TypeScript behavior)
        if self.client.bearer_token:
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.bearer_token}"
            )
        elif self.client.access_token:
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        # UserToken: OAuth1.0a authentication - header will be built dynamically in request
        # OAuth1 header must be built per-request with method, URL, and body
        # This is handled in the request logic below
        headers = {}
        # Prepare request data
        json_data = None
        # Determine pagination parameter name
        pagination_param_name = "pagination_token"
        # Start with provided pagination_token, or None for first page
        # Check if pagination_token parameter exists in the method signature
        current_pagination_token = pagination_token
        while True:
            # Build query parameters for this page
            page_params = {}
            if since_id is not None:
                page_params["since_id"] = since_id
            if until_id is not None:
                page_params["until_id"] = until_id
            if max_results is not None:
                page_params["max_results"] = max_results
            if start_time is not None:
                page_params["start_time"] = start_time
            if end_time is not None:
                page_params["end_time"] = end_time
            if tweet_fields is not None:
                page_params["tweet.fields"] = ",".join(
                    str(item) for item in tweet_fields
                )
            if expansions is not None:
                page_params["expansions"] = ",".join(str(item) for item in expansions)
            if media_fields is not None:
                page_params["media.fields"] = ",".join(
                    str(item) for item in media_fields
                )
            if poll_fields is not None:
                page_params["poll.fields"] = ",".join(str(item) for item in poll_fields)
            if user_fields is not None:
                page_params["user.fields"] = ",".join(str(item) for item in user_fields)
            if place_fields is not None:
                page_params["place.fields"] = ",".join(
                    str(item) for item in place_fields
                )
            # Add pagination token for this page
            if current_pagination_token:
                page_params[pagination_param_name] = current_pagination_token
            # Select authentication method (same logic as regular_request)
            # Priority strategy (matches TypeScript):
            # 1. If endpoint only accepts one method, use that (if available)
            # 2. If endpoint accepts multiple methods:
            #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
            #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
            # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
            page_selected_auth = None
            # Check what auth methods we have available
            page_available_bearer = bool(self.client.bearer_token)
            page_available_oauth2 = bool(self.client.access_token)
            page_available_oauth1 = bool(
                self.client.auth and self.client.auth.access_token
            )
            # Count acceptable schemes
            page_acceptable_schemes = []
            page_acceptable_schemes.append("BearerToken")
            page_acceptable_schemes.append("OAuth2UserToken")
            page_acceptable_schemes.append("UserToken")
            # If only one scheme is acceptable, use it if available
            if len(page_acceptable_schemes) == 1:
                scheme = page_acceptable_schemes[0]
                if scheme == "BearerToken" and page_available_bearer:
                    page_selected_auth = "bearer_token"
                elif scheme == "OAuth2UserToken" and page_available_oauth2:
                    page_selected_auth = "oauth2_user_context"
                elif scheme == "UserToken" and page_available_oauth1:
                    page_selected_auth = "oauth1"
            # Multiple schemes acceptable - use priority based on operation type
            elif len(page_acceptable_schemes) > 1:
                is_write_operation = "get" in ["POST", "PUT", "DELETE", "PATCH"]
                if is_write_operation:
                    # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                    if "UserToken" in page_acceptable_schemes and page_available_oauth1:
                        page_selected_auth = "oauth1"
                    elif (
                        "OAuth2UserToken" in page_acceptable_schemes
                        and page_available_oauth2
                    ):
                        page_selected_auth = "oauth2_user_context"
                    elif (
                        "BearerToken" in page_acceptable_schemes
                        and page_available_bearer
                    ):
                        page_selected_auth = "bearer_token"
                else:
                    # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                    if (
                        "BearerToken" in page_acceptable_schemes
                        and page_available_bearer
                    ):
                        page_selected_auth = "bearer_token"
                    elif (
                        "OAuth2UserToken" in page_acceptable_schemes
                        and page_available_oauth2
                    ):
                        page_selected_auth = "oauth2_user_context"
                    elif (
                        "UserToken" in page_acceptable_schemes and page_available_oauth1
                    ):
                        page_selected_auth = "oauth1"
            # Apply selected authentication for this page
            page_headers = headers.copy()
            if page_selected_auth == "oauth1":
                # OAuth1 authentication - build proper OAuth1 header dynamically
                # Build OAuth1 header with method, URL, and body
                # For OAuth1, we need to include query params in the URL for signature
                full_url = url
                if page_params:
                    query_string = urllib.parse.urlencode(page_params)
                    full_url = f"{url}?{query_string}" if query_string else url
                # Prepare body for OAuth1 signature (form-encoded, not JSON)
                body_string = ""
                # Build OAuth1 authorization header
                oauth_header = self.client.auth.build_request_header(
                    method="get", url=full_url, body=body_string
                )
                page_headers["Authorization"] = oauth_header
            elif page_selected_auth == "bearer_token":
                # Bearer token authentication
                if self.client.bearer_token:
                    page_headers["Authorization"] = f"Bearer {self.client.bearer_token}"
                elif self.client.access_token:
                    page_headers["Authorization"] = f"Bearer {self.client.access_token}"
            elif page_selected_auth == "oauth2_user_context":
                # OAuth2 User Token authentication
                if self.client.access_token:
                    page_headers["Authorization"] = f"Bearer {self.client.access_token}"
                    # Check if token needs refresh
                    if self.client.oauth2_auth and self.client.token:
                        if self.client.is_token_expired():
                            self.client.refresh_token()
                            if self.client.access_token:
                                page_headers["Authorization"] = (
                                    f"Bearer {self.client.access_token}"
                                )
            # Make the request
            if not page_selected_auth:
                # No suitable auth method found - validate authentication
                required_schemes = (
                    page_acceptable_schemes
                    if "page_acceptable_schemes" in locals()
                    else []
                )
                if required_schemes:
                    available = []
                    if page_available_bearer and "BearerToken" in required_schemes:
                        available.append("BearerToken")
                    if page_available_oauth2 and "OAuth2UserToken" in required_schemes:
                        available.append("OAuth2UserToken")
                    if page_available_oauth1 and "UserToken" in required_schemes:
                        available.append("UserToken")
                    if not available:
                        raise ValueError(
                            f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and page_available_bearer) or (s == 'OAuth2UserToken' and page_available_oauth2) or (s == 'UserToken' and page_available_oauth1)]}"
                        )
            response = self.client.session.get(
                url,
                params=page_params,
                headers=page_headers,
            )
            # Check for errors
            response.raise_for_status()
            # Parse the response data
            response_data = response.json()
            # Convert to Pydantic model if applicable
            page_response = GetMentionsResponse.model_validate(response_data)
            # Yield this page
            yield page_response
            # Extract next_token from response
            next_token = None
            try:
                # Try response.meta.next_token (most common pattern)
                if hasattr(page_response, "meta") and page_response.meta is not None:
                    meta = page_response.meta
                    # If meta is a Pydantic model, try to dump it
                    if hasattr(meta, "model_dump"):
                        try:
                            meta_dict = meta.model_dump()
                            next_token = meta_dict.get("next_token")
                        except (AttributeError, TypeError):
                            pass
                    # Otherwise try attribute access
                    if not next_token and hasattr(meta, "next_token"):
                        next_token = getattr(meta, "next_token", None)
                    # If meta is a dict, access it directly
                    if not next_token and isinstance(meta, dict):
                        next_token = meta.get("next_token")
            except (AttributeError, TypeError):
                pass
            # Try dict access if we have a dict
            if not next_token and isinstance(response_data, dict):
                try:
                    meta = response_data.get("meta")
                    if meta and isinstance(meta, dict):
                        next_token = meta.get("next_token")
                except (AttributeError, TypeError, KeyError):
                    pass
            # If no next_token, we're done
            if not next_token:
                break
            # Update token for next iteration
            current_pagination_token = next_token

            # Optional: Add rate limit backoff here if needed
            # time.sleep(0.1)  # Small delay to avoid rate limits


    def get_bookmark_folders(
        self, id: Any, max_results: int = None, pagination_token: Any = None
    ) -> Iterator[GetBookmarkFoldersResponse]:
        """
        Get Bookmark folders
        Retrieves a list of Bookmark folders created by the authenticated user.
        Args:
            id: The ID of the authenticated source User for whom to return results.
            max_results: The maximum number of results.
            pagination_token: This parameter is used to get the next 'page' of results.
            Yields:
            GetBookmarkFoldersResponse: One page of results at a time. Automatically handles pagination using next_token.
        Note:
            This method automatically paginates through all results. To get just the first page,
            you can call it once and break, or use the pagination_token parameter to start at a specific page.
        """
        url = self.client.base_url + "/2/users/{id}/bookmarks/folders"
        url = url.replace("{id}", str(id))
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        headers = {}
        # Prepare request data
        json_data = None
        # Determine pagination parameter name
        pagination_param_name = "pagination_token"
        # Start with provided pagination_token, or None for first page
        # Check if pagination_token parameter exists in the method signature
        current_pagination_token = pagination_token
        while True:
            # Build query parameters for this page
            page_params = {}
            if max_results is not None:
                page_params["max_results"] = max_results
            # Add pagination token for this page
            if current_pagination_token:
                page_params[pagination_param_name] = current_pagination_token
            # Select authentication method (same logic as regular_request)
            # Priority strategy (matches TypeScript):
            # 1. If endpoint only accepts one method, use that (if available)
            # 2. If endpoint accepts multiple methods:
            #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
            #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
            # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
            page_selected_auth = None
            # Check what auth methods we have available
            page_available_bearer = bool(self.client.bearer_token)
            page_available_oauth2 = bool(self.client.access_token)
            page_available_oauth1 = bool(
                self.client.auth and self.client.auth.access_token
            )
            # Count acceptable schemes
            page_acceptable_schemes = []
            page_acceptable_schemes.append("OAuth2UserToken")
            # If only one scheme is acceptable, use it if available
            if len(page_acceptable_schemes) == 1:
                scheme = page_acceptable_schemes[0]
                if scheme == "BearerToken" and page_available_bearer:
                    page_selected_auth = "bearer_token"
                elif scheme == "OAuth2UserToken" and page_available_oauth2:
                    page_selected_auth = "oauth2_user_context"
                elif scheme == "UserToken" and page_available_oauth1:
                    page_selected_auth = "oauth1"
            # Multiple schemes acceptable - use priority based on operation type
            elif len(page_acceptable_schemes) > 1:
                is_write_operation = "get" in ["POST", "PUT", "DELETE", "PATCH"]
                if is_write_operation:
                    # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                    if "UserToken" in page_acceptable_schemes and page_available_oauth1:
                        page_selected_auth = "oauth1"
                    elif (
                        "OAuth2UserToken" in page_acceptable_schemes
                        and page_available_oauth2
                    ):
                        page_selected_auth = "oauth2_user_context"
                    elif (
                        "BearerToken" in page_acceptable_schemes
                        and page_available_bearer
                    ):
                        page_selected_auth = "bearer_token"
                else:
                    # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                    if (
                        "BearerToken" in page_acceptable_schemes
                        and page_available_bearer
                    ):
                        page_selected_auth = "bearer_token"
                    elif (
                        "OAuth2UserToken" in page_acceptable_schemes
                        and page_available_oauth2
                    ):
                        page_selected_auth = "oauth2_user_context"
                    elif (
                        "UserToken" in page_acceptable_schemes and page_available_oauth1
                    ):
                        page_selected_auth = "oauth1"
            # Apply selected authentication for this page
            page_headers = headers.copy()
            if page_selected_auth == "oauth1":
                # OAuth1 authentication - build proper OAuth1 header dynamically
                # Build OAuth1 header with method, URL, and body
                # For OAuth1, we need to include query params in the URL for signature
                full_url = url
                if page_params:
                    query_string = urllib.parse.urlencode(page_params)
                    full_url = f"{url}?{query_string}" if query_string else url
                # Prepare body for OAuth1 signature (form-encoded, not JSON)
                body_string = ""
                # Build OAuth1 authorization header
                oauth_header = self.client.auth.build_request_header(
                    method="get", url=full_url, body=body_string
                )
                page_headers["Authorization"] = oauth_header
            elif page_selected_auth == "bearer_token":
                # Bearer token authentication
                if self.client.bearer_token:
                    page_headers["Authorization"] = f"Bearer {self.client.bearer_token}"
                elif self.client.access_token:
                    page_headers["Authorization"] = f"Bearer {self.client.access_token}"
            elif page_selected_auth == "oauth2_user_context":
                # OAuth2 User Token authentication
                if self.client.access_token:
                    page_headers["Authorization"] = f"Bearer {self.client.access_token}"
                    # Check if token needs refresh
                    if self.client.oauth2_auth and self.client.token:
                        if self.client.is_token_expired():
                            self.client.refresh_token()
                            if self.client.access_token:
                                page_headers["Authorization"] = (
                                    f"Bearer {self.client.access_token}"
                                )
            # Make the request
            if not page_selected_auth:
                # No suitable auth method found - validate authentication
                required_schemes = (
                    page_acceptable_schemes
                    if "page_acceptable_schemes" in locals()
                    else []
                )
                if required_schemes:
                    available = []
                    if page_available_bearer and "BearerToken" in required_schemes:
                        available.append("BearerToken")
                    if page_available_oauth2 and "OAuth2UserToken" in required_schemes:
                        available.append("OAuth2UserToken")
                    if page_available_oauth1 and "UserToken" in required_schemes:
                        available.append("UserToken")
                    if not available:
                        raise ValueError(
                            f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and page_available_bearer) or (s == 'OAuth2UserToken' and page_available_oauth2) or (s == 'UserToken' and page_available_oauth1)]}"
                        )
            response = self.client.session.get(
                url,
                params=page_params,
                headers=page_headers,
            )
            # Check for errors
            response.raise_for_status()
            # Parse the response data
            response_data = response.json()
            # Convert to Pydantic model if applicable
            page_response = GetBookmarkFoldersResponse.model_validate(response_data)
            # Yield this page
            yield page_response
            # Extract next_token from response
            next_token = None
            try:
                # Try response.meta.next_token (most common pattern)
                if hasattr(page_response, "meta") and page_response.meta is not None:
                    meta = page_response.meta
                    # If meta is a Pydantic model, try to dump it
                    if hasattr(meta, "model_dump"):
                        try:
                            meta_dict = meta.model_dump()
                            next_token = meta_dict.get("next_token")
                        except (AttributeError, TypeError):
                            pass
                    # Otherwise try attribute access
                    if not next_token and hasattr(meta, "next_token"):
                        next_token = getattr(meta, "next_token", None)
                    # If meta is a dict, access it directly
                    if not next_token and isinstance(meta, dict):
                        next_token = meta.get("next_token")
            except (AttributeError, TypeError):
                pass
            # Try dict access if we have a dict
            if not next_token and isinstance(response_data, dict):
                try:
                    meta = response_data.get("meta")
                    if meta and isinstance(meta, dict):
                        next_token = meta.get("next_token")
                except (AttributeError, TypeError, KeyError):
                    pass
            # If no next_token, we're done
            if not next_token:
                break
            # Update token for next iteration
            current_pagination_token = next_token

            # Optional: Add rate limit backoff here if needed
            # time.sleep(0.1)  # Small delay to avoid rate limits


    def get_reposts_of_me(
        self,
        max_results: int = None,
        pagination_token: Any = None,
        tweet_fields: List = None,
        expansions: List = None,
        media_fields: List = None,
        poll_fields: List = None,
        user_fields: List = None,
        place_fields: List = None,
    ) -> Iterator[GetRepostsOfMeResponse]:
        """
        Get Reposts of me
        Retrieves a list of Posts that repost content from the authenticated user.
        Args:
            max_results: The maximum number of results.
            pagination_token: This parameter is used to get the next 'page' of results.
            tweet_fields: A comma separated list of Tweet fields to display.
            expansions: A comma separated list of fields to expand.
            media_fields: A comma separated list of Media fields to display.
            poll_fields: A comma separated list of Poll fields to display.
            user_fields: A comma separated list of User fields to display.
            place_fields: A comma separated list of Place fields to display.
            Yields:
            GetRepostsOfMeResponse: One page of results at a time. Automatically handles pagination using next_token.
        Note:
            This method automatically paginates through all results. To get just the first page,
            you can call it once and break, or use the pagination_token parameter to start at a specific page.
        """
        url = self.client.base_url + "/2/users/reposts_of_me"
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        # UserToken: OAuth1.0a authentication - header will be built dynamically in request
        # OAuth1 header must be built per-request with method, URL, and body
        # This is handled in the request logic below
        headers = {}
        # Prepare request data
        json_data = None
        # Determine pagination parameter name
        pagination_param_name = "pagination_token"
        # Start with provided pagination_token, or None for first page
        # Check if pagination_token parameter exists in the method signature
        current_pagination_token = pagination_token
        while True:
            # Build query parameters for this page
            page_params = {}
            if max_results is not None:
                page_params["max_results"] = max_results
            if tweet_fields is not None:
                page_params["tweet.fields"] = ",".join(
                    str(item) for item in tweet_fields
                )
            if expansions is not None:
                page_params["expansions"] = ",".join(str(item) for item in expansions)
            if media_fields is not None:
                page_params["media.fields"] = ",".join(
                    str(item) for item in media_fields
                )
            if poll_fields is not None:
                page_params["poll.fields"] = ",".join(str(item) for item in poll_fields)
            if user_fields is not None:
                page_params["user.fields"] = ",".join(str(item) for item in user_fields)
            if place_fields is not None:
                page_params["place.fields"] = ",".join(
                    str(item) for item in place_fields
                )
            # Add pagination token for this page
            if current_pagination_token:
                page_params[pagination_param_name] = current_pagination_token
            # Select authentication method (same logic as regular_request)
            # Priority strategy (matches TypeScript):
            # 1. If endpoint only accepts one method, use that (if available)
            # 2. If endpoint accepts multiple methods:
            #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
            #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
            # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
            page_selected_auth = None
            # Check what auth methods we have available
            page_available_bearer = bool(self.client.bearer_token)
            page_available_oauth2 = bool(self.client.access_token)
            page_available_oauth1 = bool(
                self.client.auth and self.client.auth.access_token
            )
            # Count acceptable schemes
            page_acceptable_schemes = []
            page_acceptable_schemes.append("OAuth2UserToken")
            page_acceptable_schemes.append("UserToken")
            # If only one scheme is acceptable, use it if available
            if len(page_acceptable_schemes) == 1:
                scheme = page_acceptable_schemes[0]
                if scheme == "BearerToken" and page_available_bearer:
                    page_selected_auth = "bearer_token"
                elif scheme == "OAuth2UserToken" and page_available_oauth2:
                    page_selected_auth = "oauth2_user_context"
                elif scheme == "UserToken" and page_available_oauth1:
                    page_selected_auth = "oauth1"
            # Multiple schemes acceptable - use priority based on operation type
            elif len(page_acceptable_schemes) > 1:
                is_write_operation = "get" in ["POST", "PUT", "DELETE", "PATCH"]
                if is_write_operation:
                    # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                    if "UserToken" in page_acceptable_schemes and page_available_oauth1:
                        page_selected_auth = "oauth1"
                    elif (
                        "OAuth2UserToken" in page_acceptable_schemes
                        and page_available_oauth2
                    ):
                        page_selected_auth = "oauth2_user_context"
                    elif (
                        "BearerToken" in page_acceptable_schemes
                        and page_available_bearer
                    ):
                        page_selected_auth = "bearer_token"
                else:
                    # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                    if (
                        "BearerToken" in page_acceptable_schemes
                        and page_available_bearer
                    ):
                        page_selected_auth = "bearer_token"
                    elif (
                        "OAuth2UserToken" in page_acceptable_schemes
                        and page_available_oauth2
                    ):
                        page_selected_auth = "oauth2_user_context"
                    elif (
                        "UserToken" in page_acceptable_schemes and page_available_oauth1
                    ):
                        page_selected_auth = "oauth1"
            # Apply selected authentication for this page
            page_headers = headers.copy()
            if page_selected_auth == "oauth1":
                # OAuth1 authentication - build proper OAuth1 header dynamically
                # Build OAuth1 header with method, URL, and body
                # For OAuth1, we need to include query params in the URL for signature
                full_url = url
                if page_params:
                    query_string = urllib.parse.urlencode(page_params)
                    full_url = f"{url}?{query_string}" if query_string else url
                # Prepare body for OAuth1 signature (form-encoded, not JSON)
                body_string = ""
                # Build OAuth1 authorization header
                oauth_header = self.client.auth.build_request_header(
                    method="get", url=full_url, body=body_string
                )
                page_headers["Authorization"] = oauth_header
            elif page_selected_auth == "bearer_token":
                # Bearer token authentication
                if self.client.bearer_token:
                    page_headers["Authorization"] = f"Bearer {self.client.bearer_token}"
                elif self.client.access_token:
                    page_headers["Authorization"] = f"Bearer {self.client.access_token}"
            elif page_selected_auth == "oauth2_user_context":
                # OAuth2 User Token authentication
                if self.client.access_token:
                    page_headers["Authorization"] = f"Bearer {self.client.access_token}"
                    # Check if token needs refresh
                    if self.client.oauth2_auth and self.client.token:
                        if self.client.is_token_expired():
                            self.client.refresh_token()
                            if self.client.access_token:
                                page_headers["Authorization"] = (
                                    f"Bearer {self.client.access_token}"
                                )
            # Make the request
            if not page_selected_auth:
                # No suitable auth method found - validate authentication
                required_schemes = (
                    page_acceptable_schemes
                    if "page_acceptable_schemes" in locals()
                    else []
                )
                if required_schemes:
                    available = []
                    if page_available_bearer and "BearerToken" in required_schemes:
                        available.append("BearerToken")
                    if page_available_oauth2 and "OAuth2UserToken" in required_schemes:
                        available.append("OAuth2UserToken")
                    if page_available_oauth1 and "UserToken" in required_schemes:
                        available.append("UserToken")
                    if not available:
                        raise ValueError(
                            f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and page_available_bearer) or (s == 'OAuth2UserToken' and page_available_oauth2) or (s == 'UserToken' and page_available_oauth1)]}"
                        )
            response = self.client.session.get(
                url,
                params=page_params,
                headers=page_headers,
            )
            # Check for errors
            response.raise_for_status()
            # Parse the response data
            response_data = response.json()
            # Convert to Pydantic model if applicable
            page_response = GetRepostsOfMeResponse.model_validate(response_data)
            # Yield this page
            yield page_response
            # Extract next_token from response
            next_token = None
            try:
                # Try response.meta.next_token (most common pattern)
                if hasattr(page_response, "meta") and page_response.meta is not None:
                    meta = page_response.meta
                    # If meta is a Pydantic model, try to dump it
                    if hasattr(meta, "model_dump"):
                        try:
                            meta_dict = meta.model_dump()
                            next_token = meta_dict.get("next_token")
                        except (AttributeError, TypeError):
                            pass
                    # Otherwise try attribute access
                    if not next_token and hasattr(meta, "next_token"):
                        next_token = getattr(meta, "next_token", None)
                    # If meta is a dict, access it directly
                    if not next_token and isinstance(meta, dict):
                        next_token = meta.get("next_token")
            except (AttributeError, TypeError):
                pass
            # Try dict access if we have a dict
            if not next_token and isinstance(response_data, dict):
                try:
                    meta = response_data.get("meta")
                    if meta and isinstance(meta, dict):
                        next_token = meta.get("next_token")
                except (AttributeError, TypeError, KeyError):
                    pass
            # If no next_token, we're done
            if not next_token:
                break
            # Update token for next iteration
            current_pagination_token = next_token

            # Optional: Add rate limit backoff here if needed
            # time.sleep(0.1)  # Small delay to avoid rate limits


    def get_list_memberships(
        self,
        id: Any,
        max_results: int = None,
        pagination_token: Any = None,
        list_fields: List = None,
        expansions: List = None,
        user_fields: List = None,
    ) -> Iterator[GetListMembershipsResponse]:
        """
        Get List memberships
        Retrieves a list of Lists that a specific User is a member of by their ID.
        Args:
            id: The ID of the User to lookup.
            max_results: The maximum number of results.
            pagination_token: This parameter is used to get a specified 'page' of results.
            list_fields: A comma separated list of List fields to display.
            expansions: A comma separated list of fields to expand.
            user_fields: A comma separated list of User fields to display.
            Yields:
            GetListMembershipsResponse: One page of results at a time. Automatically handles pagination using next_token.
        Note:
            This method automatically paginates through all results. To get just the first page,
            you can call it once and break, or use the pagination_token parameter to start at a specific page.
        """
        url = self.client.base_url + "/2/users/{id}/list_memberships"
        url = url.replace("{id}", str(id))
        # Priority: bearer_token > access_token (matches TypeScript behavior)
        if self.client.bearer_token:
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.bearer_token}"
            )
        elif self.client.access_token:
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        # UserToken: OAuth1.0a authentication - header will be built dynamically in request
        # OAuth1 header must be built per-request with method, URL, and body
        # This is handled in the request logic below
        headers = {}
        # Prepare request data
        json_data = None
        # Determine pagination parameter name
        pagination_param_name = "pagination_token"
        # Start with provided pagination_token, or None for first page
        # Check if pagination_token parameter exists in the method signature
        current_pagination_token = pagination_token
        while True:
            # Build query parameters for this page
            page_params = {}
            if max_results is not None:
                page_params["max_results"] = max_results
            if list_fields is not None:
                page_params["list.fields"] = ",".join(str(item) for item in list_fields)
            if expansions is not None:
                page_params["expansions"] = ",".join(str(item) for item in expansions)
            if user_fields is not None:
                page_params["user.fields"] = ",".join(str(item) for item in user_fields)
            # Add pagination token for this page
            if current_pagination_token:
                page_params[pagination_param_name] = current_pagination_token
            # Select authentication method (same logic as regular_request)
            # Priority strategy (matches TypeScript):
            # 1. If endpoint only accepts one method, use that (if available)
            # 2. If endpoint accepts multiple methods:
            #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
            #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
            # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
            page_selected_auth = None
            # Check what auth methods we have available
            page_available_bearer = bool(self.client.bearer_token)
            page_available_oauth2 = bool(self.client.access_token)
            page_available_oauth1 = bool(
                self.client.auth and self.client.auth.access_token
            )
            # Count acceptable schemes
            page_acceptable_schemes = []
            page_acceptable_schemes.append("BearerToken")
            page_acceptable_schemes.append("OAuth2UserToken")
            page_acceptable_schemes.append("UserToken")
            # If only one scheme is acceptable, use it if available
            if len(page_acceptable_schemes) == 1:
                scheme = page_acceptable_schemes[0]
                if scheme == "BearerToken" and page_available_bearer:
                    page_selected_auth = "bearer_token"
                elif scheme == "OAuth2UserToken" and page_available_oauth2:
                    page_selected_auth = "oauth2_user_context"
                elif scheme == "UserToken" and page_available_oauth1:
                    page_selected_auth = "oauth1"
            # Multiple schemes acceptable - use priority based on operation type
            elif len(page_acceptable_schemes) > 1:
                is_write_operation = "get" in ["POST", "PUT", "DELETE", "PATCH"]
                if is_write_operation:
                    # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                    if "UserToken" in page_acceptable_schemes and page_available_oauth1:
                        page_selected_auth = "oauth1"
                    elif (
                        "OAuth2UserToken" in page_acceptable_schemes
                        and page_available_oauth2
                    ):
                        page_selected_auth = "oauth2_user_context"
                    elif (
                        "BearerToken" in page_acceptable_schemes
                        and page_available_bearer
                    ):
                        page_selected_auth = "bearer_token"
                else:
                    # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                    if (
                        "BearerToken" in page_acceptable_schemes
                        and page_available_bearer
                    ):
                        page_selected_auth = "bearer_token"
                    elif (
                        "OAuth2UserToken" in page_acceptable_schemes
                        and page_available_oauth2
                    ):
                        page_selected_auth = "oauth2_user_context"
                    elif (
                        "UserToken" in page_acceptable_schemes and page_available_oauth1
                    ):
                        page_selected_auth = "oauth1"
            # Apply selected authentication for this page
            page_headers = headers.copy()
            if page_selected_auth == "oauth1":
                # OAuth1 authentication - build proper OAuth1 header dynamically
                # Build OAuth1 header with method, URL, and body
                # For OAuth1, we need to include query params in the URL for signature
                full_url = url
                if page_params:
                    query_string = urllib.parse.urlencode(page_params)
                    full_url = f"{url}?{query_string}" if query_string else url
                # Prepare body for OAuth1 signature (form-encoded, not JSON)
                body_string = ""
                # Build OAuth1 authorization header
                oauth_header = self.client.auth.build_request_header(
                    method="get", url=full_url, body=body_string
                )
                page_headers["Authorization"] = oauth_header
            elif page_selected_auth == "bearer_token":
                # Bearer token authentication
                if self.client.bearer_token:
                    page_headers["Authorization"] = f"Bearer {self.client.bearer_token}"
                elif self.client.access_token:
                    page_headers["Authorization"] = f"Bearer {self.client.access_token}"
            elif page_selected_auth == "oauth2_user_context":
                # OAuth2 User Token authentication
                if self.client.access_token:
                    page_headers["Authorization"] = f"Bearer {self.client.access_token}"
                    # Check if token needs refresh
                    if self.client.oauth2_auth and self.client.token:
                        if self.client.is_token_expired():
                            self.client.refresh_token()
                            if self.client.access_token:
                                page_headers["Authorization"] = (
                                    f"Bearer {self.client.access_token}"
                                )
            # Make the request
            if not page_selected_auth:
                # No suitable auth method found - validate authentication
                required_schemes = (
                    page_acceptable_schemes
                    if "page_acceptable_schemes" in locals()
                    else []
                )
                if required_schemes:
                    available = []
                    if page_available_bearer and "BearerToken" in required_schemes:
                        available.append("BearerToken")
                    if page_available_oauth2 and "OAuth2UserToken" in required_schemes:
                        available.append("OAuth2UserToken")
                    if page_available_oauth1 and "UserToken" in required_schemes:
                        available.append("UserToken")
                    if not available:
                        raise ValueError(
                            f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and page_available_bearer) or (s == 'OAuth2UserToken' and page_available_oauth2) or (s == 'UserToken' and page_available_oauth1)]}"
                        )
            response = self.client.session.get(
                url,
                params=page_params,
                headers=page_headers,
            )
            # Check for errors
            response.raise_for_status()
            # Parse the response data
            response_data = response.json()
            # Convert to Pydantic model if applicable
            page_response = GetListMembershipsResponse.model_validate(response_data)
            # Yield this page
            yield page_response
            # Extract next_token from response
            next_token = None
            try:
                # Try response.meta.next_token (most common pattern)
                if hasattr(page_response, "meta") and page_response.meta is not None:
                    meta = page_response.meta
                    # If meta is a Pydantic model, try to dump it
                    if hasattr(meta, "model_dump"):
                        try:
                            meta_dict = meta.model_dump()
                            next_token = meta_dict.get("next_token")
                        except (AttributeError, TypeError):
                            pass
                    # Otherwise try attribute access
                    if not next_token and hasattr(meta, "next_token"):
                        next_token = getattr(meta, "next_token", None)
                    # If meta is a dict, access it directly
                    if not next_token and isinstance(meta, dict):
                        next_token = meta.get("next_token")
            except (AttributeError, TypeError):
                pass
            # Try dict access if we have a dict
            if not next_token and isinstance(response_data, dict):
                try:
                    meta = response_data.get("meta")
                    if meta and isinstance(meta, dict):
                        next_token = meta.get("next_token")
                except (AttributeError, TypeError, KeyError):
                    pass
            # If no next_token, we're done
            if not next_token:
                break
            # Update token for next iteration
            current_pagination_token = next_token

            # Optional: Add rate limit backoff here if needed
            # time.sleep(0.1)  # Small delay to avoid rate limits


    def get_blocking(
        self,
        id: Any,
        max_results: int = None,
        pagination_token: Any = None,
        user_fields: List = None,
        expansions: List = None,
        tweet_fields: List = None,
    ) -> Iterator[GetBlockingResponse]:
        """
        Get blocking
        Retrieves a list of Users blocked by the specified User ID.
        Args:
            id: The ID of the authenticated source User for whom to return results.
            max_results: The maximum number of results.
            pagination_token: This parameter is used to get a specified 'page' of results.
            user_fields: A comma separated list of User fields to display.
            expansions: A comma separated list of fields to expand.
            tweet_fields: A comma separated list of Tweet fields to display.
            Yields:
            GetBlockingResponse: One page of results at a time. Automatically handles pagination using next_token.
        Note:
            This method automatically paginates through all results. To get just the first page,
            you can call it once and break, or use the pagination_token parameter to start at a specific page.
        """
        url = self.client.base_url + "/2/users/{id}/blocking"
        url = url.replace("{id}", str(id))
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        # UserToken: OAuth1.0a authentication - header will be built dynamically in request
        # OAuth1 header must be built per-request with method, URL, and body
        # This is handled in the request logic below
        headers = {}
        # Prepare request data
        json_data = None
        # Determine pagination parameter name
        pagination_param_name = "pagination_token"
        # Start with provided pagination_token, or None for first page
        # Check if pagination_token parameter exists in the method signature
        current_pagination_token = pagination_token
        while True:
            # Build query parameters for this page
            page_params = {}
            if max_results is not None:
                page_params["max_results"] = max_results
            if user_fields is not None:
                page_params["user.fields"] = ",".join(str(item) for item in user_fields)
            if expansions is not None:
                page_params["expansions"] = ",".join(str(item) for item in expansions)
            if tweet_fields is not None:
                page_params["tweet.fields"] = ",".join(
                    str(item) for item in tweet_fields
                )
            # Add pagination token for this page
            if current_pagination_token:
                page_params[pagination_param_name] = current_pagination_token
            # Select authentication method (same logic as regular_request)
            # Priority strategy (matches TypeScript):
            # 1. If endpoint only accepts one method, use that (if available)
            # 2. If endpoint accepts multiple methods:
            #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
            #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
            # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
            page_selected_auth = None
            # Check what auth methods we have available
            page_available_bearer = bool(self.client.bearer_token)
            page_available_oauth2 = bool(self.client.access_token)
            page_available_oauth1 = bool(
                self.client.auth and self.client.auth.access_token
            )
            # Count acceptable schemes
            page_acceptable_schemes = []
            page_acceptable_schemes.append("OAuth2UserToken")
            page_acceptable_schemes.append("UserToken")
            # If only one scheme is acceptable, use it if available
            if len(page_acceptable_schemes) == 1:
                scheme = page_acceptable_schemes[0]
                if scheme == "BearerToken" and page_available_bearer:
                    page_selected_auth = "bearer_token"
                elif scheme == "OAuth2UserToken" and page_available_oauth2:
                    page_selected_auth = "oauth2_user_context"
                elif scheme == "UserToken" and page_available_oauth1:
                    page_selected_auth = "oauth1"
            # Multiple schemes acceptable - use priority based on operation type
            elif len(page_acceptable_schemes) > 1:
                is_write_operation = "get" in ["POST", "PUT", "DELETE", "PATCH"]
                if is_write_operation:
                    # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                    if "UserToken" in page_acceptable_schemes and page_available_oauth1:
                        page_selected_auth = "oauth1"
                    elif (
                        "OAuth2UserToken" in page_acceptable_schemes
                        and page_available_oauth2
                    ):
                        page_selected_auth = "oauth2_user_context"
                    elif (
                        "BearerToken" in page_acceptable_schemes
                        and page_available_bearer
                    ):
                        page_selected_auth = "bearer_token"
                else:
                    # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                    if (
                        "BearerToken" in page_acceptable_schemes
                        and page_available_bearer
                    ):
                        page_selected_auth = "bearer_token"
                    elif (
                        "OAuth2UserToken" in page_acceptable_schemes
                        and page_available_oauth2
                    ):
                        page_selected_auth = "oauth2_user_context"
                    elif (
                        "UserToken" in page_acceptable_schemes and page_available_oauth1
                    ):
                        page_selected_auth = "oauth1"
            # Apply selected authentication for this page
            page_headers = headers.copy()
            if page_selected_auth == "oauth1":
                # OAuth1 authentication - build proper OAuth1 header dynamically
                # Build OAuth1 header with method, URL, and body
                # For OAuth1, we need to include query params in the URL for signature
                full_url = url
                if page_params:
                    query_string = urllib.parse.urlencode(page_params)
                    full_url = f"{url}?{query_string}" if query_string else url
                # Prepare body for OAuth1 signature (form-encoded, not JSON)
                body_string = ""
                # Build OAuth1 authorization header
                oauth_header = self.client.auth.build_request_header(
                    method="get", url=full_url, body=body_string
                )
                page_headers["Authorization"] = oauth_header
            elif page_selected_auth == "bearer_token":
                # Bearer token authentication
                if self.client.bearer_token:
                    page_headers["Authorization"] = f"Bearer {self.client.bearer_token}"
                elif self.client.access_token:
                    page_headers["Authorization"] = f"Bearer {self.client.access_token}"
            elif page_selected_auth == "oauth2_user_context":
                # OAuth2 User Token authentication
                if self.client.access_token:
                    page_headers["Authorization"] = f"Bearer {self.client.access_token}"
                    # Check if token needs refresh
                    if self.client.oauth2_auth and self.client.token:
                        if self.client.is_token_expired():
                            self.client.refresh_token()
                            if self.client.access_token:
                                page_headers["Authorization"] = (
                                    f"Bearer {self.client.access_token}"
                                )
            # Make the request
            if not page_selected_auth:
                # No suitable auth method found - validate authentication
                required_schemes = (
                    page_acceptable_schemes
                    if "page_acceptable_schemes" in locals()
                    else []
                )
                if required_schemes:
                    available = []
                    if page_available_bearer and "BearerToken" in required_schemes:
                        available.append("BearerToken")
                    if page_available_oauth2 and "OAuth2UserToken" in required_schemes:
                        available.append("OAuth2UserToken")
                    if page_available_oauth1 and "UserToken" in required_schemes:
                        available.append("UserToken")
                    if not available:
                        raise ValueError(
                            f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and page_available_bearer) or (s == 'OAuth2UserToken' and page_available_oauth2) or (s == 'UserToken' and page_available_oauth1)]}"
                        )
            response = self.client.session.get(
                url,
                params=page_params,
                headers=page_headers,
            )
            # Check for errors
            response.raise_for_status()
            # Parse the response data
            response_data = response.json()
            # Convert to Pydantic model if applicable
            page_response = GetBlockingResponse.model_validate(response_data)
            # Yield this page
            yield page_response
            # Extract next_token from response
            next_token = None
            try:
                # Try response.meta.next_token (most common pattern)
                if hasattr(page_response, "meta") and page_response.meta is not None:
                    meta = page_response.meta
                    # If meta is a Pydantic model, try to dump it
                    if hasattr(meta, "model_dump"):
                        try:
                            meta_dict = meta.model_dump()
                            next_token = meta_dict.get("next_token")
                        except (AttributeError, TypeError):
                            pass
                    # Otherwise try attribute access
                    if not next_token and hasattr(meta, "next_token"):
                        next_token = getattr(meta, "next_token", None)
                    # If meta is a dict, access it directly
                    if not next_token and isinstance(meta, dict):
                        next_token = meta.get("next_token")
            except (AttributeError, TypeError):
                pass
            # Try dict access if we have a dict
            if not next_token and isinstance(response_data, dict):
                try:
                    meta = response_data.get("meta")
                    if meta and isinstance(meta, dict):
                        next_token = meta.get("next_token")
                except (AttributeError, TypeError, KeyError):
                    pass
            # If no next_token, we're done
            if not next_token:
                break
            # Update token for next iteration
            current_pagination_token = next_token

            # Optional: Add rate limit backoff here if needed
            # time.sleep(0.1)  # Small delay to avoid rate limits


    def unpin_list(self, id: Any, list_id: Any) -> UnpinListResponse:
        """
        Unpin List
        Causes the authenticated user to unpin a specific List by its ID.
        Args:
            id: The ID of the authenticated source User for whom to return results.
            list_id: The ID of the List to unpin.
            Returns:
            UnpinListResponse: Response data
        """
        url = self.client.base_url + "/2/users/{id}/pinned_lists/{list_id}"
        url = url.replace("{id}", str(id))
        url = url.replace("{list_id}", str(list_id))
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        # UserToken: OAuth1.0a authentication - header will be built dynamically in request
        # OAuth1 header must be built per-request with method, URL, and body
        # This is handled in the request logic below
        params = {}
        headers = {}
        # Prepare request data
        json_data = None
        # Select authentication method based on endpoint requirements and available credentials
        # Priority strategy (matches TypeScript):
        # 1. If endpoint only accepts one method, use that (if available)
        # 2. If endpoint accepts multiple methods:
        #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
        #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
        # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
        selected_auth = None
        # Check what auth methods we have available
        available_bearer = bool(self.client.bearer_token)
        available_oauth2 = bool(self.client.access_token)
        available_oauth1 = bool(self.client.auth and self.client.auth.access_token)
        # Count acceptable schemes
        acceptable_schemes = []
        acceptable_schemes.append("OAuth2UserToken")
        acceptable_schemes.append("UserToken")
        # If only one scheme is acceptable, use it if available
        if len(acceptable_schemes) == 1:
            scheme = acceptable_schemes[0]
            if scheme == "BearerToken" and available_bearer:
                selected_auth = "bearer_token"
            elif scheme == "OAuth2UserToken" and available_oauth2:
                selected_auth = "oauth2_user_context"
            elif scheme == "UserToken" and available_oauth1:
                selected_auth = "oauth1"
        # Multiple schemes acceptable - use priority based on operation type
        elif len(acceptable_schemes) > 1:
            is_write_operation = "delete" in ["POST", "PUT", "DELETE", "PATCH"]
            if is_write_operation:
                # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                if "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
            else:
                # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                if "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
        # Apply selected authentication
        if selected_auth == "oauth1":
            # OAuth1 authentication - build proper OAuth1 header dynamically
            # Build OAuth1 header with method, URL, and body
            # For OAuth1, we need to include query params in the URL for signature
            full_url = url
            if params:
                query_string = urllib.parse.urlencode(params)
                full_url = f"{url}?{query_string}" if query_string else url
            # Prepare body for OAuth1 signature (form-encoded, not JSON)
            body_string = ""
            # Build OAuth1 authorization header
            oauth_header = self.client.auth.build_request_header(
                method="delete", url=full_url, body=body_string
            )
            headers["Authorization"] = oauth_header
        elif selected_auth == "bearer_token":
            # Bearer token authentication
            if self.client.bearer_token:
                headers["Authorization"] = f"Bearer {self.client.bearer_token}"
            elif self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
        elif selected_auth == "oauth2_user_context":
            # OAuth2 User Token authentication
            if self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
                # Check if token needs refresh
                if self.client.oauth2_auth and self.client.token:
                    if self.client.is_token_expired():
                        self.client.refresh_token()
                        if self.client.access_token:
                            headers["Authorization"] = (
                                f"Bearer {self.client.access_token}"
                            )
        # Make the request
        if not selected_auth:
            # No suitable auth method found - validate authentication
            required_schemes = (
                acceptable_schemes if "acceptable_schemes" in locals() else []
            )
            if required_schemes:
                available = []
                if available_bearer and "BearerToken" in required_schemes:
                    available.append("BearerToken")
                if available_oauth2 and "OAuth2UserToken" in required_schemes:
                    available.append("OAuth2UserToken")
                if available_oauth1 and "UserToken" in required_schemes:
                    available.append("UserToken")
                if not available:
                    raise ValueError(
                        f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and available_bearer) or (s == 'OAuth2UserToken' and available_oauth2) or (s == 'UserToken' and available_oauth1)]}"
                    )
        response = self.client.session.delete(
            url,
            params=params,
            headers=headers,
        )
        # Check for errors
        response.raise_for_status()
        # Parse the response data
        response_data = response.json()
        # Convert to Pydantic model if applicable
        return UnpinListResponse.model_validate(response_data)


    def unrepost_post(self, id: Any, source_tweet_id: Any) -> UnrepostPostResponse:
        """
        Unrepost Post
        Causes the authenticated user to unrepost a specific Post by its ID.
        Args:
            id: The ID of the authenticated source User that is requesting to repost the Post.
            source_tweet_id: The ID of the Post that the User is requesting to unretweet.
            Returns:
            UnrepostPostResponse: Response data
        """
        url = self.client.base_url + "/2/users/{id}/retweets/{source_tweet_id}"
        url = url.replace("{id}", str(id))
        url = url.replace("{source_tweet_id}", str(source_tweet_id))
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        # UserToken: OAuth1.0a authentication - header will be built dynamically in request
        # OAuth1 header must be built per-request with method, URL, and body
        # This is handled in the request logic below
        params = {}
        headers = {}
        # Prepare request data
        json_data = None
        # Select authentication method based on endpoint requirements and available credentials
        # Priority strategy (matches TypeScript):
        # 1. If endpoint only accepts one method, use that (if available)
        # 2. If endpoint accepts multiple methods:
        #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
        #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
        # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
        selected_auth = None
        # Check what auth methods we have available
        available_bearer = bool(self.client.bearer_token)
        available_oauth2 = bool(self.client.access_token)
        available_oauth1 = bool(self.client.auth and self.client.auth.access_token)
        # Count acceptable schemes
        acceptable_schemes = []
        acceptable_schemes.append("OAuth2UserToken")
        acceptable_schemes.append("UserToken")
        # If only one scheme is acceptable, use it if available
        if len(acceptable_schemes) == 1:
            scheme = acceptable_schemes[0]
            if scheme == "BearerToken" and available_bearer:
                selected_auth = "bearer_token"
            elif scheme == "OAuth2UserToken" and available_oauth2:
                selected_auth = "oauth2_user_context"
            elif scheme == "UserToken" and available_oauth1:
                selected_auth = "oauth1"
        # Multiple schemes acceptable - use priority based on operation type
        elif len(acceptable_schemes) > 1:
            is_write_operation = "delete" in ["POST", "PUT", "DELETE", "PATCH"]
            if is_write_operation:
                # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                if "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
            else:
                # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                if "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
        # Apply selected authentication
        if selected_auth == "oauth1":
            # OAuth1 authentication - build proper OAuth1 header dynamically
            # Build OAuth1 header with method, URL, and body
            # For OAuth1, we need to include query params in the URL for signature
            full_url = url
            if params:
                query_string = urllib.parse.urlencode(params)
                full_url = f"{url}?{query_string}" if query_string else url
            # Prepare body for OAuth1 signature (form-encoded, not JSON)
            body_string = ""
            # Build OAuth1 authorization header
            oauth_header = self.client.auth.build_request_header(
                method="delete", url=full_url, body=body_string
            )
            headers["Authorization"] = oauth_header
        elif selected_auth == "bearer_token":
            # Bearer token authentication
            if self.client.bearer_token:
                headers["Authorization"] = f"Bearer {self.client.bearer_token}"
            elif self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
        elif selected_auth == "oauth2_user_context":
            # OAuth2 User Token authentication
            if self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
                # Check if token needs refresh
                if self.client.oauth2_auth and self.client.token:
                    if self.client.is_token_expired():
                        self.client.refresh_token()
                        if self.client.access_token:
                            headers["Authorization"] = (
                                f"Bearer {self.client.access_token}"
                            )
        # Make the request
        if not selected_auth:
            # No suitable auth method found - validate authentication
            required_schemes = (
                acceptable_schemes if "acceptable_schemes" in locals() else []
            )
            if required_schemes:
                available = []
                if available_bearer and "BearerToken" in required_schemes:
                    available.append("BearerToken")
                if available_oauth2 and "OAuth2UserToken" in required_schemes:
                    available.append("OAuth2UserToken")
                if available_oauth1 and "UserToken" in required_schemes:
                    available.append("UserToken")
                if not available:
                    raise ValueError(
                        f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and available_bearer) or (s == 'OAuth2UserToken' and available_oauth2) or (s == 'UserToken' and available_oauth1)]}"
                    )
        response = self.client.session.delete(
            url,
            params=params,
            headers=headers,
        )
        # Check for errors
        response.raise_for_status()
        # Parse the response data
        response_data = response.json()
        # Convert to Pydantic model if applicable
        return UnrepostPostResponse.model_validate(response_data)


    def get_muting(
        self,
        id: Any,
        max_results: int = None,
        pagination_token: Any = None,
        user_fields: List = None,
        expansions: List = None,
        tweet_fields: List = None,
    ) -> Iterator[GetMutingResponse]:
        """
        Get muting
        Retrieves a list of Users muted by the authenticated user.
        Args:
            id: The ID of the authenticated source User for whom to return results.
            max_results: The maximum number of results.
            pagination_token: This parameter is used to get the next 'page' of results.
            user_fields: A comma separated list of User fields to display.
            expansions: A comma separated list of fields to expand.
            tweet_fields: A comma separated list of Tweet fields to display.
            Yields:
            GetMutingResponse: One page of results at a time. Automatically handles pagination using next_token.
        Note:
            This method automatically paginates through all results. To get just the first page,
            you can call it once and break, or use the pagination_token parameter to start at a specific page.
        """
        url = self.client.base_url + "/2/users/{id}/muting"
        url = url.replace("{id}", str(id))
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        # UserToken: OAuth1.0a authentication - header will be built dynamically in request
        # OAuth1 header must be built per-request with method, URL, and body
        # This is handled in the request logic below
        headers = {}
        # Prepare request data
        json_data = None
        # Determine pagination parameter name
        pagination_param_name = "pagination_token"
        # Start with provided pagination_token, or None for first page
        # Check if pagination_token parameter exists in the method signature
        current_pagination_token = pagination_token
        while True:
            # Build query parameters for this page
            page_params = {}
            if max_results is not None:
                page_params["max_results"] = max_results
            if user_fields is not None:
                page_params["user.fields"] = ",".join(str(item) for item in user_fields)
            if expansions is not None:
                page_params["expansions"] = ",".join(str(item) for item in expansions)
            if tweet_fields is not None:
                page_params["tweet.fields"] = ",".join(
                    str(item) for item in tweet_fields
                )
            # Add pagination token for this page
            if current_pagination_token:
                page_params[pagination_param_name] = current_pagination_token
            # Select authentication method (same logic as regular_request)
            # Priority strategy (matches TypeScript):
            # 1. If endpoint only accepts one method, use that (if available)
            # 2. If endpoint accepts multiple methods:
            #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
            #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
            # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
            page_selected_auth = None
            # Check what auth methods we have available
            page_available_bearer = bool(self.client.bearer_token)
            page_available_oauth2 = bool(self.client.access_token)
            page_available_oauth1 = bool(
                self.client.auth and self.client.auth.access_token
            )
            # Count acceptable schemes
            page_acceptable_schemes = []
            page_acceptable_schemes.append("OAuth2UserToken")
            page_acceptable_schemes.append("UserToken")
            # If only one scheme is acceptable, use it if available
            if len(page_acceptable_schemes) == 1:
                scheme = page_acceptable_schemes[0]
                if scheme == "BearerToken" and page_available_bearer:
                    page_selected_auth = "bearer_token"
                elif scheme == "OAuth2UserToken" and page_available_oauth2:
                    page_selected_auth = "oauth2_user_context"
                elif scheme == "UserToken" and page_available_oauth1:
                    page_selected_auth = "oauth1"
            # Multiple schemes acceptable - use priority based on operation type
            elif len(page_acceptable_schemes) > 1:
                is_write_operation = "get" in ["POST", "PUT", "DELETE", "PATCH"]
                if is_write_operation:
                    # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                    if "UserToken" in page_acceptable_schemes and page_available_oauth1:
                        page_selected_auth = "oauth1"
                    elif (
                        "OAuth2UserToken" in page_acceptable_schemes
                        and page_available_oauth2
                    ):
                        page_selected_auth = "oauth2_user_context"
                    elif (
                        "BearerToken" in page_acceptable_schemes
                        and page_available_bearer
                    ):
                        page_selected_auth = "bearer_token"
                else:
                    # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                    if (
                        "BearerToken" in page_acceptable_schemes
                        and page_available_bearer
                    ):
                        page_selected_auth = "bearer_token"
                    elif (
                        "OAuth2UserToken" in page_acceptable_schemes
                        and page_available_oauth2
                    ):
                        page_selected_auth = "oauth2_user_context"
                    elif (
                        "UserToken" in page_acceptable_schemes and page_available_oauth1
                    ):
                        page_selected_auth = "oauth1"
            # Apply selected authentication for this page
            page_headers = headers.copy()
            if page_selected_auth == "oauth1":
                # OAuth1 authentication - build proper OAuth1 header dynamically
                # Build OAuth1 header with method, URL, and body
                # For OAuth1, we need to include query params in the URL for signature
                full_url = url
                if page_params:
                    query_string = urllib.parse.urlencode(page_params)
                    full_url = f"{url}?{query_string}" if query_string else url
                # Prepare body for OAuth1 signature (form-encoded, not JSON)
                body_string = ""
                # Build OAuth1 authorization header
                oauth_header = self.client.auth.build_request_header(
                    method="get", url=full_url, body=body_string
                )
                page_headers["Authorization"] = oauth_header
            elif page_selected_auth == "bearer_token":
                # Bearer token authentication
                if self.client.bearer_token:
                    page_headers["Authorization"] = f"Bearer {self.client.bearer_token}"
                elif self.client.access_token:
                    page_headers["Authorization"] = f"Bearer {self.client.access_token}"
            elif page_selected_auth == "oauth2_user_context":
                # OAuth2 User Token authentication
                if self.client.access_token:
                    page_headers["Authorization"] = f"Bearer {self.client.access_token}"
                    # Check if token needs refresh
                    if self.client.oauth2_auth and self.client.token:
                        if self.client.is_token_expired():
                            self.client.refresh_token()
                            if self.client.access_token:
                                page_headers["Authorization"] = (
                                    f"Bearer {self.client.access_token}"
                                )
            # Make the request
            if not page_selected_auth:
                # No suitable auth method found - validate authentication
                required_schemes = (
                    page_acceptable_schemes
                    if "page_acceptable_schemes" in locals()
                    else []
                )
                if required_schemes:
                    available = []
                    if page_available_bearer and "BearerToken" in required_schemes:
                        available.append("BearerToken")
                    if page_available_oauth2 and "OAuth2UserToken" in required_schemes:
                        available.append("OAuth2UserToken")
                    if page_available_oauth1 and "UserToken" in required_schemes:
                        available.append("UserToken")
                    if not available:
                        raise ValueError(
                            f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and page_available_bearer) or (s == 'OAuth2UserToken' and page_available_oauth2) or (s == 'UserToken' and page_available_oauth1)]}"
                        )
            response = self.client.session.get(
                url,
                params=page_params,
                headers=page_headers,
            )
            # Check for errors
            response.raise_for_status()
            # Parse the response data
            response_data = response.json()
            # Convert to Pydantic model if applicable
            page_response = GetMutingResponse.model_validate(response_data)
            # Yield this page
            yield page_response
            # Extract next_token from response
            next_token = None
            try:
                # Try response.meta.next_token (most common pattern)
                if hasattr(page_response, "meta") and page_response.meta is not None:
                    meta = page_response.meta
                    # If meta is a Pydantic model, try to dump it
                    if hasattr(meta, "model_dump"):
                        try:
                            meta_dict = meta.model_dump()
                            next_token = meta_dict.get("next_token")
                        except (AttributeError, TypeError):
                            pass
                    # Otherwise try attribute access
                    if not next_token and hasattr(meta, "next_token"):
                        next_token = getattr(meta, "next_token", None)
                    # If meta is a dict, access it directly
                    if not next_token and isinstance(meta, dict):
                        next_token = meta.get("next_token")
            except (AttributeError, TypeError):
                pass
            # Try dict access if we have a dict
            if not next_token and isinstance(response_data, dict):
                try:
                    meta = response_data.get("meta")
                    if meta and isinstance(meta, dict):
                        next_token = meta.get("next_token")
                except (AttributeError, TypeError, KeyError):
                    pass
            # If no next_token, we're done
            if not next_token:
                break
            # Update token for next iteration
            current_pagination_token = next_token

            # Optional: Add rate limit backoff here if needed
            # time.sleep(0.1)  # Small delay to avoid rate limits


    def mute_user(
        self, id: Any, body: Optional[MuteUserRequest] = None
    ) -> MuteUserResponse:
        """
        Mute User
        Causes the authenticated user to mute a specific User by their ID.
        Args:
            id: The ID of the authenticated source User that is requesting to mute the target User.
            body: Request body
        Returns:
            MuteUserResponse: Response data
        """
        url = self.client.base_url + "/2/users/{id}/muting"
        url = url.replace("{id}", str(id))
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        # UserToken: OAuth1.0a authentication - header will be built dynamically in request
        # OAuth1 header must be built per-request with method, URL, and body
        # This is handled in the request logic below
        params = {}
        headers = {}
        headers["Content-Type"] = "application/json"
        # Prepare request data
        json_data = None
        if body is not None:
            json_data = (
                body.model_dump(exclude_none=True)
                if hasattr(body, "model_dump")
                else body
            )
        # Select authentication method based on endpoint requirements and available credentials
        # Priority strategy (matches TypeScript):
        # 1. If endpoint only accepts one method, use that (if available)
        # 2. If endpoint accepts multiple methods:
        #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
        #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
        # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
        selected_auth = None
        # Check what auth methods we have available
        available_bearer = bool(self.client.bearer_token)
        available_oauth2 = bool(self.client.access_token)
        available_oauth1 = bool(self.client.auth and self.client.auth.access_token)
        # Count acceptable schemes
        acceptable_schemes = []
        acceptable_schemes.append("OAuth2UserToken")
        acceptable_schemes.append("UserToken")
        # If only one scheme is acceptable, use it if available
        if len(acceptable_schemes) == 1:
            scheme = acceptable_schemes[0]
            if scheme == "BearerToken" and available_bearer:
                selected_auth = "bearer_token"
            elif scheme == "OAuth2UserToken" and available_oauth2:
                selected_auth = "oauth2_user_context"
            elif scheme == "UserToken" and available_oauth1:
                selected_auth = "oauth1"
        # Multiple schemes acceptable - use priority based on operation type
        elif len(acceptable_schemes) > 1:
            is_write_operation = "post" in ["POST", "PUT", "DELETE", "PATCH"]
            if is_write_operation:
                # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                if "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
            else:
                # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                if "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
        # Apply selected authentication
        if selected_auth == "oauth1":
            # OAuth1 authentication - build proper OAuth1 header dynamically
            # Build OAuth1 header with method, URL, and body
            # For OAuth1, we need to include query params in the URL for signature
            full_url = url
            if params:
                query_string = urllib.parse.urlencode(params)
                full_url = f"{url}?{query_string}" if query_string else url
            # Prepare body for OAuth1 signature (form-encoded, not JSON)
            body_string = ""
            if json_data:
                # OAuth1 spec: JSON bodies are NOT included in signature
                # But we still need to pass the body for the request
                body_string = ""
            # Build OAuth1 authorization header
            oauth_header = self.client.auth.build_request_header(
                method="post", url=full_url, body=body_string
            )
            headers["Authorization"] = oauth_header
        elif selected_auth == "bearer_token":
            # Bearer token authentication
            if self.client.bearer_token:
                headers["Authorization"] = f"Bearer {self.client.bearer_token}"
            elif self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
        elif selected_auth == "oauth2_user_context":
            # OAuth2 User Token authentication
            if self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
                # Check if token needs refresh
                if self.client.oauth2_auth and self.client.token:
                    if self.client.is_token_expired():
                        self.client.refresh_token()
                        if self.client.access_token:
                            headers["Authorization"] = (
                                f"Bearer {self.client.access_token}"
                            )
        # Make the request
        if not selected_auth:
            # No suitable auth method found - validate authentication
            required_schemes = (
                acceptable_schemes if "acceptable_schemes" in locals() else []
            )
            if required_schemes:
                available = []
                if available_bearer and "BearerToken" in required_schemes:
                    available.append("BearerToken")
                if available_oauth2 and "OAuth2UserToken" in required_schemes:
                    available.append("OAuth2UserToken")
                if available_oauth1 and "UserToken" in required_schemes:
                    available.append("UserToken")
                if not available:
                    raise ValueError(
                        f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and available_bearer) or (s == 'OAuth2UserToken' and available_oauth2) or (s == 'UserToken' and available_oauth1)]}"
                    )
        response = self.client.session.post(
            url,
            params=params,
            headers=headers,
            json=json_data,
        )
        # Check for errors
        response.raise_for_status()
        # Parse the response data
        response_data = response.json()
        # Convert to Pydantic model if applicable
        return MuteUserResponse.model_validate(response_data)


    def get_by_username(
        self,
        username: str,
        user_fields: List = None,
        expansions: List = None,
        tweet_fields: List = None,
    ) -> GetByUsernameResponse:
        """
        Get User by username
        Retrieves details of a specific User by their username.
        Args:
            username: A username.
            user_fields: A comma separated list of User fields to display.
            expansions: A comma separated list of fields to expand.
            tweet_fields: A comma separated list of Tweet fields to display.
            Returns:
            GetByUsernameResponse: Response data
        """
        url = self.client.base_url + "/2/users/by/username/{username}"
        url = url.replace("{username}", str(username))
        # Priority: bearer_token > access_token (matches TypeScript behavior)
        if self.client.bearer_token:
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.bearer_token}"
            )
        elif self.client.access_token:
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        # UserToken: OAuth1.0a authentication - header will be built dynamically in request
        # OAuth1 header must be built per-request with method, URL, and body
        # This is handled in the request logic below
        params = {}
        if user_fields is not None:
            params["user.fields"] = ",".join(str(item) for item in user_fields)
        if expansions is not None:
            params["expansions"] = ",".join(str(item) for item in expansions)
        if tweet_fields is not None:
            params["tweet.fields"] = ",".join(str(item) for item in tweet_fields)
        headers = {}
        # Prepare request data
        json_data = None
        # Select authentication method based on endpoint requirements and available credentials
        # Priority strategy (matches TypeScript):
        # 1. If endpoint only accepts one method, use that (if available)
        # 2. If endpoint accepts multiple methods:
        #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
        #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
        # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
        selected_auth = None
        # Check what auth methods we have available
        available_bearer = bool(self.client.bearer_token)
        available_oauth2 = bool(self.client.access_token)
        available_oauth1 = bool(self.client.auth and self.client.auth.access_token)
        # Count acceptable schemes
        acceptable_schemes = []
        acceptable_schemes.append("BearerToken")
        acceptable_schemes.append("OAuth2UserToken")
        acceptable_schemes.append("UserToken")
        # If only one scheme is acceptable, use it if available
        if len(acceptable_schemes) == 1:
            scheme = acceptable_schemes[0]
            if scheme == "BearerToken" and available_bearer:
                selected_auth = "bearer_token"
            elif scheme == "OAuth2UserToken" and available_oauth2:
                selected_auth = "oauth2_user_context"
            elif scheme == "UserToken" and available_oauth1:
                selected_auth = "oauth1"
        # Multiple schemes acceptable - use priority based on operation type
        elif len(acceptable_schemes) > 1:
            is_write_operation = "get" in ["POST", "PUT", "DELETE", "PATCH"]
            if is_write_operation:
                # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                if "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
            else:
                # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                if "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
        # Apply selected authentication
        if selected_auth == "oauth1":
            # OAuth1 authentication - build proper OAuth1 header dynamically
            # Build OAuth1 header with method, URL, and body
            # For OAuth1, we need to include query params in the URL for signature
            full_url = url
            if params:
                query_string = urllib.parse.urlencode(params)
                full_url = f"{url}?{query_string}" if query_string else url
            # Prepare body for OAuth1 signature (form-encoded, not JSON)
            body_string = ""
            # Build OAuth1 authorization header
            oauth_header = self.client.auth.build_request_header(
                method="get", url=full_url, body=body_string
            )
            headers["Authorization"] = oauth_header
        elif selected_auth == "bearer_token":
            # Bearer token authentication
            if self.client.bearer_token:
                headers["Authorization"] = f"Bearer {self.client.bearer_token}"
            elif self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
        elif selected_auth == "oauth2_user_context":
            # OAuth2 User Token authentication
            if self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
                # Check if token needs refresh
                if self.client.oauth2_auth and self.client.token:
                    if self.client.is_token_expired():
                        self.client.refresh_token()
                        if self.client.access_token:
                            headers["Authorization"] = (
                                f"Bearer {self.client.access_token}"
                            )
        # Make the request
        if not selected_auth:
            # No suitable auth method found - validate authentication
            required_schemes = (
                acceptable_schemes if "acceptable_schemes" in locals() else []
            )
            if required_schemes:
                available = []
                if available_bearer and "BearerToken" in required_schemes:
                    available.append("BearerToken")
                if available_oauth2 and "OAuth2UserToken" in required_schemes:
                    available.append("OAuth2UserToken")
                if available_oauth1 and "UserToken" in required_schemes:
                    available.append("UserToken")
                if not available:
                    raise ValueError(
                        f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and available_bearer) or (s == 'OAuth2UserToken' and available_oauth2) or (s == 'UserToken' and available_oauth1)]}"
                    )
        response = self.client.session.get(
            url,
            params=params,
            headers=headers,
        )
        # Check for errors
        response.raise_for_status()
        # Parse the response data
        response_data = response.json()
        # Convert to Pydantic model if applicable
        return GetByUsernameResponse.model_validate(response_data)


    def get_timeline(
        self,
        id: Any,
        since_id: Any = None,
        until_id: Any = None,
        max_results: int = None,
        pagination_token: Any = None,
        exclude: List = None,
        start_time: str = None,
        end_time: str = None,
        tweet_fields: List = None,
        expansions: List = None,
        media_fields: List = None,
        poll_fields: List = None,
        user_fields: List = None,
        place_fields: List = None,
    ) -> Iterator[GetTimelineResponse]:
        """
        Get Timeline
        Retrieves a reverse chronological list of Posts in the authenticated Users Timeline.
        Args:
            id: The ID of the authenticated source User to list Reverse Chronological Timeline Posts of.
            since_id: The minimum Post ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
            until_id: The maximum Post ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
            max_results: The maximum number of results.
            pagination_token: This parameter is used to get the next 'page' of results.
            exclude: The set of entities to exclude (e.g. 'replies' or 'retweets').
            start_time: YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Posts will be provided. The since_id parameter takes precedence if it is also specified.
            end_time: YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Posts will be provided. The until_id parameter takes precedence if it is also specified.
            tweet_fields: A comma separated list of Tweet fields to display.
            expansions: A comma separated list of fields to expand.
            media_fields: A comma separated list of Media fields to display.
            poll_fields: A comma separated list of Poll fields to display.
            user_fields: A comma separated list of User fields to display.
            place_fields: A comma separated list of Place fields to display.
            Yields:
            GetTimelineResponse: One page of results at a time. Automatically handles pagination using next_token.
        Note:
            This method automatically paginates through all results. To get just the first page,
            you can call it once and break, or use the pagination_token parameter to start at a specific page.
        """
        url = self.client.base_url + "/2/users/{id}/timelines/reverse_chronological"
        url = url.replace("{id}", str(id))
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        # UserToken: OAuth1.0a authentication - header will be built dynamically in request
        # OAuth1 header must be built per-request with method, URL, and body
        # This is handled in the request logic below
        headers = {}
        # Prepare request data
        json_data = None
        # Determine pagination parameter name
        pagination_param_name = "pagination_token"
        # Start with provided pagination_token, or None for first page
        # Check if pagination_token parameter exists in the method signature
        current_pagination_token = pagination_token
        while True:
            # Build query parameters for this page
            page_params = {}
            if since_id is not None:
                page_params["since_id"] = since_id
            if until_id is not None:
                page_params["until_id"] = until_id
            if max_results is not None:
                page_params["max_results"] = max_results
            if exclude is not None:
                page_params["exclude"] = ",".join(str(item) for item in exclude)
            if start_time is not None:
                page_params["start_time"] = start_time
            if end_time is not None:
                page_params["end_time"] = end_time
            if tweet_fields is not None:
                page_params["tweet.fields"] = ",".join(
                    str(item) for item in tweet_fields
                )
            if expansions is not None:
                page_params["expansions"] = ",".join(str(item) for item in expansions)
            if media_fields is not None:
                page_params["media.fields"] = ",".join(
                    str(item) for item in media_fields
                )
            if poll_fields is not None:
                page_params["poll.fields"] = ",".join(str(item) for item in poll_fields)
            if user_fields is not None:
                page_params["user.fields"] = ",".join(str(item) for item in user_fields)
            if place_fields is not None:
                page_params["place.fields"] = ",".join(
                    str(item) for item in place_fields
                )
            # Add pagination token for this page
            if current_pagination_token:
                page_params[pagination_param_name] = current_pagination_token
            # Select authentication method (same logic as regular_request)
            # Priority strategy (matches TypeScript):
            # 1. If endpoint only accepts one method, use that (if available)
            # 2. If endpoint accepts multiple methods:
            #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
            #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
            # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
            page_selected_auth = None
            # Check what auth methods we have available
            page_available_bearer = bool(self.client.bearer_token)
            page_available_oauth2 = bool(self.client.access_token)
            page_available_oauth1 = bool(
                self.client.auth and self.client.auth.access_token
            )
            # Count acceptable schemes
            page_acceptable_schemes = []
            page_acceptable_schemes.append("OAuth2UserToken")
            page_acceptable_schemes.append("UserToken")
            # If only one scheme is acceptable, use it if available
            if len(page_acceptable_schemes) == 1:
                scheme = page_acceptable_schemes[0]
                if scheme == "BearerToken" and page_available_bearer:
                    page_selected_auth = "bearer_token"
                elif scheme == "OAuth2UserToken" and page_available_oauth2:
                    page_selected_auth = "oauth2_user_context"
                elif scheme == "UserToken" and page_available_oauth1:
                    page_selected_auth = "oauth1"
            # Multiple schemes acceptable - use priority based on operation type
            elif len(page_acceptable_schemes) > 1:
                is_write_operation = "get" in ["POST", "PUT", "DELETE", "PATCH"]
                if is_write_operation:
                    # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                    if "UserToken" in page_acceptable_schemes and page_available_oauth1:
                        page_selected_auth = "oauth1"
                    elif (
                        "OAuth2UserToken" in page_acceptable_schemes
                        and page_available_oauth2
                    ):
                        page_selected_auth = "oauth2_user_context"
                    elif (
                        "BearerToken" in page_acceptable_schemes
                        and page_available_bearer
                    ):
                        page_selected_auth = "bearer_token"
                else:
                    # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                    if (
                        "BearerToken" in page_acceptable_schemes
                        and page_available_bearer
                    ):
                        page_selected_auth = "bearer_token"
                    elif (
                        "OAuth2UserToken" in page_acceptable_schemes
                        and page_available_oauth2
                    ):
                        page_selected_auth = "oauth2_user_context"
                    elif (
                        "UserToken" in page_acceptable_schemes and page_available_oauth1
                    ):
                        page_selected_auth = "oauth1"
            # Apply selected authentication for this page
            page_headers = headers.copy()
            if page_selected_auth == "oauth1":
                # OAuth1 authentication - build proper OAuth1 header dynamically
                # Build OAuth1 header with method, URL, and body
                # For OAuth1, we need to include query params in the URL for signature
                full_url = url
                if page_params:
                    query_string = urllib.parse.urlencode(page_params)
                    full_url = f"{url}?{query_string}" if query_string else url
                # Prepare body for OAuth1 signature (form-encoded, not JSON)
                body_string = ""
                # Build OAuth1 authorization header
                oauth_header = self.client.auth.build_request_header(
                    method="get", url=full_url, body=body_string
                )
                page_headers["Authorization"] = oauth_header
            elif page_selected_auth == "bearer_token":
                # Bearer token authentication
                if self.client.bearer_token:
                    page_headers["Authorization"] = f"Bearer {self.client.bearer_token}"
                elif self.client.access_token:
                    page_headers["Authorization"] = f"Bearer {self.client.access_token}"
            elif page_selected_auth == "oauth2_user_context":
                # OAuth2 User Token authentication
                if self.client.access_token:
                    page_headers["Authorization"] = f"Bearer {self.client.access_token}"
                    # Check if token needs refresh
                    if self.client.oauth2_auth and self.client.token:
                        if self.client.is_token_expired():
                            self.client.refresh_token()
                            if self.client.access_token:
                                page_headers["Authorization"] = (
                                    f"Bearer {self.client.access_token}"
                                )
            # Make the request
            if not page_selected_auth:
                # No suitable auth method found - validate authentication
                required_schemes = (
                    page_acceptable_schemes
                    if "page_acceptable_schemes" in locals()
                    else []
                )
                if required_schemes:
                    available = []
                    if page_available_bearer and "BearerToken" in required_schemes:
                        available.append("BearerToken")
                    if page_available_oauth2 and "OAuth2UserToken" in required_schemes:
                        available.append("OAuth2UserToken")
                    if page_available_oauth1 and "UserToken" in required_schemes:
                        available.append("UserToken")
                    if not available:
                        raise ValueError(
                            f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and page_available_bearer) or (s == 'OAuth2UserToken' and page_available_oauth2) or (s == 'UserToken' and page_available_oauth1)]}"
                        )
            response = self.client.session.get(
                url,
                params=page_params,
                headers=page_headers,
            )
            # Check for errors
            response.raise_for_status()
            # Parse the response data
            response_data = response.json()
            # Convert to Pydantic model if applicable
            page_response = GetTimelineResponse.model_validate(response_data)
            # Yield this page
            yield page_response
            # Extract next_token from response
            next_token = None
            try:
                # Try response.meta.next_token (most common pattern)
                if hasattr(page_response, "meta") and page_response.meta is not None:
                    meta = page_response.meta
                    # If meta is a Pydantic model, try to dump it
                    if hasattr(meta, "model_dump"):
                        try:
                            meta_dict = meta.model_dump()
                            next_token = meta_dict.get("next_token")
                        except (AttributeError, TypeError):
                            pass
                    # Otherwise try attribute access
                    if not next_token and hasattr(meta, "next_token"):
                        next_token = getattr(meta, "next_token", None)
                    # If meta is a dict, access it directly
                    if not next_token and isinstance(meta, dict):
                        next_token = meta.get("next_token")
            except (AttributeError, TypeError):
                pass
            # Try dict access if we have a dict
            if not next_token and isinstance(response_data, dict):
                try:
                    meta = response_data.get("meta")
                    if meta and isinstance(meta, dict):
                        next_token = meta.get("next_token")
                except (AttributeError, TypeError, KeyError):
                    pass
            # If no next_token, we're done
            if not next_token:
                break
            # Update token for next iteration
            current_pagination_token = next_token

            # Optional: Add rate limit backoff here if needed
            # time.sleep(0.1)  # Small delay to avoid rate limits


    def get_bookmarks_by_folder_id(
        self, id: Any, folder_id: Any
    ) -> GetBookmarksByFolderIdResponse:
        """
        Get Bookmarks by folder ID
        Retrieves Posts in a specific Bookmark folder by its ID for the authenticated user.
        Args:
            id: The ID of the authenticated source User for whom to return results.
            folder_id: The ID of the Bookmark Folder that the authenticated User is trying to fetch Posts for.
            Returns:
            GetBookmarksByFolderIdResponse: Response data
        """
        url = self.client.base_url + "/2/users/{id}/bookmarks/folders/{folder_id}"
        url = url.replace("{id}", str(id))
        url = url.replace("{folder_id}", str(folder_id))
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        params = {}
        headers = {}
        # Prepare request data
        json_data = None
        # Select authentication method based on endpoint requirements and available credentials
        # Priority strategy (matches TypeScript):
        # 1. If endpoint only accepts one method, use that (if available)
        # 2. If endpoint accepts multiple methods:
        #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
        #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
        # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
        selected_auth = None
        # Check what auth methods we have available
        available_bearer = bool(self.client.bearer_token)
        available_oauth2 = bool(self.client.access_token)
        available_oauth1 = bool(self.client.auth and self.client.auth.access_token)
        # Count acceptable schemes
        acceptable_schemes = []
        acceptable_schemes.append("OAuth2UserToken")
        # If only one scheme is acceptable, use it if available
        if len(acceptable_schemes) == 1:
            scheme = acceptable_schemes[0]
            if scheme == "BearerToken" and available_bearer:
                selected_auth = "bearer_token"
            elif scheme == "OAuth2UserToken" and available_oauth2:
                selected_auth = "oauth2_user_context"
            elif scheme == "UserToken" and available_oauth1:
                selected_auth = "oauth1"
        # Multiple schemes acceptable - use priority based on operation type
        elif len(acceptable_schemes) > 1:
            is_write_operation = "get" in ["POST", "PUT", "DELETE", "PATCH"]
            if is_write_operation:
                # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                if "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
            else:
                # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                if "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
        # Apply selected authentication
        if selected_auth == "oauth1":
            # OAuth1 authentication - build proper OAuth1 header dynamically
            # Build OAuth1 header with method, URL, and body
            # For OAuth1, we need to include query params in the URL for signature
            full_url = url
            if params:
                query_string = urllib.parse.urlencode(params)
                full_url = f"{url}?{query_string}" if query_string else url
            # Prepare body for OAuth1 signature (form-encoded, not JSON)
            body_string = ""
            # Build OAuth1 authorization header
            oauth_header = self.client.auth.build_request_header(
                method="get", url=full_url, body=body_string
            )
            headers["Authorization"] = oauth_header
        elif selected_auth == "bearer_token":
            # Bearer token authentication
            if self.client.bearer_token:
                headers["Authorization"] = f"Bearer {self.client.bearer_token}"
            elif self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
        elif selected_auth == "oauth2_user_context":
            # OAuth2 User Token authentication
            if self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
                # Check if token needs refresh
                if self.client.oauth2_auth and self.client.token:
                    if self.client.is_token_expired():
                        self.client.refresh_token()
                        if self.client.access_token:
                            headers["Authorization"] = (
                                f"Bearer {self.client.access_token}"
                            )
        # Make the request
        if not selected_auth:
            # No suitable auth method found - validate authentication
            required_schemes = (
                acceptable_schemes if "acceptable_schemes" in locals() else []
            )
            if required_schemes:
                available = []
                if available_bearer and "BearerToken" in required_schemes:
                    available.append("BearerToken")
                if available_oauth2 and "OAuth2UserToken" in required_schemes:
                    available.append("OAuth2UserToken")
                if available_oauth1 and "UserToken" in required_schemes:
                    available.append("UserToken")
                if not available:
                    raise ValueError(
                        f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and available_bearer) or (s == 'OAuth2UserToken' and available_oauth2) or (s == 'UserToken' and available_oauth1)]}"
                    )
        response = self.client.session.get(
            url,
            params=params,
            headers=headers,
        )
        # Check for errors
        response.raise_for_status()
        # Parse the response data
        response_data = response.json()
        # Convert to Pydantic model if applicable
        return GetBookmarksByFolderIdResponse.model_validate(response_data)


    def get_followers(
        self,
        id: Any,
        max_results: int = None,
        pagination_token: Any = None,
        user_fields: List = None,
        expansions: List = None,
        tweet_fields: List = None,
    ) -> Iterator[GetFollowersResponse]:
        """
        Get followers
        Retrieves a list of Users who follow a specific User by their ID.
        Args:
            id: The ID of the User to lookup.
            max_results: The maximum number of results.
            pagination_token: This parameter is used to get a specified 'page' of results.
            user_fields: A comma separated list of User fields to display.
            expansions: A comma separated list of fields to expand.
            tweet_fields: A comma separated list of Tweet fields to display.
            Yields:
            GetFollowersResponse: One page of results at a time. Automatically handles pagination using next_token.
        Note:
            This method automatically paginates through all results. To get just the first page,
            you can call it once and break, or use the pagination_token parameter to start at a specific page.
        """
        url = self.client.base_url + "/2/users/{id}/followers"
        url = url.replace("{id}", str(id))
        # Priority: bearer_token > access_token (matches TypeScript behavior)
        if self.client.bearer_token:
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.bearer_token}"
            )
        elif self.client.access_token:
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        # UserToken: OAuth1.0a authentication - header will be built dynamically in request
        # OAuth1 header must be built per-request with method, URL, and body
        # This is handled in the request logic below
        headers = {}
        # Prepare request data
        json_data = None
        # Determine pagination parameter name
        pagination_param_name = "pagination_token"
        # Start with provided pagination_token, or None for first page
        # Check if pagination_token parameter exists in the method signature
        current_pagination_token = pagination_token
        while True:
            # Build query parameters for this page
            page_params = {}
            if max_results is not None:
                page_params["max_results"] = max_results
            if user_fields is not None:
                page_params["user.fields"] = ",".join(str(item) for item in user_fields)
            if expansions is not None:
                page_params["expansions"] = ",".join(str(item) for item in expansions)
            if tweet_fields is not None:
                page_params["tweet.fields"] = ",".join(
                    str(item) for item in tweet_fields
                )
            # Add pagination token for this page
            if current_pagination_token:
                page_params[pagination_param_name] = current_pagination_token
            # Select authentication method (same logic as regular_request)
            # Priority strategy (matches TypeScript):
            # 1. If endpoint only accepts one method, use that (if available)
            # 2. If endpoint accepts multiple methods:
            #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
            #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
            # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
            page_selected_auth = None
            # Check what auth methods we have available
            page_available_bearer = bool(self.client.bearer_token)
            page_available_oauth2 = bool(self.client.access_token)
            page_available_oauth1 = bool(
                self.client.auth and self.client.auth.access_token
            )
            # Count acceptable schemes
            page_acceptable_schemes = []
            page_acceptable_schemes.append("BearerToken")
            page_acceptable_schemes.append("OAuth2UserToken")
            page_acceptable_schemes.append("UserToken")
            # If only one scheme is acceptable, use it if available
            if len(page_acceptable_schemes) == 1:
                scheme = page_acceptable_schemes[0]
                if scheme == "BearerToken" and page_available_bearer:
                    page_selected_auth = "bearer_token"
                elif scheme == "OAuth2UserToken" and page_available_oauth2:
                    page_selected_auth = "oauth2_user_context"
                elif scheme == "UserToken" and page_available_oauth1:
                    page_selected_auth = "oauth1"
            # Multiple schemes acceptable - use priority based on operation type
            elif len(page_acceptable_schemes) > 1:
                is_write_operation = "get" in ["POST", "PUT", "DELETE", "PATCH"]
                if is_write_operation:
                    # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                    if "UserToken" in page_acceptable_schemes and page_available_oauth1:
                        page_selected_auth = "oauth1"
                    elif (
                        "OAuth2UserToken" in page_acceptable_schemes
                        and page_available_oauth2
                    ):
                        page_selected_auth = "oauth2_user_context"
                    elif (
                        "BearerToken" in page_acceptable_schemes
                        and page_available_bearer
                    ):
                        page_selected_auth = "bearer_token"
                else:
                    # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                    if (
                        "BearerToken" in page_acceptable_schemes
                        and page_available_bearer
                    ):
                        page_selected_auth = "bearer_token"
                    elif (
                        "OAuth2UserToken" in page_acceptable_schemes
                        and page_available_oauth2
                    ):
                        page_selected_auth = "oauth2_user_context"
                    elif (
                        "UserToken" in page_acceptable_schemes and page_available_oauth1
                    ):
                        page_selected_auth = "oauth1"
            # Apply selected authentication for this page
            page_headers = headers.copy()
            if page_selected_auth == "oauth1":
                # OAuth1 authentication - build proper OAuth1 header dynamically
                # Build OAuth1 header with method, URL, and body
                # For OAuth1, we need to include query params in the URL for signature
                full_url = url
                if page_params:
                    query_string = urllib.parse.urlencode(page_params)
                    full_url = f"{url}?{query_string}" if query_string else url
                # Prepare body for OAuth1 signature (form-encoded, not JSON)
                body_string = ""
                # Build OAuth1 authorization header
                oauth_header = self.client.auth.build_request_header(
                    method="get", url=full_url, body=body_string
                )
                page_headers["Authorization"] = oauth_header
            elif page_selected_auth == "bearer_token":
                # Bearer token authentication
                if self.client.bearer_token:
                    page_headers["Authorization"] = f"Bearer {self.client.bearer_token}"
                elif self.client.access_token:
                    page_headers["Authorization"] = f"Bearer {self.client.access_token}"
            elif page_selected_auth == "oauth2_user_context":
                # OAuth2 User Token authentication
                if self.client.access_token:
                    page_headers["Authorization"] = f"Bearer {self.client.access_token}"
                    # Check if token needs refresh
                    if self.client.oauth2_auth and self.client.token:
                        if self.client.is_token_expired():
                            self.client.refresh_token()
                            if self.client.access_token:
                                page_headers["Authorization"] = (
                                    f"Bearer {self.client.access_token}"
                                )
            # Make the request
            if not page_selected_auth:
                # No suitable auth method found - validate authentication
                required_schemes = (
                    page_acceptable_schemes
                    if "page_acceptable_schemes" in locals()
                    else []
                )
                if required_schemes:
                    available = []
                    if page_available_bearer and "BearerToken" in required_schemes:
                        available.append("BearerToken")
                    if page_available_oauth2 and "OAuth2UserToken" in required_schemes:
                        available.append("OAuth2UserToken")
                    if page_available_oauth1 and "UserToken" in required_schemes:
                        available.append("UserToken")
                    if not available:
                        raise ValueError(
                            f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and page_available_bearer) or (s == 'OAuth2UserToken' and page_available_oauth2) or (s == 'UserToken' and page_available_oauth1)]}"
                        )
            response = self.client.session.get(
                url,
                params=page_params,
                headers=page_headers,
            )
            # Check for errors
            response.raise_for_status()
            # Parse the response data
            response_data = response.json()
            # Convert to Pydantic model if applicable
            page_response = GetFollowersResponse.model_validate(response_data)
            # Yield this page
            yield page_response
            # Extract next_token from response
            next_token = None
            try:
                # Try response.meta.next_token (most common pattern)
                if hasattr(page_response, "meta") and page_response.meta is not None:
                    meta = page_response.meta
                    # If meta is a Pydantic model, try to dump it
                    if hasattr(meta, "model_dump"):
                        try:
                            meta_dict = meta.model_dump()
                            next_token = meta_dict.get("next_token")
                        except (AttributeError, TypeError):
                            pass
                    # Otherwise try attribute access
                    if not next_token and hasattr(meta, "next_token"):
                        next_token = getattr(meta, "next_token", None)
                    # If meta is a dict, access it directly
                    if not next_token and isinstance(meta, dict):
                        next_token = meta.get("next_token")
            except (AttributeError, TypeError):
                pass
            # Try dict access if we have a dict
            if not next_token and isinstance(response_data, dict):
                try:
                    meta = response_data.get("meta")
                    if meta and isinstance(meta, dict):
                        next_token = meta.get("next_token")
                except (AttributeError, TypeError, KeyError):
                    pass
            # If no next_token, we're done
            if not next_token:
                break
            # Update token for next iteration
            current_pagination_token = next_token

            # Optional: Add rate limit backoff here if needed
            # time.sleep(0.1)  # Small delay to avoid rate limits


    def delete_bookmark(self, id: Any, tweet_id: Any) -> DeleteBookmarkResponse:
        """
        Delete Bookmark
        Removes a Post from the authenticated users Bookmarks by its ID.
        Args:
            id: The ID of the authenticated source User whose bookmark is to be removed.
            tweet_id: The ID of the Post that the source User is removing from bookmarks.
            Returns:
            DeleteBookmarkResponse: Response data
        """
        url = self.client.base_url + "/2/users/{id}/bookmarks/{tweet_id}"
        url = url.replace("{id}", str(id))
        url = url.replace("{tweet_id}", str(tweet_id))
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        params = {}
        headers = {}
        # Prepare request data
        json_data = None
        # Select authentication method based on endpoint requirements and available credentials
        # Priority strategy (matches TypeScript):
        # 1. If endpoint only accepts one method, use that (if available)
        # 2. If endpoint accepts multiple methods:
        #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
        #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
        # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
        selected_auth = None
        # Check what auth methods we have available
        available_bearer = bool(self.client.bearer_token)
        available_oauth2 = bool(self.client.access_token)
        available_oauth1 = bool(self.client.auth and self.client.auth.access_token)
        # Count acceptable schemes
        acceptable_schemes = []
        acceptable_schemes.append("OAuth2UserToken")
        # If only one scheme is acceptable, use it if available
        if len(acceptable_schemes) == 1:
            scheme = acceptable_schemes[0]
            if scheme == "BearerToken" and available_bearer:
                selected_auth = "bearer_token"
            elif scheme == "OAuth2UserToken" and available_oauth2:
                selected_auth = "oauth2_user_context"
            elif scheme == "UserToken" and available_oauth1:
                selected_auth = "oauth1"
        # Multiple schemes acceptable - use priority based on operation type
        elif len(acceptable_schemes) > 1:
            is_write_operation = "delete" in ["POST", "PUT", "DELETE", "PATCH"]
            if is_write_operation:
                # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                if "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
            else:
                # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                if "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
        # Apply selected authentication
        if selected_auth == "oauth1":
            # OAuth1 authentication - build proper OAuth1 header dynamically
            # Build OAuth1 header with method, URL, and body
            # For OAuth1, we need to include query params in the URL for signature
            full_url = url
            if params:
                query_string = urllib.parse.urlencode(params)
                full_url = f"{url}?{query_string}" if query_string else url
            # Prepare body for OAuth1 signature (form-encoded, not JSON)
            body_string = ""
            # Build OAuth1 authorization header
            oauth_header = self.client.auth.build_request_header(
                method="delete", url=full_url, body=body_string
            )
            headers["Authorization"] = oauth_header
        elif selected_auth == "bearer_token":
            # Bearer token authentication
            if self.client.bearer_token:
                headers["Authorization"] = f"Bearer {self.client.bearer_token}"
            elif self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
        elif selected_auth == "oauth2_user_context":
            # OAuth2 User Token authentication
            if self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
                # Check if token needs refresh
                if self.client.oauth2_auth and self.client.token:
                    if self.client.is_token_expired():
                        self.client.refresh_token()
                        if self.client.access_token:
                            headers["Authorization"] = (
                                f"Bearer {self.client.access_token}"
                            )
        # Make the request
        if not selected_auth:
            # No suitable auth method found - validate authentication
            required_schemes = (
                acceptable_schemes if "acceptable_schemes" in locals() else []
            )
            if required_schemes:
                available = []
                if available_bearer and "BearerToken" in required_schemes:
                    available.append("BearerToken")
                if available_oauth2 and "OAuth2UserToken" in required_schemes:
                    available.append("OAuth2UserToken")
                if available_oauth1 and "UserToken" in required_schemes:
                    available.append("UserToken")
                if not available:
                    raise ValueError(
                        f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and available_bearer) or (s == 'OAuth2UserToken' and available_oauth2) or (s == 'UserToken' and available_oauth1)]}"
                    )
        response = self.client.session.delete(
            url,
            params=params,
            headers=headers,
        )
        # Check for errors
        response.raise_for_status()
        # Parse the response data
        response_data = response.json()
        # Convert to Pydantic model if applicable
        return DeleteBookmarkResponse.model_validate(response_data)


    def unlike_post(self, id: Any, tweet_id: Any) -> UnlikePostResponse:
        """
        Unlike Post
        Causes the authenticated user to Unlike a specific Post by its ID.
        Args:
            id: The ID of the authenticated source User that is requesting to unlike the Post.
            tweet_id: The ID of the Post that the User is requesting to unlike.
            Returns:
            UnlikePostResponse: Response data
        """
        url = self.client.base_url + "/2/users/{id}/likes/{tweet_id}"
        url = url.replace("{id}", str(id))
        url = url.replace("{tweet_id}", str(tweet_id))
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        # UserToken: OAuth1.0a authentication - header will be built dynamically in request
        # OAuth1 header must be built per-request with method, URL, and body
        # This is handled in the request logic below
        params = {}
        headers = {}
        # Prepare request data
        json_data = None
        # Select authentication method based on endpoint requirements and available credentials
        # Priority strategy (matches TypeScript):
        # 1. If endpoint only accepts one method, use that (if available)
        # 2. If endpoint accepts multiple methods:
        #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
        #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
        # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
        selected_auth = None
        # Check what auth methods we have available
        available_bearer = bool(self.client.bearer_token)
        available_oauth2 = bool(self.client.access_token)
        available_oauth1 = bool(self.client.auth and self.client.auth.access_token)
        # Count acceptable schemes
        acceptable_schemes = []
        acceptable_schemes.append("OAuth2UserToken")
        acceptable_schemes.append("UserToken")
        # If only one scheme is acceptable, use it if available
        if len(acceptable_schemes) == 1:
            scheme = acceptable_schemes[0]
            if scheme == "BearerToken" and available_bearer:
                selected_auth = "bearer_token"
            elif scheme == "OAuth2UserToken" and available_oauth2:
                selected_auth = "oauth2_user_context"
            elif scheme == "UserToken" and available_oauth1:
                selected_auth = "oauth1"
        # Multiple schemes acceptable - use priority based on operation type
        elif len(acceptable_schemes) > 1:
            is_write_operation = "delete" in ["POST", "PUT", "DELETE", "PATCH"]
            if is_write_operation:
                # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                if "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
            else:
                # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                if "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
        # Apply selected authentication
        if selected_auth == "oauth1":
            # OAuth1 authentication - build proper OAuth1 header dynamically
            # Build OAuth1 header with method, URL, and body
            # For OAuth1, we need to include query params in the URL for signature
            full_url = url
            if params:
                query_string = urllib.parse.urlencode(params)
                full_url = f"{url}?{query_string}" if query_string else url
            # Prepare body for OAuth1 signature (form-encoded, not JSON)
            body_string = ""
            # Build OAuth1 authorization header
            oauth_header = self.client.auth.build_request_header(
                method="delete", url=full_url, body=body_string
            )
            headers["Authorization"] = oauth_header
        elif selected_auth == "bearer_token":
            # Bearer token authentication
            if self.client.bearer_token:
                headers["Authorization"] = f"Bearer {self.client.bearer_token}"
            elif self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
        elif selected_auth == "oauth2_user_context":
            # OAuth2 User Token authentication
            if self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
                # Check if token needs refresh
                if self.client.oauth2_auth and self.client.token:
                    if self.client.is_token_expired():
                        self.client.refresh_token()
                        if self.client.access_token:
                            headers["Authorization"] = (
                                f"Bearer {self.client.access_token}"
                            )
        # Make the request
        if not selected_auth:
            # No suitable auth method found - validate authentication
            required_schemes = (
                acceptable_schemes if "acceptable_schemes" in locals() else []
            )
            if required_schemes:
                available = []
                if available_bearer and "BearerToken" in required_schemes:
                    available.append("BearerToken")
                if available_oauth2 and "OAuth2UserToken" in required_schemes:
                    available.append("OAuth2UserToken")
                if available_oauth1 and "UserToken" in required_schemes:
                    available.append("UserToken")
                if not available:
                    raise ValueError(
                        f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and available_bearer) or (s == 'OAuth2UserToken' and available_oauth2) or (s == 'UserToken' and available_oauth1)]}"
                    )
        response = self.client.session.delete(
            url,
            params=params,
            headers=headers,
        )
        # Check for errors
        response.raise_for_status()
        # Parse the response data
        response_data = response.json()
        # Convert to Pydantic model if applicable
        return UnlikePostResponse.model_validate(response_data)


    def get_owned_lists(
        self,
        id: Any,
        max_results: int = None,
        pagination_token: Any = None,
        list_fields: List = None,
        expansions: List = None,
        user_fields: List = None,
    ) -> Iterator[GetOwnedListsResponse]:
        """
        Get owned Lists
        Retrieves a list of Lists owned by a specific User by their ID.
        Args:
            id: The ID of the User to lookup.
            max_results: The maximum number of results.
            pagination_token: This parameter is used to get a specified 'page' of results.
            list_fields: A comma separated list of List fields to display.
            expansions: A comma separated list of fields to expand.
            user_fields: A comma separated list of User fields to display.
            Yields:
            GetOwnedListsResponse: One page of results at a time. Automatically handles pagination using next_token.
        Note:
            This method automatically paginates through all results. To get just the first page,
            you can call it once and break, or use the pagination_token parameter to start at a specific page.
        """
        url = self.client.base_url + "/2/users/{id}/owned_lists"
        url = url.replace("{id}", str(id))
        # Priority: bearer_token > access_token (matches TypeScript behavior)
        if self.client.bearer_token:
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.bearer_token}"
            )
        elif self.client.access_token:
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        # UserToken: OAuth1.0a authentication - header will be built dynamically in request
        # OAuth1 header must be built per-request with method, URL, and body
        # This is handled in the request logic below
        headers = {}
        # Prepare request data
        json_data = None
        # Determine pagination parameter name
        pagination_param_name = "pagination_token"
        # Start with provided pagination_token, or None for first page
        # Check if pagination_token parameter exists in the method signature
        current_pagination_token = pagination_token
        while True:
            # Build query parameters for this page
            page_params = {}
            if max_results is not None:
                page_params["max_results"] = max_results
            if list_fields is not None:
                page_params["list.fields"] = ",".join(str(item) for item in list_fields)
            if expansions is not None:
                page_params["expansions"] = ",".join(str(item) for item in expansions)
            if user_fields is not None:
                page_params["user.fields"] = ",".join(str(item) for item in user_fields)
            # Add pagination token for this page
            if current_pagination_token:
                page_params[pagination_param_name] = current_pagination_token
            # Select authentication method (same logic as regular_request)
            # Priority strategy (matches TypeScript):
            # 1. If endpoint only accepts one method, use that (if available)
            # 2. If endpoint accepts multiple methods:
            #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
            #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
            # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
            page_selected_auth = None
            # Check what auth methods we have available
            page_available_bearer = bool(self.client.bearer_token)
            page_available_oauth2 = bool(self.client.access_token)
            page_available_oauth1 = bool(
                self.client.auth and self.client.auth.access_token
            )
            # Count acceptable schemes
            page_acceptable_schemes = []
            page_acceptable_schemes.append("BearerToken")
            page_acceptable_schemes.append("OAuth2UserToken")
            page_acceptable_schemes.append("UserToken")
            # If only one scheme is acceptable, use it if available
            if len(page_acceptable_schemes) == 1:
                scheme = page_acceptable_schemes[0]
                if scheme == "BearerToken" and page_available_bearer:
                    page_selected_auth = "bearer_token"
                elif scheme == "OAuth2UserToken" and page_available_oauth2:
                    page_selected_auth = "oauth2_user_context"
                elif scheme == "UserToken" and page_available_oauth1:
                    page_selected_auth = "oauth1"
            # Multiple schemes acceptable - use priority based on operation type
            elif len(page_acceptable_schemes) > 1:
                is_write_operation = "get" in ["POST", "PUT", "DELETE", "PATCH"]
                if is_write_operation:
                    # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                    if "UserToken" in page_acceptable_schemes and page_available_oauth1:
                        page_selected_auth = "oauth1"
                    elif (
                        "OAuth2UserToken" in page_acceptable_schemes
                        and page_available_oauth2
                    ):
                        page_selected_auth = "oauth2_user_context"
                    elif (
                        "BearerToken" in page_acceptable_schemes
                        and page_available_bearer
                    ):
                        page_selected_auth = "bearer_token"
                else:
                    # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                    if (
                        "BearerToken" in page_acceptable_schemes
                        and page_available_bearer
                    ):
                        page_selected_auth = "bearer_token"
                    elif (
                        "OAuth2UserToken" in page_acceptable_schemes
                        and page_available_oauth2
                    ):
                        page_selected_auth = "oauth2_user_context"
                    elif (
                        "UserToken" in page_acceptable_schemes and page_available_oauth1
                    ):
                        page_selected_auth = "oauth1"
            # Apply selected authentication for this page
            page_headers = headers.copy()
            if page_selected_auth == "oauth1":
                # OAuth1 authentication - build proper OAuth1 header dynamically
                # Build OAuth1 header with method, URL, and body
                # For OAuth1, we need to include query params in the URL for signature
                full_url = url
                if page_params:
                    query_string = urllib.parse.urlencode(page_params)
                    full_url = f"{url}?{query_string}" if query_string else url
                # Prepare body for OAuth1 signature (form-encoded, not JSON)
                body_string = ""
                # Build OAuth1 authorization header
                oauth_header = self.client.auth.build_request_header(
                    method="get", url=full_url, body=body_string
                )
                page_headers["Authorization"] = oauth_header
            elif page_selected_auth == "bearer_token":
                # Bearer token authentication
                if self.client.bearer_token:
                    page_headers["Authorization"] = f"Bearer {self.client.bearer_token}"
                elif self.client.access_token:
                    page_headers["Authorization"] = f"Bearer {self.client.access_token}"
            elif page_selected_auth == "oauth2_user_context":
                # OAuth2 User Token authentication
                if self.client.access_token:
                    page_headers["Authorization"] = f"Bearer {self.client.access_token}"
                    # Check if token needs refresh
                    if self.client.oauth2_auth and self.client.token:
                        if self.client.is_token_expired():
                            self.client.refresh_token()
                            if self.client.access_token:
                                page_headers["Authorization"] = (
                                    f"Bearer {self.client.access_token}"
                                )
            # Make the request
            if not page_selected_auth:
                # No suitable auth method found - validate authentication
                required_schemes = (
                    page_acceptable_schemes
                    if "page_acceptable_schemes" in locals()
                    else []
                )
                if required_schemes:
                    available = []
                    if page_available_bearer and "BearerToken" in required_schemes:
                        available.append("BearerToken")
                    if page_available_oauth2 and "OAuth2UserToken" in required_schemes:
                        available.append("OAuth2UserToken")
                    if page_available_oauth1 and "UserToken" in required_schemes:
                        available.append("UserToken")
                    if not available:
                        raise ValueError(
                            f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and page_available_bearer) or (s == 'OAuth2UserToken' and page_available_oauth2) or (s == 'UserToken' and page_available_oauth1)]}"
                        )
            response = self.client.session.get(
                url,
                params=page_params,
                headers=page_headers,
            )
            # Check for errors
            response.raise_for_status()
            # Parse the response data
            response_data = response.json()
            # Convert to Pydantic model if applicable
            page_response = GetOwnedListsResponse.model_validate(response_data)
            # Yield this page
            yield page_response
            # Extract next_token from response
            next_token = None
            try:
                # Try response.meta.next_token (most common pattern)
                if hasattr(page_response, "meta") and page_response.meta is not None:
                    meta = page_response.meta
                    # If meta is a Pydantic model, try to dump it
                    if hasattr(meta, "model_dump"):
                        try:
                            meta_dict = meta.model_dump()
                            next_token = meta_dict.get("next_token")
                        except (AttributeError, TypeError):
                            pass
                    # Otherwise try attribute access
                    if not next_token and hasattr(meta, "next_token"):
                        next_token = getattr(meta, "next_token", None)
                    # If meta is a dict, access it directly
                    if not next_token and isinstance(meta, dict):
                        next_token = meta.get("next_token")
            except (AttributeError, TypeError):
                pass
            # Try dict access if we have a dict
            if not next_token and isinstance(response_data, dict):
                try:
                    meta = response_data.get("meta")
                    if meta and isinstance(meta, dict):
                        next_token = meta.get("next_token")
                except (AttributeError, TypeError, KeyError):
                    pass
            # If no next_token, we're done
            if not next_token:
                break
            # Update token for next iteration
            current_pagination_token = next_token

            # Optional: Add rate limit backoff here if needed
            # time.sleep(0.1)  # Small delay to avoid rate limits


    def search(
        self,
        query: Any,
        max_results: int = None,
        next_token: Any = None,
        user_fields: List = None,
        expansions: List = None,
        tweet_fields: List = None,
    ) -> Iterator[SearchResponse]:
        """
        Search Users
        Retrieves a list of Users matching a search query.
        Args:
            query: TThe the query string by which to query for users.
            max_results: The maximum number of results.
            next_token: This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
            user_fields: A comma separated list of User fields to display.
            expansions: A comma separated list of fields to expand.
            tweet_fields: A comma separated list of Tweet fields to display.
            Yields:
            SearchResponse: One page of results at a time. Automatically handles pagination using next_token.
        Note:
            This method automatically paginates through all results. To get just the first page,
            you can call it once and break, or use the pagination_token parameter to start at a specific page.
        """
        url = self.client.base_url + "/2/users/search"
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        # UserToken: OAuth1.0a authentication - header will be built dynamically in request
        # OAuth1 header must be built per-request with method, URL, and body
        # This is handled in the request logic below
        headers = {}
        # Prepare request data
        json_data = None
        # Determine pagination parameter name
        pagination_param_name = "next_token"
        # Start with provided pagination_token, or None for first page
        # Check if pagination_token parameter exists in the method signature
        current_pagination_token = next_token
        while True:
            # Build query parameters for this page
            page_params = {}
            if query is not None:
                page_params["query"] = query
            if max_results is not None:
                page_params["max_results"] = max_results
            if user_fields is not None:
                page_params["user.fields"] = ",".join(str(item) for item in user_fields)
            if expansions is not None:
                page_params["expansions"] = ",".join(str(item) for item in expansions)
            if tweet_fields is not None:
                page_params["tweet.fields"] = ",".join(
                    str(item) for item in tweet_fields
                )
            # Add pagination token for this page
            if current_pagination_token:
                page_params[pagination_param_name] = current_pagination_token
            # Select authentication method (same logic as regular_request)
            # Priority strategy (matches TypeScript):
            # 1. If endpoint only accepts one method, use that (if available)
            # 2. If endpoint accepts multiple methods:
            #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
            #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
            # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
            page_selected_auth = None
            # Check what auth methods we have available
            page_available_bearer = bool(self.client.bearer_token)
            page_available_oauth2 = bool(self.client.access_token)
            page_available_oauth1 = bool(
                self.client.auth and self.client.auth.access_token
            )
            # Count acceptable schemes
            page_acceptable_schemes = []
            page_acceptable_schemes.append("OAuth2UserToken")
            page_acceptable_schemes.append("UserToken")
            # If only one scheme is acceptable, use it if available
            if len(page_acceptable_schemes) == 1:
                scheme = page_acceptable_schemes[0]
                if scheme == "BearerToken" and page_available_bearer:
                    page_selected_auth = "bearer_token"
                elif scheme == "OAuth2UserToken" and page_available_oauth2:
                    page_selected_auth = "oauth2_user_context"
                elif scheme == "UserToken" and page_available_oauth1:
                    page_selected_auth = "oauth1"
            # Multiple schemes acceptable - use priority based on operation type
            elif len(page_acceptable_schemes) > 1:
                is_write_operation = "get" in ["POST", "PUT", "DELETE", "PATCH"]
                if is_write_operation:
                    # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                    if "UserToken" in page_acceptable_schemes and page_available_oauth1:
                        page_selected_auth = "oauth1"
                    elif (
                        "OAuth2UserToken" in page_acceptable_schemes
                        and page_available_oauth2
                    ):
                        page_selected_auth = "oauth2_user_context"
                    elif (
                        "BearerToken" in page_acceptable_schemes
                        and page_available_bearer
                    ):
                        page_selected_auth = "bearer_token"
                else:
                    # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                    if (
                        "BearerToken" in page_acceptable_schemes
                        and page_available_bearer
                    ):
                        page_selected_auth = "bearer_token"
                    elif (
                        "OAuth2UserToken" in page_acceptable_schemes
                        and page_available_oauth2
                    ):
                        page_selected_auth = "oauth2_user_context"
                    elif (
                        "UserToken" in page_acceptable_schemes and page_available_oauth1
                    ):
                        page_selected_auth = "oauth1"
            # Apply selected authentication for this page
            page_headers = headers.copy()
            if page_selected_auth == "oauth1":
                # OAuth1 authentication - build proper OAuth1 header dynamically
                # Build OAuth1 header with method, URL, and body
                # For OAuth1, we need to include query params in the URL for signature
                full_url = url
                if page_params:
                    query_string = urllib.parse.urlencode(page_params)
                    full_url = f"{url}?{query_string}" if query_string else url
                # Prepare body for OAuth1 signature (form-encoded, not JSON)
                body_string = ""
                # Build OAuth1 authorization header
                oauth_header = self.client.auth.build_request_header(
                    method="get", url=full_url, body=body_string
                )
                page_headers["Authorization"] = oauth_header
            elif page_selected_auth == "bearer_token":
                # Bearer token authentication
                if self.client.bearer_token:
                    page_headers["Authorization"] = f"Bearer {self.client.bearer_token}"
                elif self.client.access_token:
                    page_headers["Authorization"] = f"Bearer {self.client.access_token}"
            elif page_selected_auth == "oauth2_user_context":
                # OAuth2 User Token authentication
                if self.client.access_token:
                    page_headers["Authorization"] = f"Bearer {self.client.access_token}"
                    # Check if token needs refresh
                    if self.client.oauth2_auth and self.client.token:
                        if self.client.is_token_expired():
                            self.client.refresh_token()
                            if self.client.access_token:
                                page_headers["Authorization"] = (
                                    f"Bearer {self.client.access_token}"
                                )
            # Make the request
            if not page_selected_auth:
                # No suitable auth method found - validate authentication
                required_schemes = (
                    page_acceptable_schemes
                    if "page_acceptable_schemes" in locals()
                    else []
                )
                if required_schemes:
                    available = []
                    if page_available_bearer and "BearerToken" in required_schemes:
                        available.append("BearerToken")
                    if page_available_oauth2 and "OAuth2UserToken" in required_schemes:
                        available.append("OAuth2UserToken")
                    if page_available_oauth1 and "UserToken" in required_schemes:
                        available.append("UserToken")
                    if not available:
                        raise ValueError(
                            f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and page_available_bearer) or (s == 'OAuth2UserToken' and page_available_oauth2) or (s == 'UserToken' and page_available_oauth1)]}"
                        )
            response = self.client.session.get(
                url,
                params=page_params,
                headers=page_headers,
            )
            # Check for errors
            response.raise_for_status()
            # Parse the response data
            response_data = response.json()
            # Convert to Pydantic model if applicable
            page_response = SearchResponse.model_validate(response_data)
            # Yield this page
            yield page_response
            # Extract next_token from response
            next_token = None
            try:
                # Try response.meta.next_token (most common pattern)
                if hasattr(page_response, "meta") and page_response.meta is not None:
                    meta = page_response.meta
                    # If meta is a Pydantic model, try to dump it
                    if hasattr(meta, "model_dump"):
                        try:
                            meta_dict = meta.model_dump()
                            next_token = meta_dict.get("next_token")
                        except (AttributeError, TypeError):
                            pass
                    # Otherwise try attribute access
                    if not next_token and hasattr(meta, "next_token"):
                        next_token = getattr(meta, "next_token", None)
                    # If meta is a dict, access it directly
                    if not next_token and isinstance(meta, dict):
                        next_token = meta.get("next_token")
            except (AttributeError, TypeError):
                pass
            # Try dict access if we have a dict
            if not next_token and isinstance(response_data, dict):
                try:
                    meta = response_data.get("meta")
                    if meta and isinstance(meta, dict):
                        next_token = meta.get("next_token")
                except (AttributeError, TypeError, KeyError):
                    pass
            # If no next_token, we're done
            if not next_token:
                break
            # Update token for next iteration
            current_pagination_token = next_token

            # Optional: Add rate limit backoff here if needed
            # time.sleep(0.1)  # Small delay to avoid rate limits


    def unblock_dms(self, id: Any) -> UnblockDmsResponse:
        """
        Unblock DMs
        Unblocks direct messages to or from a specific User by their ID for the authenticated user.
        Args:
            id: The ID of the target User that the authenticated user requesting to unblock dms for.
            Returns:
            UnblockDmsResponse: Response data
        """
        url = self.client.base_url + "/2/users/{id}/dm/unblock"
        url = url.replace("{id}", str(id))
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        # UserToken: OAuth1.0a authentication - header will be built dynamically in request
        # OAuth1 header must be built per-request with method, URL, and body
        # This is handled in the request logic below
        params = {}
        headers = {}
        # Prepare request data
        json_data = None
        # Select authentication method based on endpoint requirements and available credentials
        # Priority strategy (matches TypeScript):
        # 1. If endpoint only accepts one method, use that (if available)
        # 2. If endpoint accepts multiple methods:
        #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
        #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
        # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
        selected_auth = None
        # Check what auth methods we have available
        available_bearer = bool(self.client.bearer_token)
        available_oauth2 = bool(self.client.access_token)
        available_oauth1 = bool(self.client.auth and self.client.auth.access_token)
        # Count acceptable schemes
        acceptable_schemes = []
        acceptable_schemes.append("OAuth2UserToken")
        acceptable_schemes.append("UserToken")
        # If only one scheme is acceptable, use it if available
        if len(acceptable_schemes) == 1:
            scheme = acceptable_schemes[0]
            if scheme == "BearerToken" and available_bearer:
                selected_auth = "bearer_token"
            elif scheme == "OAuth2UserToken" and available_oauth2:
                selected_auth = "oauth2_user_context"
            elif scheme == "UserToken" and available_oauth1:
                selected_auth = "oauth1"
        # Multiple schemes acceptable - use priority based on operation type
        elif len(acceptable_schemes) > 1:
            is_write_operation = "post" in ["POST", "PUT", "DELETE", "PATCH"]
            if is_write_operation:
                # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                if "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
            else:
                # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                if "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
        # Apply selected authentication
        if selected_auth == "oauth1":
            # OAuth1 authentication - build proper OAuth1 header dynamically
            # Build OAuth1 header with method, URL, and body
            # For OAuth1, we need to include query params in the URL for signature
            full_url = url
            if params:
                query_string = urllib.parse.urlencode(params)
                full_url = f"{url}?{query_string}" if query_string else url
            # Prepare body for OAuth1 signature (form-encoded, not JSON)
            body_string = ""
            # Build OAuth1 authorization header
            oauth_header = self.client.auth.build_request_header(
                method="post", url=full_url, body=body_string
            )
            headers["Authorization"] = oauth_header
        elif selected_auth == "bearer_token":
            # Bearer token authentication
            if self.client.bearer_token:
                headers["Authorization"] = f"Bearer {self.client.bearer_token}"
            elif self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
        elif selected_auth == "oauth2_user_context":
            # OAuth2 User Token authentication
            if self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
                # Check if token needs refresh
                if self.client.oauth2_auth and self.client.token:
                    if self.client.is_token_expired():
                        self.client.refresh_token()
                        if self.client.access_token:
                            headers["Authorization"] = (
                                f"Bearer {self.client.access_token}"
                            )
        # Make the request
        if not selected_auth:
            # No suitable auth method found - validate authentication
            required_schemes = (
                acceptable_schemes if "acceptable_schemes" in locals() else []
            )
            if required_schemes:
                available = []
                if available_bearer and "BearerToken" in required_schemes:
                    available.append("BearerToken")
                if available_oauth2 and "OAuth2UserToken" in required_schemes:
                    available.append("OAuth2UserToken")
                if available_oauth1 and "UserToken" in required_schemes:
                    available.append("UserToken")
                if not available:
                    raise ValueError(
                        f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and available_bearer) or (s == 'OAuth2UserToken' and available_oauth2) or (s == 'UserToken' and available_oauth1)]}"
                    )
        response = self.client.session.post(
            url,
            params=params,
            headers=headers,
        )
        # Check for errors
        response.raise_for_status()
        # Parse the response data
        response_data = response.json()
        # Convert to Pydantic model if applicable
        return UnblockDmsResponse.model_validate(response_data)


    def unfollow_user(
        self, source_user_id: Any, target_user_id: Any
    ) -> UnfollowUserResponse:
        """
        Unfollow User
        Causes the authenticated user to unfollow a specific user by their ID.
        Args:
            source_user_id: The ID of the authenticated source User that is requesting to unfollow the target User.
            target_user_id: The ID of the User that the source User is requesting to unfollow.
            Returns:
            UnfollowUserResponse: Response data
        """
        url = (
            self.client.base_url
            + "/2/users/{source_user_id}/following/{target_user_id}"
        )
        url = url.replace("{source_user_id}", str(source_user_id))
        url = url.replace("{target_user_id}", str(target_user_id))
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        # UserToken: OAuth1.0a authentication - header will be built dynamically in request
        # OAuth1 header must be built per-request with method, URL, and body
        # This is handled in the request logic below
        params = {}
        headers = {}
        # Prepare request data
        json_data = None
        # Select authentication method based on endpoint requirements and available credentials
        # Priority strategy (matches TypeScript):
        # 1. If endpoint only accepts one method, use that (if available)
        # 2. If endpoint accepts multiple methods:
        #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
        #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
        # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
        selected_auth = None
        # Check what auth methods we have available
        available_bearer = bool(self.client.bearer_token)
        available_oauth2 = bool(self.client.access_token)
        available_oauth1 = bool(self.client.auth and self.client.auth.access_token)
        # Count acceptable schemes
        acceptable_schemes = []
        acceptable_schemes.append("OAuth2UserToken")
        acceptable_schemes.append("UserToken")
        # If only one scheme is acceptable, use it if available
        if len(acceptable_schemes) == 1:
            scheme = acceptable_schemes[0]
            if scheme == "BearerToken" and available_bearer:
                selected_auth = "bearer_token"
            elif scheme == "OAuth2UserToken" and available_oauth2:
                selected_auth = "oauth2_user_context"
            elif scheme == "UserToken" and available_oauth1:
                selected_auth = "oauth1"
        # Multiple schemes acceptable - use priority based on operation type
        elif len(acceptable_schemes) > 1:
            is_write_operation = "delete" in ["POST", "PUT", "DELETE", "PATCH"]
            if is_write_operation:
                # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                if "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
            else:
                # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                if "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
        # Apply selected authentication
        if selected_auth == "oauth1":
            # OAuth1 authentication - build proper OAuth1 header dynamically
            # Build OAuth1 header with method, URL, and body
            # For OAuth1, we need to include query params in the URL for signature
            full_url = url
            if params:
                query_string = urllib.parse.urlencode(params)
                full_url = f"{url}?{query_string}" if query_string else url
            # Prepare body for OAuth1 signature (form-encoded, not JSON)
            body_string = ""
            # Build OAuth1 authorization header
            oauth_header = self.client.auth.build_request_header(
                method="delete", url=full_url, body=body_string
            )
            headers["Authorization"] = oauth_header
        elif selected_auth == "bearer_token":
            # Bearer token authentication
            if self.client.bearer_token:
                headers["Authorization"] = f"Bearer {self.client.bearer_token}"
            elif self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
        elif selected_auth == "oauth2_user_context":
            # OAuth2 User Token authentication
            if self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
                # Check if token needs refresh
                if self.client.oauth2_auth and self.client.token:
                    if self.client.is_token_expired():
                        self.client.refresh_token()
                        if self.client.access_token:
                            headers["Authorization"] = (
                                f"Bearer {self.client.access_token}"
                            )
        # Make the request
        if not selected_auth:
            # No suitable auth method found - validate authentication
            required_schemes = (
                acceptable_schemes if "acceptable_schemes" in locals() else []
            )
            if required_schemes:
                available = []
                if available_bearer and "BearerToken" in required_schemes:
                    available.append("BearerToken")
                if available_oauth2 and "OAuth2UserToken" in required_schemes:
                    available.append("OAuth2UserToken")
                if available_oauth1 and "UserToken" in required_schemes:
                    available.append("UserToken")
                if not available:
                    raise ValueError(
                        f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and available_bearer) or (s == 'OAuth2UserToken' and available_oauth2) or (s == 'UserToken' and available_oauth1)]}"
                    )
        response = self.client.session.delete(
            url,
            params=params,
            headers=headers,
        )
        # Check for errors
        response.raise_for_status()
        # Parse the response data
        response_data = response.json()
        # Convert to Pydantic model if applicable
        return UnfollowUserResponse.model_validate(response_data)


    def like_post(
        self, id: Any, body: Optional[LikePostRequest] = None
    ) -> LikePostResponse:
        """
        Like Post
        Causes the authenticated user to Like a specific Post by its ID.
        Args:
            id: The ID of the authenticated source User that is requesting to like the Post.
            body: Request body
        Returns:
            LikePostResponse: Response data
        """
        url = self.client.base_url + "/2/users/{id}/likes"
        url = url.replace("{id}", str(id))
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        # UserToken: OAuth1.0a authentication - header will be built dynamically in request
        # OAuth1 header must be built per-request with method, URL, and body
        # This is handled in the request logic below
        params = {}
        headers = {}
        headers["Content-Type"] = "application/json"
        # Prepare request data
        json_data = None
        if body is not None:
            json_data = (
                body.model_dump(exclude_none=True)
                if hasattr(body, "model_dump")
                else body
            )
        # Select authentication method based on endpoint requirements and available credentials
        # Priority strategy (matches TypeScript):
        # 1. If endpoint only accepts one method, use that (if available)
        # 2. If endpoint accepts multiple methods:
        #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
        #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
        # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
        selected_auth = None
        # Check what auth methods we have available
        available_bearer = bool(self.client.bearer_token)
        available_oauth2 = bool(self.client.access_token)
        available_oauth1 = bool(self.client.auth and self.client.auth.access_token)
        # Count acceptable schemes
        acceptable_schemes = []
        acceptable_schemes.append("OAuth2UserToken")
        acceptable_schemes.append("UserToken")
        # If only one scheme is acceptable, use it if available
        if len(acceptable_schemes) == 1:
            scheme = acceptable_schemes[0]
            if scheme == "BearerToken" and available_bearer:
                selected_auth = "bearer_token"
            elif scheme == "OAuth2UserToken" and available_oauth2:
                selected_auth = "oauth2_user_context"
            elif scheme == "UserToken" and available_oauth1:
                selected_auth = "oauth1"
        # Multiple schemes acceptable - use priority based on operation type
        elif len(acceptable_schemes) > 1:
            is_write_operation = "post" in ["POST", "PUT", "DELETE", "PATCH"]
            if is_write_operation:
                # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                if "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
            else:
                # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                if "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
        # Apply selected authentication
        if selected_auth == "oauth1":
            # OAuth1 authentication - build proper OAuth1 header dynamically
            # Build OAuth1 header with method, URL, and body
            # For OAuth1, we need to include query params in the URL for signature
            full_url = url
            if params:
                query_string = urllib.parse.urlencode(params)
                full_url = f"{url}?{query_string}" if query_string else url
            # Prepare body for OAuth1 signature (form-encoded, not JSON)
            body_string = ""
            if json_data:
                # OAuth1 spec: JSON bodies are NOT included in signature
                # But we still need to pass the body for the request
                body_string = ""
            # Build OAuth1 authorization header
            oauth_header = self.client.auth.build_request_header(
                method="post", url=full_url, body=body_string
            )
            headers["Authorization"] = oauth_header
        elif selected_auth == "bearer_token":
            # Bearer token authentication
            if self.client.bearer_token:
                headers["Authorization"] = f"Bearer {self.client.bearer_token}"
            elif self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
        elif selected_auth == "oauth2_user_context":
            # OAuth2 User Token authentication
            if self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
                # Check if token needs refresh
                if self.client.oauth2_auth and self.client.token:
                    if self.client.is_token_expired():
                        self.client.refresh_token()
                        if self.client.access_token:
                            headers["Authorization"] = (
                                f"Bearer {self.client.access_token}"
                            )
        # Make the request
        if not selected_auth:
            # No suitable auth method found - validate authentication
            required_schemes = (
                acceptable_schemes if "acceptable_schemes" in locals() else []
            )
            if required_schemes:
                available = []
                if available_bearer and "BearerToken" in required_schemes:
                    available.append("BearerToken")
                if available_oauth2 and "OAuth2UserToken" in required_schemes:
                    available.append("OAuth2UserToken")
                if available_oauth1 and "UserToken" in required_schemes:
                    available.append("UserToken")
                if not available:
                    raise ValueError(
                        f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and available_bearer) or (s == 'OAuth2UserToken' and available_oauth2) or (s == 'UserToken' and available_oauth1)]}"
                    )
        response = self.client.session.post(
            url,
            params=params,
            headers=headers,
            json=json_data,
        )
        # Check for errors
        response.raise_for_status()
        # Parse the response data
        response_data = response.json()
        # Convert to Pydantic model if applicable
        return LikePostResponse.model_validate(response_data)


    def get_by_usernames(
        self,
        usernames: List,
        user_fields: List = None,
        expansions: List = None,
        tweet_fields: List = None,
    ) -> GetByUsernamesResponse:
        """
        Get Users by usernames
        Retrieves details of multiple Users by their usernames.
        Args:
            usernames: A list of usernames, comma-separated.
            user_fields: A comma separated list of User fields to display.
            expansions: A comma separated list of fields to expand.
            tweet_fields: A comma separated list of Tweet fields to display.
            Returns:
            GetByUsernamesResponse: Response data
        """
        url = self.client.base_url + "/2/users/by"
        # Priority: bearer_token > access_token (matches TypeScript behavior)
        if self.client.bearer_token:
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.bearer_token}"
            )
        elif self.client.access_token:
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        # UserToken: OAuth1.0a authentication - header will be built dynamically in request
        # OAuth1 header must be built per-request with method, URL, and body
        # This is handled in the request logic below
        params = {}
        if usernames is not None:
            params["usernames"] = ",".join(str(item) for item in usernames)
        if user_fields is not None:
            params["user.fields"] = ",".join(str(item) for item in user_fields)
        if expansions is not None:
            params["expansions"] = ",".join(str(item) for item in expansions)
        if tweet_fields is not None:
            params["tweet.fields"] = ",".join(str(item) for item in tweet_fields)
        headers = {}
        # Prepare request data
        json_data = None
        # Select authentication method based on endpoint requirements and available credentials
        # Priority strategy (matches TypeScript):
        # 1. If endpoint only accepts one method, use that (if available)
        # 2. If endpoint accepts multiple methods:
        #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
        #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
        # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
        selected_auth = None
        # Check what auth methods we have available
        available_bearer = bool(self.client.bearer_token)
        available_oauth2 = bool(self.client.access_token)
        available_oauth1 = bool(self.client.auth and self.client.auth.access_token)
        # Count acceptable schemes
        acceptable_schemes = []
        acceptable_schemes.append("BearerToken")
        acceptable_schemes.append("OAuth2UserToken")
        acceptable_schemes.append("UserToken")
        # If only one scheme is acceptable, use it if available
        if len(acceptable_schemes) == 1:
            scheme = acceptable_schemes[0]
            if scheme == "BearerToken" and available_bearer:
                selected_auth = "bearer_token"
            elif scheme == "OAuth2UserToken" and available_oauth2:
                selected_auth = "oauth2_user_context"
            elif scheme == "UserToken" and available_oauth1:
                selected_auth = "oauth1"
        # Multiple schemes acceptable - use priority based on operation type
        elif len(acceptable_schemes) > 1:
            is_write_operation = "get" in ["POST", "PUT", "DELETE", "PATCH"]
            if is_write_operation:
                # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                if "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
            else:
                # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                if "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
        # Apply selected authentication
        if selected_auth == "oauth1":
            # OAuth1 authentication - build proper OAuth1 header dynamically
            # Build OAuth1 header with method, URL, and body
            # For OAuth1, we need to include query params in the URL for signature
            full_url = url
            if params:
                query_string = urllib.parse.urlencode(params)
                full_url = f"{url}?{query_string}" if query_string else url
            # Prepare body for OAuth1 signature (form-encoded, not JSON)
            body_string = ""
            # Build OAuth1 authorization header
            oauth_header = self.client.auth.build_request_header(
                method="get", url=full_url, body=body_string
            )
            headers["Authorization"] = oauth_header
        elif selected_auth == "bearer_token":
            # Bearer token authentication
            if self.client.bearer_token:
                headers["Authorization"] = f"Bearer {self.client.bearer_token}"
            elif self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
        elif selected_auth == "oauth2_user_context":
            # OAuth2 User Token authentication
            if self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
                # Check if token needs refresh
                if self.client.oauth2_auth and self.client.token:
                    if self.client.is_token_expired():
                        self.client.refresh_token()
                        if self.client.access_token:
                            headers["Authorization"] = (
                                f"Bearer {self.client.access_token}"
                            )
        # Make the request
        if not selected_auth:
            # No suitable auth method found - validate authentication
            required_schemes = (
                acceptable_schemes if "acceptable_schemes" in locals() else []
            )
            if required_schemes:
                available = []
                if available_bearer and "BearerToken" in required_schemes:
                    available.append("BearerToken")
                if available_oauth2 and "OAuth2UserToken" in required_schemes:
                    available.append("OAuth2UserToken")
                if available_oauth1 and "UserToken" in required_schemes:
                    available.append("UserToken")
                if not available:
                    raise ValueError(
                        f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and available_bearer) or (s == 'OAuth2UserToken' and available_oauth2) or (s == 'UserToken' and available_oauth1)]}"
                    )
        response = self.client.session.get(
            url,
            params=params,
            headers=headers,
        )
        # Check for errors
        response.raise_for_status()
        # Parse the response data
        response_data = response.json()
        # Convert to Pydantic model if applicable
        return GetByUsernamesResponse.model_validate(response_data)


    def get_affiliates(
        self,
        id: Any,
        max_results: int = None,
        pagination_token: Any = None,
        user_fields: List = None,
        expansions: List = None,
        tweet_fields: List = None,
    ) -> Iterator[GetAffiliatesResponse]:
        """
        Get affiliates
        Retrieves a list of Users who are affiliated with a specific organization User by their ID.
        Args:
            id: The ID of the User to lookup.
            max_results: The maximum number of results.
            pagination_token: This parameter is used to get a specified 'page' of results.
            user_fields: A comma separated list of User fields to display.
            expansions: A comma separated list of fields to expand.
            tweet_fields: A comma separated list of Tweet fields to display.
            Yields:
            GetAffiliatesResponse: One page of results at a time. Automatically handles pagination using next_token.
        Note:
            This method automatically paginates through all results. To get just the first page,
            you can call it once and break, or use the pagination_token parameter to start at a specific page.
        """
        url = self.client.base_url + "/2/users/{id}/affiliates"
        url = url.replace("{id}", str(id))
        # Priority: bearer_token > access_token (matches TypeScript behavior)
        if self.client.bearer_token:
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.bearer_token}"
            )
        elif self.client.access_token:
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        # UserToken: OAuth1.0a authentication - header will be built dynamically in request
        # OAuth1 header must be built per-request with method, URL, and body
        # This is handled in the request logic below
        headers = {}
        # Prepare request data
        json_data = None
        # Determine pagination parameter name
        pagination_param_name = "pagination_token"
        # Start with provided pagination_token, or None for first page
        # Check if pagination_token parameter exists in the method signature
        current_pagination_token = pagination_token
        while True:
            # Build query parameters for this page
            page_params = {}
            if max_results is not None:
                page_params["max_results"] = max_results
            if user_fields is not None:
                page_params["user.fields"] = ",".join(str(item) for item in user_fields)
            if expansions is not None:
                page_params["expansions"] = ",".join(str(item) for item in expansions)
            if tweet_fields is not None:
                page_params["tweet.fields"] = ",".join(
                    str(item) for item in tweet_fields
                )
            # Add pagination token for this page
            if current_pagination_token:
                page_params[pagination_param_name] = current_pagination_token
            # Select authentication method (same logic as regular_request)
            # Priority strategy (matches TypeScript):
            # 1. If endpoint only accepts one method, use that (if available)
            # 2. If endpoint accepts multiple methods:
            #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
            #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
            # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
            page_selected_auth = None
            # Check what auth methods we have available
            page_available_bearer = bool(self.client.bearer_token)
            page_available_oauth2 = bool(self.client.access_token)
            page_available_oauth1 = bool(
                self.client.auth and self.client.auth.access_token
            )
            # Count acceptable schemes
            page_acceptable_schemes = []
            page_acceptable_schemes.append("BearerToken")
            page_acceptable_schemes.append("OAuth2UserToken")
            page_acceptable_schemes.append("UserToken")
            # If only one scheme is acceptable, use it if available
            if len(page_acceptable_schemes) == 1:
                scheme = page_acceptable_schemes[0]
                if scheme == "BearerToken" and page_available_bearer:
                    page_selected_auth = "bearer_token"
                elif scheme == "OAuth2UserToken" and page_available_oauth2:
                    page_selected_auth = "oauth2_user_context"
                elif scheme == "UserToken" and page_available_oauth1:
                    page_selected_auth = "oauth1"
            # Multiple schemes acceptable - use priority based on operation type
            elif len(page_acceptable_schemes) > 1:
                is_write_operation = "get" in ["POST", "PUT", "DELETE", "PATCH"]
                if is_write_operation:
                    # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                    if "UserToken" in page_acceptable_schemes and page_available_oauth1:
                        page_selected_auth = "oauth1"
                    elif (
                        "OAuth2UserToken" in page_acceptable_schemes
                        and page_available_oauth2
                    ):
                        page_selected_auth = "oauth2_user_context"
                    elif (
                        "BearerToken" in page_acceptable_schemes
                        and page_available_bearer
                    ):
                        page_selected_auth = "bearer_token"
                else:
                    # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                    if (
                        "BearerToken" in page_acceptable_schemes
                        and page_available_bearer
                    ):
                        page_selected_auth = "bearer_token"
                    elif (
                        "OAuth2UserToken" in page_acceptable_schemes
                        and page_available_oauth2
                    ):
                        page_selected_auth = "oauth2_user_context"
                    elif (
                        "UserToken" in page_acceptable_schemes and page_available_oauth1
                    ):
                        page_selected_auth = "oauth1"
            # Apply selected authentication for this page
            page_headers = headers.copy()
            if page_selected_auth == "oauth1":
                # OAuth1 authentication - build proper OAuth1 header dynamically
                # Build OAuth1 header with method, URL, and body
                # For OAuth1, we need to include query params in the URL for signature
                full_url = url
                if page_params:
                    query_string = urllib.parse.urlencode(page_params)
                    full_url = f"{url}?{query_string}" if query_string else url
                # Prepare body for OAuth1 signature (form-encoded, not JSON)
                body_string = ""
                # Build OAuth1 authorization header
                oauth_header = self.client.auth.build_request_header(
                    method="get", url=full_url, body=body_string
                )
                page_headers["Authorization"] = oauth_header
            elif page_selected_auth == "bearer_token":
                # Bearer token authentication
                if self.client.bearer_token:
                    page_headers["Authorization"] = f"Bearer {self.client.bearer_token}"
                elif self.client.access_token:
                    page_headers["Authorization"] = f"Bearer {self.client.access_token}"
            elif page_selected_auth == "oauth2_user_context":
                # OAuth2 User Token authentication
                if self.client.access_token:
                    page_headers["Authorization"] = f"Bearer {self.client.access_token}"
                    # Check if token needs refresh
                    if self.client.oauth2_auth and self.client.token:
                        if self.client.is_token_expired():
                            self.client.refresh_token()
                            if self.client.access_token:
                                page_headers["Authorization"] = (
                                    f"Bearer {self.client.access_token}"
                                )
            # Make the request
            if not page_selected_auth:
                # No suitable auth method found - validate authentication
                required_schemes = (
                    page_acceptable_schemes
                    if "page_acceptable_schemes" in locals()
                    else []
                )
                if required_schemes:
                    available = []
                    if page_available_bearer and "BearerToken" in required_schemes:
                        available.append("BearerToken")
                    if page_available_oauth2 and "OAuth2UserToken" in required_schemes:
                        available.append("OAuth2UserToken")
                    if page_available_oauth1 and "UserToken" in required_schemes:
                        available.append("UserToken")
                    if not available:
                        raise ValueError(
                            f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and page_available_bearer) or (s == 'OAuth2UserToken' and page_available_oauth2) or (s == 'UserToken' and page_available_oauth1)]}"
                        )
            response = self.client.session.get(
                url,
                params=page_params,
                headers=page_headers,
            )
            # Check for errors
            response.raise_for_status()
            # Parse the response data
            response_data = response.json()
            # Convert to Pydantic model if applicable
            page_response = GetAffiliatesResponse.model_validate(response_data)
            # Yield this page
            yield page_response
            # Extract next_token from response
            next_token = None
            try:
                # Try response.meta.next_token (most common pattern)
                if hasattr(page_response, "meta") and page_response.meta is not None:
                    meta = page_response.meta
                    # If meta is a Pydantic model, try to dump it
                    if hasattr(meta, "model_dump"):
                        try:
                            meta_dict = meta.model_dump()
                            next_token = meta_dict.get("next_token")
                        except (AttributeError, TypeError):
                            pass
                    # Otherwise try attribute access
                    if not next_token and hasattr(meta, "next_token"):
                        next_token = getattr(meta, "next_token", None)
                    # If meta is a dict, access it directly
                    if not next_token and isinstance(meta, dict):
                        next_token = meta.get("next_token")
            except (AttributeError, TypeError):
                pass
            # Try dict access if we have a dict
            if not next_token and isinstance(response_data, dict):
                try:
                    meta = response_data.get("meta")
                    if meta and isinstance(meta, dict):
                        next_token = meta.get("next_token")
                except (AttributeError, TypeError, KeyError):
                    pass
            # If no next_token, we're done
            if not next_token:
                break
            # Update token for next iteration
            current_pagination_token = next_token

            # Optional: Add rate limit backoff here if needed
            # time.sleep(0.1)  # Small delay to avoid rate limits


    def get_by_id(
        self,
        id: Any,
        user_fields: List = None,
        expansions: List = None,
        tweet_fields: List = None,
    ) -> GetByIdResponse:
        """
        Get User by ID
        Retrieves details of a specific User by their ID.
        Args:
            id: The ID of the User to lookup.
            user_fields: A comma separated list of User fields to display.
            expansions: A comma separated list of fields to expand.
            tweet_fields: A comma separated list of Tweet fields to display.
            Returns:
            GetByIdResponse: Response data
        """
        url = self.client.base_url + "/2/users/{id}"
        url = url.replace("{id}", str(id))
        # Priority: bearer_token > access_token (matches TypeScript behavior)
        if self.client.bearer_token:
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.bearer_token}"
            )
        elif self.client.access_token:
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        # UserToken: OAuth1.0a authentication - header will be built dynamically in request
        # OAuth1 header must be built per-request with method, URL, and body
        # This is handled in the request logic below
        params = {}
        if user_fields is not None:
            params["user.fields"] = ",".join(str(item) for item in user_fields)
        if expansions is not None:
            params["expansions"] = ",".join(str(item) for item in expansions)
        if tweet_fields is not None:
            params["tweet.fields"] = ",".join(str(item) for item in tweet_fields)
        headers = {}
        # Prepare request data
        json_data = None
        # Select authentication method based on endpoint requirements and available credentials
        # Priority strategy (matches TypeScript):
        # 1. If endpoint only accepts one method, use that (if available)
        # 2. If endpoint accepts multiple methods:
        #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
        #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
        # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
        selected_auth = None
        # Check what auth methods we have available
        available_bearer = bool(self.client.bearer_token)
        available_oauth2 = bool(self.client.access_token)
        available_oauth1 = bool(self.client.auth and self.client.auth.access_token)
        # Count acceptable schemes
        acceptable_schemes = []
        acceptable_schemes.append("BearerToken")
        acceptable_schemes.append("OAuth2UserToken")
        acceptable_schemes.append("UserToken")
        # If only one scheme is acceptable, use it if available
        if len(acceptable_schemes) == 1:
            scheme = acceptable_schemes[0]
            if scheme == "BearerToken" and available_bearer:
                selected_auth = "bearer_token"
            elif scheme == "OAuth2UserToken" and available_oauth2:
                selected_auth = "oauth2_user_context"
            elif scheme == "UserToken" and available_oauth1:
                selected_auth = "oauth1"
        # Multiple schemes acceptable - use priority based on operation type
        elif len(acceptable_schemes) > 1:
            is_write_operation = "get" in ["POST", "PUT", "DELETE", "PATCH"]
            if is_write_operation:
                # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                if "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
            else:
                # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                if "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
        # Apply selected authentication
        if selected_auth == "oauth1":
            # OAuth1 authentication - build proper OAuth1 header dynamically
            # Build OAuth1 header with method, URL, and body
            # For OAuth1, we need to include query params in the URL for signature
            full_url = url
            if params:
                query_string = urllib.parse.urlencode(params)
                full_url = f"{url}?{query_string}" if query_string else url
            # Prepare body for OAuth1 signature (form-encoded, not JSON)
            body_string = ""
            # Build OAuth1 authorization header
            oauth_header = self.client.auth.build_request_header(
                method="get", url=full_url, body=body_string
            )
            headers["Authorization"] = oauth_header
        elif selected_auth == "bearer_token":
            # Bearer token authentication
            if self.client.bearer_token:
                headers["Authorization"] = f"Bearer {self.client.bearer_token}"
            elif self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
        elif selected_auth == "oauth2_user_context":
            # OAuth2 User Token authentication
            if self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
                # Check if token needs refresh
                if self.client.oauth2_auth and self.client.token:
                    if self.client.is_token_expired():
                        self.client.refresh_token()
                        if self.client.access_token:
                            headers["Authorization"] = (
                                f"Bearer {self.client.access_token}"
                            )
        # Make the request
        if not selected_auth:
            # No suitable auth method found - validate authentication
            required_schemes = (
                acceptable_schemes if "acceptable_schemes" in locals() else []
            )
            if required_schemes:
                available = []
                if available_bearer and "BearerToken" in required_schemes:
                    available.append("BearerToken")
                if available_oauth2 and "OAuth2UserToken" in required_schemes:
                    available.append("OAuth2UserToken")
                if available_oauth1 and "UserToken" in required_schemes:
                    available.append("UserToken")
                if not available:
                    raise ValueError(
                        f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and available_bearer) or (s == 'OAuth2UserToken' and available_oauth2) or (s == 'UserToken' and available_oauth1)]}"
                    )
        response = self.client.session.get(
            url,
            params=params,
            headers=headers,
        )
        # Check for errors
        response.raise_for_status()
        # Parse the response data
        response_data = response.json()
        # Convert to Pydantic model if applicable
        return GetByIdResponse.model_validate(response_data)


    def get_posts(
        self,
        id: Any,
        since_id: Any = None,
        until_id: Any = None,
        max_results: int = None,
        pagination_token: Any = None,
        exclude: List = None,
        start_time: str = None,
        end_time: str = None,
        tweet_fields: List = None,
        expansions: List = None,
        media_fields: List = None,
        poll_fields: List = None,
        user_fields: List = None,
        place_fields: List = None,
    ) -> Iterator[GetPostsResponse]:
        """
        Get Posts
        Retrieves a list of posts authored by a specific User by their ID.
        Args:
            id: The ID of the User to lookup.
            since_id: The minimum Post ID to be included in the result set. This parameter takes precedence over start_time if both are specified.
            until_id: The maximum Post ID to be included in the result set. This parameter takes precedence over end_time if both are specified.
            max_results: The maximum number of results.
            pagination_token: This parameter is used to get the next 'page' of results.
            exclude: The set of entities to exclude (e.g. 'replies' or 'retweets').
            start_time: YYYY-MM-DDTHH:mm:ssZ. The earliest UTC timestamp from which the Posts will be provided. The since_id parameter takes precedence if it is also specified.
            end_time: YYYY-MM-DDTHH:mm:ssZ. The latest UTC timestamp to which the Posts will be provided. The until_id parameter takes precedence if it is also specified.
            tweet_fields: A comma separated list of Tweet fields to display.
            expansions: A comma separated list of fields to expand.
            media_fields: A comma separated list of Media fields to display.
            poll_fields: A comma separated list of Poll fields to display.
            user_fields: A comma separated list of User fields to display.
            place_fields: A comma separated list of Place fields to display.
            Yields:
            GetPostsResponse: One page of results at a time. Automatically handles pagination using next_token.
        Note:
            This method automatically paginates through all results. To get just the first page,
            you can call it once and break, or use the pagination_token parameter to start at a specific page.
        """
        url = self.client.base_url + "/2/users/{id}/tweets"
        url = url.replace("{id}", str(id))
        # Priority: bearer_token > access_token (matches TypeScript behavior)
        if self.client.bearer_token:
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.bearer_token}"
            )
        elif self.client.access_token:
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        # UserToken: OAuth1.0a authentication - header will be built dynamically in request
        # OAuth1 header must be built per-request with method, URL, and body
        # This is handled in the request logic below
        headers = {}
        # Prepare request data
        json_data = None
        # Determine pagination parameter name
        pagination_param_name = "pagination_token"
        # Start with provided pagination_token, or None for first page
        # Check if pagination_token parameter exists in the method signature
        current_pagination_token = pagination_token
        while True:
            # Build query parameters for this page
            page_params = {}
            if since_id is not None:
                page_params["since_id"] = since_id
            if until_id is not None:
                page_params["until_id"] = until_id
            if max_results is not None:
                page_params["max_results"] = max_results
            if exclude is not None:
                page_params["exclude"] = ",".join(str(item) for item in exclude)
            if start_time is not None:
                page_params["start_time"] = start_time
            if end_time is not None:
                page_params["end_time"] = end_time
            if tweet_fields is not None:
                page_params["tweet.fields"] = ",".join(
                    str(item) for item in tweet_fields
                )
            if expansions is not None:
                page_params["expansions"] = ",".join(str(item) for item in expansions)
            if media_fields is not None:
                page_params["media.fields"] = ",".join(
                    str(item) for item in media_fields
                )
            if poll_fields is not None:
                page_params["poll.fields"] = ",".join(str(item) for item in poll_fields)
            if user_fields is not None:
                page_params["user.fields"] = ",".join(str(item) for item in user_fields)
            if place_fields is not None:
                page_params["place.fields"] = ",".join(
                    str(item) for item in place_fields
                )
            # Add pagination token for this page
            if current_pagination_token:
                page_params[pagination_param_name] = current_pagination_token
            # Select authentication method (same logic as regular_request)
            # Priority strategy (matches TypeScript):
            # 1. If endpoint only accepts one method, use that (if available)
            # 2. If endpoint accepts multiple methods:
            #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
            #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
            # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
            page_selected_auth = None
            # Check what auth methods we have available
            page_available_bearer = bool(self.client.bearer_token)
            page_available_oauth2 = bool(self.client.access_token)
            page_available_oauth1 = bool(
                self.client.auth and self.client.auth.access_token
            )
            # Count acceptable schemes
            page_acceptable_schemes = []
            page_acceptable_schemes.append("BearerToken")
            page_acceptable_schemes.append("OAuth2UserToken")
            page_acceptable_schemes.append("UserToken")
            # If only one scheme is acceptable, use it if available
            if len(page_acceptable_schemes) == 1:
                scheme = page_acceptable_schemes[0]
                if scheme == "BearerToken" and page_available_bearer:
                    page_selected_auth = "bearer_token"
                elif scheme == "OAuth2UserToken" and page_available_oauth2:
                    page_selected_auth = "oauth2_user_context"
                elif scheme == "UserToken" and page_available_oauth1:
                    page_selected_auth = "oauth1"
            # Multiple schemes acceptable - use priority based on operation type
            elif len(page_acceptable_schemes) > 1:
                is_write_operation = "get" in ["POST", "PUT", "DELETE", "PATCH"]
                if is_write_operation:
                    # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                    if "UserToken" in page_acceptable_schemes and page_available_oauth1:
                        page_selected_auth = "oauth1"
                    elif (
                        "OAuth2UserToken" in page_acceptable_schemes
                        and page_available_oauth2
                    ):
                        page_selected_auth = "oauth2_user_context"
                    elif (
                        "BearerToken" in page_acceptable_schemes
                        and page_available_bearer
                    ):
                        page_selected_auth = "bearer_token"
                else:
                    # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                    if (
                        "BearerToken" in page_acceptable_schemes
                        and page_available_bearer
                    ):
                        page_selected_auth = "bearer_token"
                    elif (
                        "OAuth2UserToken" in page_acceptable_schemes
                        and page_available_oauth2
                    ):
                        page_selected_auth = "oauth2_user_context"
                    elif (
                        "UserToken" in page_acceptable_schemes and page_available_oauth1
                    ):
                        page_selected_auth = "oauth1"
            # Apply selected authentication for this page
            page_headers = headers.copy()
            if page_selected_auth == "oauth1":
                # OAuth1 authentication - build proper OAuth1 header dynamically
                # Build OAuth1 header with method, URL, and body
                # For OAuth1, we need to include query params in the URL for signature
                full_url = url
                if page_params:
                    query_string = urllib.parse.urlencode(page_params)
                    full_url = f"{url}?{query_string}" if query_string else url
                # Prepare body for OAuth1 signature (form-encoded, not JSON)
                body_string = ""
                # Build OAuth1 authorization header
                oauth_header = self.client.auth.build_request_header(
                    method="get", url=full_url, body=body_string
                )
                page_headers["Authorization"] = oauth_header
            elif page_selected_auth == "bearer_token":
                # Bearer token authentication
                if self.client.bearer_token:
                    page_headers["Authorization"] = f"Bearer {self.client.bearer_token}"
                elif self.client.access_token:
                    page_headers["Authorization"] = f"Bearer {self.client.access_token}"
            elif page_selected_auth == "oauth2_user_context":
                # OAuth2 User Token authentication
                if self.client.access_token:
                    page_headers["Authorization"] = f"Bearer {self.client.access_token}"
                    # Check if token needs refresh
                    if self.client.oauth2_auth and self.client.token:
                        if self.client.is_token_expired():
                            self.client.refresh_token()
                            if self.client.access_token:
                                page_headers["Authorization"] = (
                                    f"Bearer {self.client.access_token}"
                                )
            # Make the request
            if not page_selected_auth:
                # No suitable auth method found - validate authentication
                required_schemes = (
                    page_acceptable_schemes
                    if "page_acceptable_schemes" in locals()
                    else []
                )
                if required_schemes:
                    available = []
                    if page_available_bearer and "BearerToken" in required_schemes:
                        available.append("BearerToken")
                    if page_available_oauth2 and "OAuth2UserToken" in required_schemes:
                        available.append("OAuth2UserToken")
                    if page_available_oauth1 and "UserToken" in required_schemes:
                        available.append("UserToken")
                    if not available:
                        raise ValueError(
                            f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and page_available_bearer) or (s == 'OAuth2UserToken' and page_available_oauth2) or (s == 'UserToken' and page_available_oauth1)]}"
                        )
            response = self.client.session.get(
                url,
                params=page_params,
                headers=page_headers,
            )
            # Check for errors
            response.raise_for_status()
            # Parse the response data
            response_data = response.json()
            # Convert to Pydantic model if applicable
            page_response = GetPostsResponse.model_validate(response_data)
            # Yield this page
            yield page_response
            # Extract next_token from response
            next_token = None
            try:
                # Try response.meta.next_token (most common pattern)
                if hasattr(page_response, "meta") and page_response.meta is not None:
                    meta = page_response.meta
                    # If meta is a Pydantic model, try to dump it
                    if hasattr(meta, "model_dump"):
                        try:
                            meta_dict = meta.model_dump()
                            next_token = meta_dict.get("next_token")
                        except (AttributeError, TypeError):
                            pass
                    # Otherwise try attribute access
                    if not next_token and hasattr(meta, "next_token"):
                        next_token = getattr(meta, "next_token", None)
                    # If meta is a dict, access it directly
                    if not next_token and isinstance(meta, dict):
                        next_token = meta.get("next_token")
            except (AttributeError, TypeError):
                pass
            # Try dict access if we have a dict
            if not next_token and isinstance(response_data, dict):
                try:
                    meta = response_data.get("meta")
                    if meta and isinstance(meta, dict):
                        next_token = meta.get("next_token")
                except (AttributeError, TypeError, KeyError):
                    pass
            # If no next_token, we're done
            if not next_token:
                break
            # Update token for next iteration
            current_pagination_token = next_token

            # Optional: Add rate limit backoff here if needed
            # time.sleep(0.1)  # Small delay to avoid rate limits


    def get_followed_lists(
        self,
        id: Any,
        max_results: int = None,
        pagination_token: Any = None,
        list_fields: List = None,
        expansions: List = None,
        user_fields: List = None,
    ) -> Iterator[GetFollowedListsResponse]:
        """
        Get followed Lists
        Retrieves a list of Lists followed by a specific User by their ID.
        Args:
            id: The ID of the User to lookup.
            max_results: The maximum number of results.
            pagination_token: This parameter is used to get a specified 'page' of results.
            list_fields: A comma separated list of List fields to display.
            expansions: A comma separated list of fields to expand.
            user_fields: A comma separated list of User fields to display.
            Yields:
            GetFollowedListsResponse: One page of results at a time. Automatically handles pagination using next_token.
        Note:
            This method automatically paginates through all results. To get just the first page,
            you can call it once and break, or use the pagination_token parameter to start at a specific page.
        """
        url = self.client.base_url + "/2/users/{id}/followed_lists"
        url = url.replace("{id}", str(id))
        # Priority: bearer_token > access_token (matches TypeScript behavior)
        if self.client.bearer_token:
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.bearer_token}"
            )
        elif self.client.access_token:
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        # UserToken: OAuth1.0a authentication - header will be built dynamically in request
        # OAuth1 header must be built per-request with method, URL, and body
        # This is handled in the request logic below
        headers = {}
        # Prepare request data
        json_data = None
        # Determine pagination parameter name
        pagination_param_name = "pagination_token"
        # Start with provided pagination_token, or None for first page
        # Check if pagination_token parameter exists in the method signature
        current_pagination_token = pagination_token
        while True:
            # Build query parameters for this page
            page_params = {}
            if max_results is not None:
                page_params["max_results"] = max_results
            if list_fields is not None:
                page_params["list.fields"] = ",".join(str(item) for item in list_fields)
            if expansions is not None:
                page_params["expansions"] = ",".join(str(item) for item in expansions)
            if user_fields is not None:
                page_params["user.fields"] = ",".join(str(item) for item in user_fields)
            # Add pagination token for this page
            if current_pagination_token:
                page_params[pagination_param_name] = current_pagination_token
            # Select authentication method (same logic as regular_request)
            # Priority strategy (matches TypeScript):
            # 1. If endpoint only accepts one method, use that (if available)
            # 2. If endpoint accepts multiple methods:
            #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
            #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
            # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
            page_selected_auth = None
            # Check what auth methods we have available
            page_available_bearer = bool(self.client.bearer_token)
            page_available_oauth2 = bool(self.client.access_token)
            page_available_oauth1 = bool(
                self.client.auth and self.client.auth.access_token
            )
            # Count acceptable schemes
            page_acceptable_schemes = []
            page_acceptable_schemes.append("BearerToken")
            page_acceptable_schemes.append("OAuth2UserToken")
            page_acceptable_schemes.append("UserToken")
            # If only one scheme is acceptable, use it if available
            if len(page_acceptable_schemes) == 1:
                scheme = page_acceptable_schemes[0]
                if scheme == "BearerToken" and page_available_bearer:
                    page_selected_auth = "bearer_token"
                elif scheme == "OAuth2UserToken" and page_available_oauth2:
                    page_selected_auth = "oauth2_user_context"
                elif scheme == "UserToken" and page_available_oauth1:
                    page_selected_auth = "oauth1"
            # Multiple schemes acceptable - use priority based on operation type
            elif len(page_acceptable_schemes) > 1:
                is_write_operation = "get" in ["POST", "PUT", "DELETE", "PATCH"]
                if is_write_operation:
                    # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                    if "UserToken" in page_acceptable_schemes and page_available_oauth1:
                        page_selected_auth = "oauth1"
                    elif (
                        "OAuth2UserToken" in page_acceptable_schemes
                        and page_available_oauth2
                    ):
                        page_selected_auth = "oauth2_user_context"
                    elif (
                        "BearerToken" in page_acceptable_schemes
                        and page_available_bearer
                    ):
                        page_selected_auth = "bearer_token"
                else:
                    # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                    if (
                        "BearerToken" in page_acceptable_schemes
                        and page_available_bearer
                    ):
                        page_selected_auth = "bearer_token"
                    elif (
                        "OAuth2UserToken" in page_acceptable_schemes
                        and page_available_oauth2
                    ):
                        page_selected_auth = "oauth2_user_context"
                    elif (
                        "UserToken" in page_acceptable_schemes and page_available_oauth1
                    ):
                        page_selected_auth = "oauth1"
            # Apply selected authentication for this page
            page_headers = headers.copy()
            if page_selected_auth == "oauth1":
                # OAuth1 authentication - build proper OAuth1 header dynamically
                # Build OAuth1 header with method, URL, and body
                # For OAuth1, we need to include query params in the URL for signature
                full_url = url
                if page_params:
                    query_string = urllib.parse.urlencode(page_params)
                    full_url = f"{url}?{query_string}" if query_string else url
                # Prepare body for OAuth1 signature (form-encoded, not JSON)
                body_string = ""
                # Build OAuth1 authorization header
                oauth_header = self.client.auth.build_request_header(
                    method="get", url=full_url, body=body_string
                )
                page_headers["Authorization"] = oauth_header
            elif page_selected_auth == "bearer_token":
                # Bearer token authentication
                if self.client.bearer_token:
                    page_headers["Authorization"] = f"Bearer {self.client.bearer_token}"
                elif self.client.access_token:
                    page_headers["Authorization"] = f"Bearer {self.client.access_token}"
            elif page_selected_auth == "oauth2_user_context":
                # OAuth2 User Token authentication
                if self.client.access_token:
                    page_headers["Authorization"] = f"Bearer {self.client.access_token}"
                    # Check if token needs refresh
                    if self.client.oauth2_auth and self.client.token:
                        if self.client.is_token_expired():
                            self.client.refresh_token()
                            if self.client.access_token:
                                page_headers["Authorization"] = (
                                    f"Bearer {self.client.access_token}"
                                )
            # Make the request
            if not page_selected_auth:
                # No suitable auth method found - validate authentication
                required_schemes = (
                    page_acceptable_schemes
                    if "page_acceptable_schemes" in locals()
                    else []
                )
                if required_schemes:
                    available = []
                    if page_available_bearer and "BearerToken" in required_schemes:
                        available.append("BearerToken")
                    if page_available_oauth2 and "OAuth2UserToken" in required_schemes:
                        available.append("OAuth2UserToken")
                    if page_available_oauth1 and "UserToken" in required_schemes:
                        available.append("UserToken")
                    if not available:
                        raise ValueError(
                            f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and page_available_bearer) or (s == 'OAuth2UserToken' and page_available_oauth2) or (s == 'UserToken' and page_available_oauth1)]}"
                        )
            response = self.client.session.get(
                url,
                params=page_params,
                headers=page_headers,
            )
            # Check for errors
            response.raise_for_status()
            # Parse the response data
            response_data = response.json()
            # Convert to Pydantic model if applicable
            page_response = GetFollowedListsResponse.model_validate(response_data)
            # Yield this page
            yield page_response
            # Extract next_token from response
            next_token = None
            try:
                # Try response.meta.next_token (most common pattern)
                if hasattr(page_response, "meta") and page_response.meta is not None:
                    meta = page_response.meta
                    # If meta is a Pydantic model, try to dump it
                    if hasattr(meta, "model_dump"):
                        try:
                            meta_dict = meta.model_dump()
                            next_token = meta_dict.get("next_token")
                        except (AttributeError, TypeError):
                            pass
                    # Otherwise try attribute access
                    if not next_token and hasattr(meta, "next_token"):
                        next_token = getattr(meta, "next_token", None)
                    # If meta is a dict, access it directly
                    if not next_token and isinstance(meta, dict):
                        next_token = meta.get("next_token")
            except (AttributeError, TypeError):
                pass
            # Try dict access if we have a dict
            if not next_token and isinstance(response_data, dict):
                try:
                    meta = response_data.get("meta")
                    if meta and isinstance(meta, dict):
                        next_token = meta.get("next_token")
                except (AttributeError, TypeError, KeyError):
                    pass
            # If no next_token, we're done
            if not next_token:
                break
            # Update token for next iteration
            current_pagination_token = next_token

            # Optional: Add rate limit backoff here if needed
            # time.sleep(0.1)  # Small delay to avoid rate limits


    def follow_list(
        self, id: Any, body: Optional[FollowListRequest] = None
    ) -> FollowListResponse:
        """
        Follow List
        Causes the authenticated user to follow a specific List by its ID.
        Args:
            id: The ID of the authenticated source User that will follow the List.
            body: Request body
        Returns:
            FollowListResponse: Response data
        """
        url = self.client.base_url + "/2/users/{id}/followed_lists"
        url = url.replace("{id}", str(id))
        # OAuth2UserToken: Use access_token as bearer token (matches TypeScript behavior)
        # Priority: access_token > oauth2_session (for token refresh support)
        if self.client.access_token:
            # Use access_token directly as bearer token (matches TypeScript)
            self.client.session.headers["Authorization"] = (
                f"Bearer {self.client.access_token}"
            )
            # If we have oauth2_auth, check if token needs refresh
            if self.client.oauth2_auth and self.client.token:
                if self.client.is_token_expired():
                    self.client.refresh_token()
                    # Update access_token after refresh
                    if self.client.access_token:
                        self.client.session.headers["Authorization"] = (
                            f"Bearer {self.client.access_token}"
                        )
        elif self.client.oauth2_auth and self.client.token:
            # Fallback: use oauth2_session if available (for backward compatibility)
            # Check if token needs refresh
            if self.client.is_token_expired():
                self.client.refresh_token()
        # UserToken: OAuth1.0a authentication - header will be built dynamically in request
        # OAuth1 header must be built per-request with method, URL, and body
        # This is handled in the request logic below
        params = {}
        headers = {}
        headers["Content-Type"] = "application/json"
        # Prepare request data
        json_data = None
        if body is not None:
            json_data = (
                body.model_dump(exclude_none=True)
                if hasattr(body, "model_dump")
                else body
            )
        # Select authentication method based on endpoint requirements and available credentials
        # Priority strategy (matches TypeScript):
        # 1. If endpoint only accepts one method, use that (if available)
        # 2. If endpoint accepts multiple methods:
        #    - For write operations (POST/PUT/DELETE/PATCH): Prefer OAuth1 > OAuth2 User Token > Bearer Token
        #    - For read operations (GET): Prefer Bearer Token > OAuth2 User Token > OAuth1
        # 3. If no security requirements: Bearer Token > OAuth2 User Token > OAuth1
        selected_auth = None
        # Check what auth methods we have available
        available_bearer = bool(self.client.bearer_token)
        available_oauth2 = bool(self.client.access_token)
        available_oauth1 = bool(self.client.auth and self.client.auth.access_token)
        # Count acceptable schemes
        acceptable_schemes = []
        acceptable_schemes.append("OAuth2UserToken")
        acceptable_schemes.append("UserToken")
        # If only one scheme is acceptable, use it if available
        if len(acceptable_schemes) == 1:
            scheme = acceptable_schemes[0]
            if scheme == "BearerToken" and available_bearer:
                selected_auth = "bearer_token"
            elif scheme == "OAuth2UserToken" and available_oauth2:
                selected_auth = "oauth2_user_context"
            elif scheme == "UserToken" and available_oauth1:
                selected_auth = "oauth1"
        # Multiple schemes acceptable - use priority based on operation type
        elif len(acceptable_schemes) > 1:
            is_write_operation = "post" in ["POST", "PUT", "DELETE", "PATCH"]
            if is_write_operation:
                # Priority for write operations: OAuth1 > OAuth2 User Token > Bearer Token
                if "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
            else:
                # Priority for read operations: Bearer Token > OAuth2 User Token > OAuth1
                if "BearerToken" in acceptable_schemes and available_bearer:
                    selected_auth = "bearer_token"
                elif "OAuth2UserToken" in acceptable_schemes and available_oauth2:
                    selected_auth = "oauth2_user_context"
                elif "UserToken" in acceptable_schemes and available_oauth1:
                    selected_auth = "oauth1"
        # Apply selected authentication
        if selected_auth == "oauth1":
            # OAuth1 authentication - build proper OAuth1 header dynamically
            # Build OAuth1 header with method, URL, and body
            # For OAuth1, we need to include query params in the URL for signature
            full_url = url
            if params:
                query_string = urllib.parse.urlencode(params)
                full_url = f"{url}?{query_string}" if query_string else url
            # Prepare body for OAuth1 signature (form-encoded, not JSON)
            body_string = ""
            if json_data:
                # OAuth1 spec: JSON bodies are NOT included in signature
                # But we still need to pass the body for the request
                body_string = ""
            # Build OAuth1 authorization header
            oauth_header = self.client.auth.build_request_header(
                method="post", url=full_url, body=body_string
            )
            headers["Authorization"] = oauth_header
        elif selected_auth == "bearer_token":
            # Bearer token authentication
            if self.client.bearer_token:
                headers["Authorization"] = f"Bearer {self.client.bearer_token}"
            elif self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
        elif selected_auth == "oauth2_user_context":
            # OAuth2 User Token authentication
            if self.client.access_token:
                headers["Authorization"] = f"Bearer {self.client.access_token}"
                # Check if token needs refresh
                if self.client.oauth2_auth and self.client.token:
                    if self.client.is_token_expired():
                        self.client.refresh_token()
                        if self.client.access_token:
                            headers["Authorization"] = (
                                f"Bearer {self.client.access_token}"
                            )
        # Make the request
        if not selected_auth:
            # No suitable auth method found - validate authentication
            required_schemes = (
                acceptable_schemes if "acceptable_schemes" in locals() else []
            )
            if required_schemes:
                available = []
                if available_bearer and "BearerToken" in required_schemes:
                    available.append("BearerToken")
                if available_oauth2 and "OAuth2UserToken" in required_schemes:
                    available.append("OAuth2UserToken")
                if available_oauth1 and "UserToken" in required_schemes:
                    available.append("UserToken")
                if not available:
                    raise ValueError(
                        f"Authentication required for this endpoint. Required schemes: {required_schemes}. Available: {[s for s in required_schemes if (s == 'BearerToken' and available_bearer) or (s == 'OAuth2UserToken' and available_oauth2) or (s == 'UserToken' and available_oauth1)]}"
                    )
        response = self.client.session.post(
            url,
            params=params,
            headers=headers,
            json=json_data,
        )
        # Check for errors
        response.raise_for_status()
        # Parse the response data
        response_data = response.json()
        # Convert to Pydantic model if applicable
        return FollowListResponse.model_validate(response_data)
