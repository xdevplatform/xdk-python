# AUTO-GENERATED FILE - DO NOT EDIT
# This file was automatically generated by the XDK build tool.
# Any manual changes will be overwritten on the next generation.
"""
Auto-generated generic tests for {"class_name": "Users", "display_name": "users", "import_name": "users", "original": ["users"], "property_name": "users"} client.

This module contains general tests that validate the overall client
functionality, imports, error handling, and common behavior patterns
that apply across all operations without being operation-specific.

Generated automatically - do not edit manually.
"""

import pytest
import inspect
from unittest.mock import Mock, patch
from xdk.users.client import UsersClient
from xdk import Client


class TestUsersGeneric:
    """Generic tests for UsersClient."""


    def setup_class(self):
        """Set up test fixtures."""
        self.client = Client(base_url="https://api.example.com")
        self.users_client = getattr(self.client, "users")


    def test_client_exists(self):
        """Test that UsersClient class exists and is importable."""
        assert UsersClient is not None
        assert hasattr(UsersClient, "__name__")
        assert UsersClient.__name__ == "UsersClient"


    def test_client_initialization(self):
        """Test that UsersClient can be initialized properly."""
        assert self.users_client is not None
        assert isinstance(self.users_client, UsersClient)


    def test_imports_work(self):
        """Test that all expected imports work correctly."""
        expected_imports = ["typing", "requests", "pydantic"]
        for import_name in expected_imports:
            try:
                __import__(import_name)
            except ImportError as e:
                pytest.fail(f"Expected import '{import_name}' failed: {e}")


    def test_error_responses_handling(self):
        """Test that error responses are handled correctly across all methods."""
        with patch.object(self.client, "session") as mock_session:
            # Test 404 response
            mock_response = Mock()
            mock_response.status_code = 404
            mock_response.raise_for_status.side_effect = Exception("Not Found")
            mock_session.get.return_value = mock_response
            mock_session.post.return_value = mock_response
            mock_session.put.return_value = mock_response
            mock_session.delete.return_value = mock_response
            # Get first available method for testing error handling
            client_methods = [
                name
                for name in dir(UsersClient)
                if not name.startswith("_") and callable(getattr(UsersClient, name))
            ]
            if client_methods:
                method_name = client_methods[0]
                method = getattr(self.users_client, method_name)
                # Try calling the method and expect an exception
                # For generator methods (paginated), we need to iterate to trigger the exception
                import types
                with pytest.raises(Exception):
                    try:
                        # Try with no args first
                        result = method()
                        # Check if it's a generator (paginated method)
                        if isinstance(result, types.GeneratorType):
                            # For generators, exception is raised when iterating
                            next(result)
                        # If not a generator, the exception should have been raised above
                    except TypeError:
                        # If it needs args, try with basic test args
                        try:
                            result = method("test_id")
                            if isinstance(result, types.GeneratorType):
                                next(result)
                        except TypeError:
                            # If it needs more specific args, try with kwargs
                            result = method(id="test_id", query="test")
                            if isinstance(result, types.GeneratorType):
                                next(result)


    def test_client_has_expected_base_functionality(self):
        """Test that the client has expected base functionality."""
        # Should be able to access the client through main Client
        assert hasattr(self.client, "users")
        # Client should have standard Python object features
        assert hasattr(self.users_client, "__class__")
        assert hasattr(self.users_client, "__dict__")
        # Should have at least one public method
        public_methods = [
            name
            for name in dir(self.users_client)
            if not name.startswith("_") and callable(getattr(self.users_client, name))
        ]
        assert (
            len(public_methods) > 0
        ), f"UsersClient should have at least one public method"


    def test_client_method_signatures_are_valid(self):
        """Test that all client methods have valid Python signatures."""
        public_methods = [
            name
            for name in dir(UsersClient)
            if not name.startswith("_") and callable(getattr(UsersClient, name))
        ]
        for method_name in public_methods:
            method = getattr(UsersClient, method_name)
            # Should be able to get signature without error
            try:
                sig = inspect.signature(method)
                params = list(sig.parameters.keys())
                # Should have 'self' as first parameter (if it's an instance method)
                if params:
                    assert (
                        params[0] == "self"
                    ), f"Method {method_name} should have 'self' as first parameter"
            except (ValueError, TypeError) as e:
                pytest.fail(f"Method {method_name} has invalid signature: {e}")
