# AUTO-GENERATED FILE - DO NOT EDIT
# This file was automatically generated by the XDK build tool.
# Any manual changes will be overwritten on the next generation.
"""
Auto-generated contract tests for {"class_name": "Media", "display_name": "media", "import_name": "media", "original": ["media"], "property_name": "media"} client.

This module contains tests that validate the request/response contracts
of the {"class_name": "Media", "display_name": "media", "import_name": "media", "original": ["media"], "property_name": "media"} client against the OpenAPI specification.

Generated automatically - do not edit manually.
"""

import pytest
import json
import requests
from unittest.mock import Mock, patch
from xdk.media.client import MediaClient
from xdk import Client


class TestMediaContracts:
    """Test the API contracts of MediaClient."""


    def setup_class(self):
        """Set up test fixtures."""
        self.client = Client(base_url="https://api.example.com")
        self.media_client = getattr(self.client, "media")


    def test_finalize_upload_request_structure(self):
        """Test finalize_upload request structure."""
        # Mock the session to capture request details
        with patch.object(self.client, "session") as mock_session:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {
                "data": None,
            }
            mock_response.raise_for_status.return_value = None
            mock_session.post.return_value = mock_response
            # Prepare test parameters
            kwargs = {}
            # Add required parameters
            kwargs["id"] = "test_value"
            # Add request body if required
            # Call the method
            try:
                method = getattr(self.media_client, "finalize_upload")
                # Check if this might be a streaming operation by inspecting return type
                import types
                import inspect
                sig = inspect.signature(method)
                return_annotation = str(sig.return_annotation)
                might_be_streaming = (
                    "Generator" in return_annotation or "Iterator" in return_annotation
                )
                # Set up streaming mock if it might be streaming (before calling method)
                if might_be_streaming:
                    mock_streaming_response = Mock()
                    mock_streaming_response.status_code = 200
                    mock_streaming_response.raise_for_status.return_value = None
                    # Make it a proper context manager
                    mock_streaming_response.__enter__ = Mock(
                        return_value=mock_streaming_response
                    )
                    mock_streaming_response.__exit__ = Mock(return_value=None)
                    # Set up iter_content to return an iterator that yields test data
                    # iter_content with decode_unicode=True returns strings, not bytes
                    test_data = '{"data": "test"}\n'
                    # iter_content is called as a method, so we need to make it return an iterator
                    mock_streaming_response.iter_content = Mock(
                        side_effect=lambda *args, **kwargs: iter([test_data])
                    )
                    # Make session.get return the context manager
                    mock_session.post.return_value = mock_streaming_response
                result = method(**kwargs)
                # Check if this is actually a streaming operation (returns Generator)
                is_streaming = isinstance(result, types.GeneratorType)
                if is_streaming:
                    # Consume the generator to trigger the HTTP request
                    # The HTTP request happens when entering the 'with' block inside the generator
                    # We need to actually iterate to trigger the request
                    try:
                        # Try to get first item - this will trigger the HTTP request
                        # The 'with' statement inside the generator will call session.get()
                        next(result)
                    except StopIteration:
                        # Generator exhausted immediately - request was still made
                        pass
                    except (
                        requests.exceptions.RequestException,
                        json.JSONDecodeError,
                        AttributeError,
                        ValueError,
                    ) as e:
                        # These exceptions can occur during streaming (request errors, JSON parsing, etc.)
                        # The request should still have been attempted
                        pass
                    # Don't catch other exceptions - if there's an error during setup (before the request),
                    # we want to know about it, and the request verification below will fail appropriately
                # Verify the request was made
                # For streaming operations, the request happens when entering the 'with' block
                # which occurs when we call next() on the generator
                mock_session.post.assert_called_once()
                # Verify request structure
                call_args = mock_session.post.call_args
                # Check URL structure
                called_url = (
                    call_args[0][0] if call_args[0] else call_args[1].get("url", "")
                )
                expected_path = "/2/media/upload/{id}/finalize"
                assert expected_path.replace("{", "").replace(
                    "}", ""
                ) in called_url or any(
                    param in called_url for param in ["test_", "42"]
                ), f"URL should contain path template elements: {called_url}"
                # Verify response structure
                if is_streaming:
                    # For streaming, verify we got a generator
                    assert isinstance(
                        result, types.GeneratorType
                    ), "Streaming method should return a generator"
                else:
                    # For regular operations, verify we got a result
                    assert result is not None, "Method should return a result"
            except Exception as e:
                pytest.fail(f"Contract test failed for finalize_upload: {e}")


    def test_finalize_upload_required_parameters(self):
        """Test that finalize_upload handles parameters correctly."""
        method = getattr(self.media_client, "finalize_upload")
        # Test with missing required parameters - mock the request to avoid network calls
        with patch.object(self.client, "session") as mock_session:
            # Mock a 400 response (typical for missing required parameters)
            mock_response = Mock()
            mock_response.status_code = 400
            mock_response.json.return_value = {"error": "Missing required parameters"}
            mock_response.raise_for_status.side_effect = Exception("Bad Request")
            mock_session.post.return_value = mock_response
            # Call without required parameters should either raise locally or via server response
            # For generator methods (paginated), we need to iterate to trigger the exception
            import types
            with pytest.raises((TypeError, ValueError, Exception)):
                result = method()
                # Check if it's a generator (paginated method)
                if isinstance(result, types.GeneratorType):
                    # For generators, exception is raised when iterating
                    next(result)


    def test_finalize_upload_response_structure(self):
        """Test finalize_upload response structure validation."""
        with patch.object(self.client, "session") as mock_session:
            # Create mock response with expected structure
            mock_response_data = {
                "data": None,
            }
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = mock_response_data
            mock_response.raise_for_status.return_value = None
            mock_session.post.return_value = mock_response
            # Prepare minimal valid parameters
            kwargs = {}
            kwargs["id"] = "test"
            # Add request body if required
            # Call method and verify response structure
            method = getattr(self.media_client, "finalize_upload")
            result = method(**kwargs)
            # Verify response object has expected attributes
            # Optional field - just check it doesn't cause errors if accessed
            try:
                getattr(result, "data", None)
            except Exception as e:
                pytest.fail(
                    f"Accessing optional field 'data' should not cause errors: {e}"
                )


    def test_initialize_upload_request_structure(self):
        """Test initialize_upload request structure."""
        # Mock the session to capture request details
        with patch.object(self.client, "session") as mock_session:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {
                "data": None,
            }
            mock_response.raise_for_status.return_value = None
            mock_session.post.return_value = mock_response
            # Prepare test parameters
            kwargs = {}
            # Add required parameters
            # Add request body if required
            # Import and create proper request model instance
            from xdk.media.models import InitializeUploadRequest
            # Create instance with minimal valid data (empty instance should work for most cases)
            kwargs["body"] = InitializeUploadRequest()
            # Call the method
            try:
                method = getattr(self.media_client, "initialize_upload")
                # Check if this might be a streaming operation by inspecting return type
                import types
                import inspect
                sig = inspect.signature(method)
                return_annotation = str(sig.return_annotation)
                might_be_streaming = (
                    "Generator" in return_annotation or "Iterator" in return_annotation
                )
                # Set up streaming mock if it might be streaming (before calling method)
                if might_be_streaming:
                    mock_streaming_response = Mock()
                    mock_streaming_response.status_code = 200
                    mock_streaming_response.raise_for_status.return_value = None
                    # Make it a proper context manager
                    mock_streaming_response.__enter__ = Mock(
                        return_value=mock_streaming_response
                    )
                    mock_streaming_response.__exit__ = Mock(return_value=None)
                    # Set up iter_content to return an iterator that yields test data
                    # iter_content with decode_unicode=True returns strings, not bytes
                    test_data = '{"data": "test"}\n'
                    # iter_content is called as a method, so we need to make it return an iterator
                    mock_streaming_response.iter_content = Mock(
                        side_effect=lambda *args, **kwargs: iter([test_data])
                    )
                    # Make session.get return the context manager
                    mock_session.post.return_value = mock_streaming_response
                result = method(**kwargs)
                # Check if this is actually a streaming operation (returns Generator)
                is_streaming = isinstance(result, types.GeneratorType)
                if is_streaming:
                    # Consume the generator to trigger the HTTP request
                    # The HTTP request happens when entering the 'with' block inside the generator
                    # We need to actually iterate to trigger the request
                    try:
                        # Try to get first item - this will trigger the HTTP request
                        # The 'with' statement inside the generator will call session.get()
                        next(result)
                    except StopIteration:
                        # Generator exhausted immediately - request was still made
                        pass
                    except (
                        requests.exceptions.RequestException,
                        json.JSONDecodeError,
                        AttributeError,
                        ValueError,
                    ) as e:
                        # These exceptions can occur during streaming (request errors, JSON parsing, etc.)
                        # The request should still have been attempted
                        pass
                    # Don't catch other exceptions - if there's an error during setup (before the request),
                    # we want to know about it, and the request verification below will fail appropriately
                # Verify the request was made
                # For streaming operations, the request happens when entering the 'with' block
                # which occurs when we call next() on the generator
                mock_session.post.assert_called_once()
                # Verify request structure
                call_args = mock_session.post.call_args
                # Check URL structure
                called_url = (
                    call_args[0][0] if call_args[0] else call_args[1].get("url", "")
                )
                expected_path = "/2/media/upload/initialize"
                assert expected_path.replace("{", "").replace(
                    "}", ""
                ) in called_url or any(
                    param in called_url for param in ["test_", "42"]
                ), f"URL should contain path template elements: {called_url}"
                # Verify response structure
                if is_streaming:
                    # For streaming, verify we got a generator
                    assert isinstance(
                        result, types.GeneratorType
                    ), "Streaming method should return a generator"
                else:
                    # For regular operations, verify we got a result
                    assert result is not None, "Method should return a result"
            except Exception as e:
                pytest.fail(f"Contract test failed for initialize_upload: {e}")


    def test_initialize_upload_required_parameters(self):
        """Test that initialize_upload handles parameters correctly."""
        method = getattr(self.media_client, "initialize_upload")
        # Test with missing required parameters - mock the request to avoid network calls
        with patch.object(self.client, "session") as mock_session:
            # Mock a 400 response (typical for missing required parameters)
            mock_response = Mock()
            mock_response.status_code = 400
            mock_response.json.return_value = {"error": "Missing required parameters"}
            mock_response.raise_for_status.side_effect = Exception("Bad Request")
            mock_session.post.return_value = mock_response
            # Call without required parameters should either raise locally or via server response
            # For generator methods (paginated), we need to iterate to trigger the exception
            import types
            with pytest.raises((TypeError, ValueError, Exception)):
                result = method()
                # Check if it's a generator (paginated method)
                if isinstance(result, types.GeneratorType):
                    # For generators, exception is raised when iterating
                    next(result)


    def test_initialize_upload_response_structure(self):
        """Test initialize_upload response structure validation."""
        with patch.object(self.client, "session") as mock_session:
            # Create mock response with expected structure
            mock_response_data = {
                "data": None,
            }
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = mock_response_data
            mock_response.raise_for_status.return_value = None
            mock_session.post.return_value = mock_response
            # Prepare minimal valid parameters
            kwargs = {}
            # Add request body if required
            # Import and create proper request model instance
            from xdk.media.models import InitializeUploadRequest
            # Create instance with minimal valid data (empty instance should work for most cases)
            kwargs["body"] = InitializeUploadRequest()
            # Call method and verify response structure
            method = getattr(self.media_client, "initialize_upload")
            result = method(**kwargs)
            # Verify response object has expected attributes
            # Optional field - just check it doesn't cause errors if accessed
            try:
                getattr(result, "data", None)
            except Exception as e:
                pytest.fail(
                    f"Accessing optional field 'data' should not cause errors: {e}"
                )


    def test_get_by_keys_request_structure(self):
        """Test get_by_keys request structure."""
        # Mock the session to capture request details
        with patch.object(self.client, "session") as mock_session:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {
                "data": None,
            }
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare test parameters
            kwargs = {}
            # Add required parameters
            kwargs["media_keys"] = ["test_item"]
            # Add request body if required
            # Call the method
            try:
                method = getattr(self.media_client, "get_by_keys")
                # Check if this might be a streaming operation by inspecting return type
                import types
                import inspect
                sig = inspect.signature(method)
                return_annotation = str(sig.return_annotation)
                might_be_streaming = (
                    "Generator" in return_annotation or "Iterator" in return_annotation
                )
                # Set up streaming mock if it might be streaming (before calling method)
                if might_be_streaming:
                    mock_streaming_response = Mock()
                    mock_streaming_response.status_code = 200
                    mock_streaming_response.raise_for_status.return_value = None
                    # Make it a proper context manager
                    mock_streaming_response.__enter__ = Mock(
                        return_value=mock_streaming_response
                    )
                    mock_streaming_response.__exit__ = Mock(return_value=None)
                    # Set up iter_content to return an iterator that yields test data
                    # iter_content with decode_unicode=True returns strings, not bytes
                    test_data = '{"data": "test"}\n'
                    # iter_content is called as a method, so we need to make it return an iterator
                    mock_streaming_response.iter_content = Mock(
                        side_effect=lambda *args, **kwargs: iter([test_data])
                    )
                    # Make session.get return the context manager
                    mock_session.get.return_value = mock_streaming_response
                result = method(**kwargs)
                # Check if this is actually a streaming operation (returns Generator)
                is_streaming = isinstance(result, types.GeneratorType)
                if is_streaming:
                    # Consume the generator to trigger the HTTP request
                    # The HTTP request happens when entering the 'with' block inside the generator
                    # We need to actually iterate to trigger the request
                    try:
                        # Try to get first item - this will trigger the HTTP request
                        # The 'with' statement inside the generator will call session.get()
                        next(result)
                    except StopIteration:
                        # Generator exhausted immediately - request was still made
                        pass
                    except (
                        requests.exceptions.RequestException,
                        json.JSONDecodeError,
                        AttributeError,
                        ValueError,
                    ) as e:
                        # These exceptions can occur during streaming (request errors, JSON parsing, etc.)
                        # The request should still have been attempted
                        pass
                    # Don't catch other exceptions - if there's an error during setup (before the request),
                    # we want to know about it, and the request verification below will fail appropriately
                # Verify the request was made
                # For streaming operations, the request happens when entering the 'with' block
                # which occurs when we call next() on the generator
                mock_session.get.assert_called_once()
                # Verify request structure
                call_args = mock_session.get.call_args
                # Check URL structure
                called_url = (
                    call_args[0][0] if call_args[0] else call_args[1].get("url", "")
                )
                expected_path = "/2/media"
                assert expected_path.replace("{", "").replace(
                    "}", ""
                ) in called_url or any(
                    param in called_url for param in ["test_", "42"]
                ), f"URL should contain path template elements: {called_url}"
                # Verify response structure
                if is_streaming:
                    # For streaming, verify we got a generator
                    assert isinstance(
                        result, types.GeneratorType
                    ), "Streaming method should return a generator"
                else:
                    # For regular operations, verify we got a result
                    assert result is not None, "Method should return a result"
            except Exception as e:
                pytest.fail(f"Contract test failed for get_by_keys: {e}")


    def test_get_by_keys_required_parameters(self):
        """Test that get_by_keys handles parameters correctly."""
        method = getattr(self.media_client, "get_by_keys")
        # Test with missing required parameters - mock the request to avoid network calls
        with patch.object(self.client, "session") as mock_session:
            # Mock a 400 response (typical for missing required parameters)
            mock_response = Mock()
            mock_response.status_code = 400
            mock_response.json.return_value = {"error": "Missing required parameters"}
            mock_response.raise_for_status.side_effect = Exception("Bad Request")
            mock_session.get.return_value = mock_response
            # Call without required parameters should either raise locally or via server response
            # For generator methods (paginated), we need to iterate to trigger the exception
            import types
            with pytest.raises((TypeError, ValueError, Exception)):
                result = method()
                # Check if it's a generator (paginated method)
                if isinstance(result, types.GeneratorType):
                    # For generators, exception is raised when iterating
                    next(result)


    def test_get_by_keys_response_structure(self):
        """Test get_by_keys response structure validation."""
        with patch.object(self.client, "session") as mock_session:
            # Create mock response with expected structure
            mock_response_data = {
                "data": None,
            }
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = mock_response_data
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare minimal valid parameters
            kwargs = {}
            kwargs["media_keys"] = ["test"]
            # Add request body if required
            # Call method and verify response structure
            method = getattr(self.media_client, "get_by_keys")
            result = method(**kwargs)
            # Verify response object has expected attributes
            # Optional field - just check it doesn't cause errors if accessed
            try:
                getattr(result, "data", None)
            except Exception as e:
                pytest.fail(
                    f"Accessing optional field 'data' should not cause errors: {e}"
                )


    def test_get_upload_status_request_structure(self):
        """Test get_upload_status request structure."""
        # Mock the session to capture request details
        with patch.object(self.client, "session") as mock_session:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {
                "data": None,
            }
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare test parameters
            kwargs = {}
            # Add required parameters
            kwargs["media_id"] = "test_value"
            # Add request body if required
            # Call the method
            try:
                method = getattr(self.media_client, "get_upload_status")
                # Check if this might be a streaming operation by inspecting return type
                import types
                import inspect
                sig = inspect.signature(method)
                return_annotation = str(sig.return_annotation)
                might_be_streaming = (
                    "Generator" in return_annotation or "Iterator" in return_annotation
                )
                # Set up streaming mock if it might be streaming (before calling method)
                if might_be_streaming:
                    mock_streaming_response = Mock()
                    mock_streaming_response.status_code = 200
                    mock_streaming_response.raise_for_status.return_value = None
                    # Make it a proper context manager
                    mock_streaming_response.__enter__ = Mock(
                        return_value=mock_streaming_response
                    )
                    mock_streaming_response.__exit__ = Mock(return_value=None)
                    # Set up iter_content to return an iterator that yields test data
                    # iter_content with decode_unicode=True returns strings, not bytes
                    test_data = '{"data": "test"}\n'
                    # iter_content is called as a method, so we need to make it return an iterator
                    mock_streaming_response.iter_content = Mock(
                        side_effect=lambda *args, **kwargs: iter([test_data])
                    )
                    # Make session.get return the context manager
                    mock_session.get.return_value = mock_streaming_response
                result = method(**kwargs)
                # Check if this is actually a streaming operation (returns Generator)
                is_streaming = isinstance(result, types.GeneratorType)
                if is_streaming:
                    # Consume the generator to trigger the HTTP request
                    # The HTTP request happens when entering the 'with' block inside the generator
                    # We need to actually iterate to trigger the request
                    try:
                        # Try to get first item - this will trigger the HTTP request
                        # The 'with' statement inside the generator will call session.get()
                        next(result)
                    except StopIteration:
                        # Generator exhausted immediately - request was still made
                        pass
                    except (
                        requests.exceptions.RequestException,
                        json.JSONDecodeError,
                        AttributeError,
                        ValueError,
                    ) as e:
                        # These exceptions can occur during streaming (request errors, JSON parsing, etc.)
                        # The request should still have been attempted
                        pass
                    # Don't catch other exceptions - if there's an error during setup (before the request),
                    # we want to know about it, and the request verification below will fail appropriately
                # Verify the request was made
                # For streaming operations, the request happens when entering the 'with' block
                # which occurs when we call next() on the generator
                mock_session.get.assert_called_once()
                # Verify request structure
                call_args = mock_session.get.call_args
                # Check URL structure
                called_url = (
                    call_args[0][0] if call_args[0] else call_args[1].get("url", "")
                )
                expected_path = "/2/media/upload"
                assert expected_path.replace("{", "").replace(
                    "}", ""
                ) in called_url or any(
                    param in called_url for param in ["test_", "42"]
                ), f"URL should contain path template elements: {called_url}"
                # Verify response structure
                if is_streaming:
                    # For streaming, verify we got a generator
                    assert isinstance(
                        result, types.GeneratorType
                    ), "Streaming method should return a generator"
                else:
                    # For regular operations, verify we got a result
                    assert result is not None, "Method should return a result"
            except Exception as e:
                pytest.fail(f"Contract test failed for get_upload_status: {e}")


    def test_get_upload_status_required_parameters(self):
        """Test that get_upload_status handles parameters correctly."""
        method = getattr(self.media_client, "get_upload_status")
        # Test with missing required parameters - mock the request to avoid network calls
        with patch.object(self.client, "session") as mock_session:
            # Mock a 400 response (typical for missing required parameters)
            mock_response = Mock()
            mock_response.status_code = 400
            mock_response.json.return_value = {"error": "Missing required parameters"}
            mock_response.raise_for_status.side_effect = Exception("Bad Request")
            mock_session.get.return_value = mock_response
            # Call without required parameters should either raise locally or via server response
            # For generator methods (paginated), we need to iterate to trigger the exception
            import types
            with pytest.raises((TypeError, ValueError, Exception)):
                result = method()
                # Check if it's a generator (paginated method)
                if isinstance(result, types.GeneratorType):
                    # For generators, exception is raised when iterating
                    next(result)


    def test_get_upload_status_response_structure(self):
        """Test get_upload_status response structure validation."""
        with patch.object(self.client, "session") as mock_session:
            # Create mock response with expected structure
            mock_response_data = {
                "data": None,
            }
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = mock_response_data
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare minimal valid parameters
            kwargs = {}
            kwargs["media_id"] = "test"
            # Add request body if required
            # Call method and verify response structure
            method = getattr(self.media_client, "get_upload_status")
            result = method(**kwargs)
            # Verify response object has expected attributes
            # Optional field - just check it doesn't cause errors if accessed
            try:
                getattr(result, "data", None)
            except Exception as e:
                pytest.fail(
                    f"Accessing optional field 'data' should not cause errors: {e}"
                )


    def test_upload_request_structure(self):
        """Test upload request structure."""
        # Mock the session to capture request details
        with patch.object(self.client, "session") as mock_session:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {
                "data": None,
            }
            mock_response.raise_for_status.return_value = None
            mock_session.post.return_value = mock_response
            # Prepare test parameters
            kwargs = {}
            # Add required parameters
            # Add request body if required
            # Import and create proper request model instance
            from xdk.media.models import UploadRequest
            # Create instance with minimal valid data (empty instance should work for most cases)
            kwargs["body"] = UploadRequest()
            # Call the method
            try:
                method = getattr(self.media_client, "upload")
                # Check if this might be a streaming operation by inspecting return type
                import types
                import inspect
                sig = inspect.signature(method)
                return_annotation = str(sig.return_annotation)
                might_be_streaming = (
                    "Generator" in return_annotation or "Iterator" in return_annotation
                )
                # Set up streaming mock if it might be streaming (before calling method)
                if might_be_streaming:
                    mock_streaming_response = Mock()
                    mock_streaming_response.status_code = 200
                    mock_streaming_response.raise_for_status.return_value = None
                    # Make it a proper context manager
                    mock_streaming_response.__enter__ = Mock(
                        return_value=mock_streaming_response
                    )
                    mock_streaming_response.__exit__ = Mock(return_value=None)
                    # Set up iter_content to return an iterator that yields test data
                    # iter_content with decode_unicode=True returns strings, not bytes
                    test_data = '{"data": "test"}\n'
                    # iter_content is called as a method, so we need to make it return an iterator
                    mock_streaming_response.iter_content = Mock(
                        side_effect=lambda *args, **kwargs: iter([test_data])
                    )
                    # Make session.get return the context manager
                    mock_session.post.return_value = mock_streaming_response
                result = method(**kwargs)
                # Check if this is actually a streaming operation (returns Generator)
                is_streaming = isinstance(result, types.GeneratorType)
                if is_streaming:
                    # Consume the generator to trigger the HTTP request
                    # The HTTP request happens when entering the 'with' block inside the generator
                    # We need to actually iterate to trigger the request
                    try:
                        # Try to get first item - this will trigger the HTTP request
                        # The 'with' statement inside the generator will call session.get()
                        next(result)
                    except StopIteration:
                        # Generator exhausted immediately - request was still made
                        pass
                    except (
                        requests.exceptions.RequestException,
                        json.JSONDecodeError,
                        AttributeError,
                        ValueError,
                    ) as e:
                        # These exceptions can occur during streaming (request errors, JSON parsing, etc.)
                        # The request should still have been attempted
                        pass
                    # Don't catch other exceptions - if there's an error during setup (before the request),
                    # we want to know about it, and the request verification below will fail appropriately
                # Verify the request was made
                # For streaming operations, the request happens when entering the 'with' block
                # which occurs when we call next() on the generator
                mock_session.post.assert_called_once()
                # Verify request structure
                call_args = mock_session.post.call_args
                # Check URL structure
                called_url = (
                    call_args[0][0] if call_args[0] else call_args[1].get("url", "")
                )
                expected_path = "/2/media/upload"
                assert expected_path.replace("{", "").replace(
                    "}", ""
                ) in called_url or any(
                    param in called_url for param in ["test_", "42"]
                ), f"URL should contain path template elements: {called_url}"
                # Verify response structure
                if is_streaming:
                    # For streaming, verify we got a generator
                    assert isinstance(
                        result, types.GeneratorType
                    ), "Streaming method should return a generator"
                else:
                    # For regular operations, verify we got a result
                    assert result is not None, "Method should return a result"
            except Exception as e:
                pytest.fail(f"Contract test failed for upload: {e}")


    def test_upload_required_parameters(self):
        """Test that upload handles parameters correctly."""
        method = getattr(self.media_client, "upload")
        # Test with missing required parameters - mock the request to avoid network calls
        with patch.object(self.client, "session") as mock_session:
            # Mock a 400 response (typical for missing required parameters)
            mock_response = Mock()
            mock_response.status_code = 400
            mock_response.json.return_value = {"error": "Missing required parameters"}
            mock_response.raise_for_status.side_effect = Exception("Bad Request")
            mock_session.post.return_value = mock_response
            # Call without required parameters should either raise locally or via server response
            # For generator methods (paginated), we need to iterate to trigger the exception
            import types
            with pytest.raises((TypeError, ValueError, Exception)):
                result = method()
                # Check if it's a generator (paginated method)
                if isinstance(result, types.GeneratorType):
                    # For generators, exception is raised when iterating
                    next(result)


    def test_upload_response_structure(self):
        """Test upload response structure validation."""
        with patch.object(self.client, "session") as mock_session:
            # Create mock response with expected structure
            mock_response_data = {
                "data": None,
            }
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = mock_response_data
            mock_response.raise_for_status.return_value = None
            mock_session.post.return_value = mock_response
            # Prepare minimal valid parameters
            kwargs = {}
            # Add request body if required
            # Import and create proper request model instance
            from xdk.media.models import UploadRequest
            # Create instance with minimal valid data (empty instance should work for most cases)
            kwargs["body"] = UploadRequest()
            # Call method and verify response structure
            method = getattr(self.media_client, "upload")
            result = method(**kwargs)
            # Verify response object has expected attributes
            # Optional field - just check it doesn't cause errors if accessed
            try:
                getattr(result, "data", None)
            except Exception as e:
                pytest.fail(
                    f"Accessing optional field 'data' should not cause errors: {e}"
                )


    def test_create_subtitles_request_structure(self):
        """Test create_subtitles request structure."""
        # Mock the session to capture request details
        with patch.object(self.client, "session") as mock_session:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {
                "data": None,
            }
            mock_response.raise_for_status.return_value = None
            mock_session.post.return_value = mock_response
            # Prepare test parameters
            kwargs = {}
            # Add required parameters
            # Add request body if required
            # Import and create proper request model instance
            from xdk.media.models import CreateSubtitlesRequest
            # Create instance with minimal valid data (empty instance should work for most cases)
            kwargs["body"] = CreateSubtitlesRequest()
            # Call the method
            try:
                method = getattr(self.media_client, "create_subtitles")
                # Check if this might be a streaming operation by inspecting return type
                import types
                import inspect
                sig = inspect.signature(method)
                return_annotation = str(sig.return_annotation)
                might_be_streaming = (
                    "Generator" in return_annotation or "Iterator" in return_annotation
                )
                # Set up streaming mock if it might be streaming (before calling method)
                if might_be_streaming:
                    mock_streaming_response = Mock()
                    mock_streaming_response.status_code = 200
                    mock_streaming_response.raise_for_status.return_value = None
                    # Make it a proper context manager
                    mock_streaming_response.__enter__ = Mock(
                        return_value=mock_streaming_response
                    )
                    mock_streaming_response.__exit__ = Mock(return_value=None)
                    # Set up iter_content to return an iterator that yields test data
                    # iter_content with decode_unicode=True returns strings, not bytes
                    test_data = '{"data": "test"}\n'
                    # iter_content is called as a method, so we need to make it return an iterator
                    mock_streaming_response.iter_content = Mock(
                        side_effect=lambda *args, **kwargs: iter([test_data])
                    )
                    # Make session.get return the context manager
                    mock_session.post.return_value = mock_streaming_response
                result = method(**kwargs)
                # Check if this is actually a streaming operation (returns Generator)
                is_streaming = isinstance(result, types.GeneratorType)
                if is_streaming:
                    # Consume the generator to trigger the HTTP request
                    # The HTTP request happens when entering the 'with' block inside the generator
                    # We need to actually iterate to trigger the request
                    try:
                        # Try to get first item - this will trigger the HTTP request
                        # The 'with' statement inside the generator will call session.get()
                        next(result)
                    except StopIteration:
                        # Generator exhausted immediately - request was still made
                        pass
                    except (
                        requests.exceptions.RequestException,
                        json.JSONDecodeError,
                        AttributeError,
                        ValueError,
                    ) as e:
                        # These exceptions can occur during streaming (request errors, JSON parsing, etc.)
                        # The request should still have been attempted
                        pass
                    # Don't catch other exceptions - if there's an error during setup (before the request),
                    # we want to know about it, and the request verification below will fail appropriately
                # Verify the request was made
                # For streaming operations, the request happens when entering the 'with' block
                # which occurs when we call next() on the generator
                mock_session.post.assert_called_once()
                # Verify request structure
                call_args = mock_session.post.call_args
                # Check URL structure
                called_url = (
                    call_args[0][0] if call_args[0] else call_args[1].get("url", "")
                )
                expected_path = "/2/media/subtitles"
                assert expected_path.replace("{", "").replace(
                    "}", ""
                ) in called_url or any(
                    param in called_url for param in ["test_", "42"]
                ), f"URL should contain path template elements: {called_url}"
                # Verify response structure
                if is_streaming:
                    # For streaming, verify we got a generator
                    assert isinstance(
                        result, types.GeneratorType
                    ), "Streaming method should return a generator"
                else:
                    # For regular operations, verify we got a result
                    assert result is not None, "Method should return a result"
            except Exception as e:
                pytest.fail(f"Contract test failed for create_subtitles: {e}")


    def test_create_subtitles_required_parameters(self):
        """Test that create_subtitles handles parameters correctly."""
        method = getattr(self.media_client, "create_subtitles")
        # Test with missing required parameters - mock the request to avoid network calls
        with patch.object(self.client, "session") as mock_session:
            # Mock a 400 response (typical for missing required parameters)
            mock_response = Mock()
            mock_response.status_code = 400
            mock_response.json.return_value = {"error": "Missing required parameters"}
            mock_response.raise_for_status.side_effect = Exception("Bad Request")
            mock_session.post.return_value = mock_response
            # Call without required parameters should either raise locally or via server response
            # For generator methods (paginated), we need to iterate to trigger the exception
            import types
            with pytest.raises((TypeError, ValueError, Exception)):
                result = method()
                # Check if it's a generator (paginated method)
                if isinstance(result, types.GeneratorType):
                    # For generators, exception is raised when iterating
                    next(result)


    def test_create_subtitles_response_structure(self):
        """Test create_subtitles response structure validation."""
        with patch.object(self.client, "session") as mock_session:
            # Create mock response with expected structure
            mock_response_data = {
                "data": None,
            }
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = mock_response_data
            mock_response.raise_for_status.return_value = None
            mock_session.post.return_value = mock_response
            # Prepare minimal valid parameters
            kwargs = {}
            # Add request body if required
            # Import and create proper request model instance
            from xdk.media.models import CreateSubtitlesRequest
            # Create instance with minimal valid data (empty instance should work for most cases)
            kwargs["body"] = CreateSubtitlesRequest()
            # Call method and verify response structure
            method = getattr(self.media_client, "create_subtitles")
            result = method(**kwargs)
            # Verify response object has expected attributes
            # Optional field - just check it doesn't cause errors if accessed
            try:
                getattr(result, "data", None)
            except Exception as e:
                pytest.fail(
                    f"Accessing optional field 'data' should not cause errors: {e}"
                )


    def test_delete_subtitles_request_structure(self):
        """Test delete_subtitles request structure."""
        # Mock the session to capture request details
        with patch.object(self.client, "session") as mock_session:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {
                "data": None,
            }
            mock_response.raise_for_status.return_value = None
            mock_session.delete.return_value = mock_response
            # Prepare test parameters
            kwargs = {}
            # Add required parameters
            # Add request body if required
            # Import and create proper request model instance
            from xdk.media.models import DeleteSubtitlesRequest
            # Create instance with minimal valid data (empty instance should work for most cases)
            kwargs["body"] = DeleteSubtitlesRequest()
            # Call the method
            try:
                method = getattr(self.media_client, "delete_subtitles")
                # Check if this might be a streaming operation by inspecting return type
                import types
                import inspect
                sig = inspect.signature(method)
                return_annotation = str(sig.return_annotation)
                might_be_streaming = (
                    "Generator" in return_annotation or "Iterator" in return_annotation
                )
                # Set up streaming mock if it might be streaming (before calling method)
                if might_be_streaming:
                    mock_streaming_response = Mock()
                    mock_streaming_response.status_code = 200
                    mock_streaming_response.raise_for_status.return_value = None
                    # Make it a proper context manager
                    mock_streaming_response.__enter__ = Mock(
                        return_value=mock_streaming_response
                    )
                    mock_streaming_response.__exit__ = Mock(return_value=None)
                    # Set up iter_content to return an iterator that yields test data
                    # iter_content with decode_unicode=True returns strings, not bytes
                    test_data = '{"data": "test"}\n'
                    # iter_content is called as a method, so we need to make it return an iterator
                    mock_streaming_response.iter_content = Mock(
                        side_effect=lambda *args, **kwargs: iter([test_data])
                    )
                    # Make session.get return the context manager
                    mock_session.delete.return_value = mock_streaming_response
                result = method(**kwargs)
                # Check if this is actually a streaming operation (returns Generator)
                is_streaming = isinstance(result, types.GeneratorType)
                if is_streaming:
                    # Consume the generator to trigger the HTTP request
                    # The HTTP request happens when entering the 'with' block inside the generator
                    # We need to actually iterate to trigger the request
                    try:
                        # Try to get first item - this will trigger the HTTP request
                        # The 'with' statement inside the generator will call session.get()
                        next(result)
                    except StopIteration:
                        # Generator exhausted immediately - request was still made
                        pass
                    except (
                        requests.exceptions.RequestException,
                        json.JSONDecodeError,
                        AttributeError,
                        ValueError,
                    ) as e:
                        # These exceptions can occur during streaming (request errors, JSON parsing, etc.)
                        # The request should still have been attempted
                        pass
                    # Don't catch other exceptions - if there's an error during setup (before the request),
                    # we want to know about it, and the request verification below will fail appropriately
                # Verify the request was made
                # For streaming operations, the request happens when entering the 'with' block
                # which occurs when we call next() on the generator
                mock_session.delete.assert_called_once()
                # Verify request structure
                call_args = mock_session.delete.call_args
                # Check URL structure
                called_url = (
                    call_args[0][0] if call_args[0] else call_args[1].get("url", "")
                )
                expected_path = "/2/media/subtitles"
                assert expected_path.replace("{", "").replace(
                    "}", ""
                ) in called_url or any(
                    param in called_url for param in ["test_", "42"]
                ), f"URL should contain path template elements: {called_url}"
                # Verify response structure
                if is_streaming:
                    # For streaming, verify we got a generator
                    assert isinstance(
                        result, types.GeneratorType
                    ), "Streaming method should return a generator"
                else:
                    # For regular operations, verify we got a result
                    assert result is not None, "Method should return a result"
            except Exception as e:
                pytest.fail(f"Contract test failed for delete_subtitles: {e}")


    def test_delete_subtitles_required_parameters(self):
        """Test that delete_subtitles handles parameters correctly."""
        method = getattr(self.media_client, "delete_subtitles")
        # Test with missing required parameters - mock the request to avoid network calls
        with patch.object(self.client, "session") as mock_session:
            # Mock a 400 response (typical for missing required parameters)
            mock_response = Mock()
            mock_response.status_code = 400
            mock_response.json.return_value = {"error": "Missing required parameters"}
            mock_response.raise_for_status.side_effect = Exception("Bad Request")
            mock_session.delete.return_value = mock_response
            # Call without required parameters should either raise locally or via server response
            # For generator methods (paginated), we need to iterate to trigger the exception
            import types
            with pytest.raises((TypeError, ValueError, Exception)):
                result = method()
                # Check if it's a generator (paginated method)
                if isinstance(result, types.GeneratorType):
                    # For generators, exception is raised when iterating
                    next(result)


    def test_delete_subtitles_response_structure(self):
        """Test delete_subtitles response structure validation."""
        with patch.object(self.client, "session") as mock_session:
            # Create mock response with expected structure
            mock_response_data = {
                "data": None,
            }
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = mock_response_data
            mock_response.raise_for_status.return_value = None
            mock_session.delete.return_value = mock_response
            # Prepare minimal valid parameters
            kwargs = {}
            # Add request body if required
            # Import and create proper request model instance
            from xdk.media.models import DeleteSubtitlesRequest
            # Create instance with minimal valid data (empty instance should work for most cases)
            kwargs["body"] = DeleteSubtitlesRequest()
            # Call method and verify response structure
            method = getattr(self.media_client, "delete_subtitles")
            result = method(**kwargs)
            # Verify response object has expected attributes
            # Optional field - just check it doesn't cause errors if accessed
            try:
                getattr(result, "data", None)
            except Exception as e:
                pytest.fail(
                    f"Accessing optional field 'data' should not cause errors: {e}"
                )


    def test_get_by_key_request_structure(self):
        """Test get_by_key request structure."""
        # Mock the session to capture request details
        with patch.object(self.client, "session") as mock_session:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {
                "data": None,
            }
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare test parameters
            kwargs = {}
            # Add required parameters
            kwargs["media_key"] = "test_value"
            # Add request body if required
            # Call the method
            try:
                method = getattr(self.media_client, "get_by_key")
                # Check if this might be a streaming operation by inspecting return type
                import types
                import inspect
                sig = inspect.signature(method)
                return_annotation = str(sig.return_annotation)
                might_be_streaming = (
                    "Generator" in return_annotation or "Iterator" in return_annotation
                )
                # Set up streaming mock if it might be streaming (before calling method)
                if might_be_streaming:
                    mock_streaming_response = Mock()
                    mock_streaming_response.status_code = 200
                    mock_streaming_response.raise_for_status.return_value = None
                    # Make it a proper context manager
                    mock_streaming_response.__enter__ = Mock(
                        return_value=mock_streaming_response
                    )
                    mock_streaming_response.__exit__ = Mock(return_value=None)
                    # Set up iter_content to return an iterator that yields test data
                    # iter_content with decode_unicode=True returns strings, not bytes
                    test_data = '{"data": "test"}\n'
                    # iter_content is called as a method, so we need to make it return an iterator
                    mock_streaming_response.iter_content = Mock(
                        side_effect=lambda *args, **kwargs: iter([test_data])
                    )
                    # Make session.get return the context manager
                    mock_session.get.return_value = mock_streaming_response
                result = method(**kwargs)
                # Check if this is actually a streaming operation (returns Generator)
                is_streaming = isinstance(result, types.GeneratorType)
                if is_streaming:
                    # Consume the generator to trigger the HTTP request
                    # The HTTP request happens when entering the 'with' block inside the generator
                    # We need to actually iterate to trigger the request
                    try:
                        # Try to get first item - this will trigger the HTTP request
                        # The 'with' statement inside the generator will call session.get()
                        next(result)
                    except StopIteration:
                        # Generator exhausted immediately - request was still made
                        pass
                    except (
                        requests.exceptions.RequestException,
                        json.JSONDecodeError,
                        AttributeError,
                        ValueError,
                    ) as e:
                        # These exceptions can occur during streaming (request errors, JSON parsing, etc.)
                        # The request should still have been attempted
                        pass
                    # Don't catch other exceptions - if there's an error during setup (before the request),
                    # we want to know about it, and the request verification below will fail appropriately
                # Verify the request was made
                # For streaming operations, the request happens when entering the 'with' block
                # which occurs when we call next() on the generator
                mock_session.get.assert_called_once()
                # Verify request structure
                call_args = mock_session.get.call_args
                # Check URL structure
                called_url = (
                    call_args[0][0] if call_args[0] else call_args[1].get("url", "")
                )
                expected_path = "/2/media/{media_key}"
                assert expected_path.replace("{", "").replace(
                    "}", ""
                ) in called_url or any(
                    param in called_url for param in ["test_", "42"]
                ), f"URL should contain path template elements: {called_url}"
                # Verify response structure
                if is_streaming:
                    # For streaming, verify we got a generator
                    assert isinstance(
                        result, types.GeneratorType
                    ), "Streaming method should return a generator"
                else:
                    # For regular operations, verify we got a result
                    assert result is not None, "Method should return a result"
            except Exception as e:
                pytest.fail(f"Contract test failed for get_by_key: {e}")


    def test_get_by_key_required_parameters(self):
        """Test that get_by_key handles parameters correctly."""
        method = getattr(self.media_client, "get_by_key")
        # Test with missing required parameters - mock the request to avoid network calls
        with patch.object(self.client, "session") as mock_session:
            # Mock a 400 response (typical for missing required parameters)
            mock_response = Mock()
            mock_response.status_code = 400
            mock_response.json.return_value = {"error": "Missing required parameters"}
            mock_response.raise_for_status.side_effect = Exception("Bad Request")
            mock_session.get.return_value = mock_response
            # Call without required parameters should either raise locally or via server response
            # For generator methods (paginated), we need to iterate to trigger the exception
            import types
            with pytest.raises((TypeError, ValueError, Exception)):
                result = method()
                # Check if it's a generator (paginated method)
                if isinstance(result, types.GeneratorType):
                    # For generators, exception is raised when iterating
                    next(result)


    def test_get_by_key_response_structure(self):
        """Test get_by_key response structure validation."""
        with patch.object(self.client, "session") as mock_session:
            # Create mock response with expected structure
            mock_response_data = {
                "data": None,
            }
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = mock_response_data
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare minimal valid parameters
            kwargs = {}
            kwargs["media_key"] = "test"
            # Add request body if required
            # Call method and verify response structure
            method = getattr(self.media_client, "get_by_key")
            result = method(**kwargs)
            # Verify response object has expected attributes
            # Optional field - just check it doesn't cause errors if accessed
            try:
                getattr(result, "data", None)
            except Exception as e:
                pytest.fail(
                    f"Accessing optional field 'data' should not cause errors: {e}"
                )


    def test_append_upload_request_structure(self):
        """Test append_upload request structure."""
        # Mock the session to capture request details
        with patch.object(self.client, "session") as mock_session:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {
                "data": None,
            }
            mock_response.raise_for_status.return_value = None
            mock_session.post.return_value = mock_response
            # Prepare test parameters
            kwargs = {}
            # Add required parameters
            kwargs["id"] = "test_value"
            # Add request body if required
            # Import and create proper request model instance
            from xdk.media.models import AppendUploadRequest
            # Create instance with minimal valid data (empty instance should work for most cases)
            kwargs["body"] = AppendUploadRequest()
            # Call the method
            try:
                method = getattr(self.media_client, "append_upload")
                # Check if this might be a streaming operation by inspecting return type
                import types
                import inspect
                sig = inspect.signature(method)
                return_annotation = str(sig.return_annotation)
                might_be_streaming = (
                    "Generator" in return_annotation or "Iterator" in return_annotation
                )
                # Set up streaming mock if it might be streaming (before calling method)
                if might_be_streaming:
                    mock_streaming_response = Mock()
                    mock_streaming_response.status_code = 200
                    mock_streaming_response.raise_for_status.return_value = None
                    # Make it a proper context manager
                    mock_streaming_response.__enter__ = Mock(
                        return_value=mock_streaming_response
                    )
                    mock_streaming_response.__exit__ = Mock(return_value=None)
                    # Set up iter_content to return an iterator that yields test data
                    # iter_content with decode_unicode=True returns strings, not bytes
                    test_data = '{"data": "test"}\n'
                    # iter_content is called as a method, so we need to make it return an iterator
                    mock_streaming_response.iter_content = Mock(
                        side_effect=lambda *args, **kwargs: iter([test_data])
                    )
                    # Make session.get return the context manager
                    mock_session.post.return_value = mock_streaming_response
                result = method(**kwargs)
                # Check if this is actually a streaming operation (returns Generator)
                is_streaming = isinstance(result, types.GeneratorType)
                if is_streaming:
                    # Consume the generator to trigger the HTTP request
                    # The HTTP request happens when entering the 'with' block inside the generator
                    # We need to actually iterate to trigger the request
                    try:
                        # Try to get first item - this will trigger the HTTP request
                        # The 'with' statement inside the generator will call session.get()
                        next(result)
                    except StopIteration:
                        # Generator exhausted immediately - request was still made
                        pass
                    except (
                        requests.exceptions.RequestException,
                        json.JSONDecodeError,
                        AttributeError,
                        ValueError,
                    ) as e:
                        # These exceptions can occur during streaming (request errors, JSON parsing, etc.)
                        # The request should still have been attempted
                        pass
                    # Don't catch other exceptions - if there's an error during setup (before the request),
                    # we want to know about it, and the request verification below will fail appropriately
                # Verify the request was made
                # For streaming operations, the request happens when entering the 'with' block
                # which occurs when we call next() on the generator
                mock_session.post.assert_called_once()
                # Verify request structure
                call_args = mock_session.post.call_args
                # Check URL structure
                called_url = (
                    call_args[0][0] if call_args[0] else call_args[1].get("url", "")
                )
                expected_path = "/2/media/upload/{id}/append"
                assert expected_path.replace("{", "").replace(
                    "}", ""
                ) in called_url or any(
                    param in called_url for param in ["test_", "42"]
                ), f"URL should contain path template elements: {called_url}"
                # Verify response structure
                if is_streaming:
                    # For streaming, verify we got a generator
                    assert isinstance(
                        result, types.GeneratorType
                    ), "Streaming method should return a generator"
                else:
                    # For regular operations, verify we got a result
                    assert result is not None, "Method should return a result"
            except Exception as e:
                pytest.fail(f"Contract test failed for append_upload: {e}")


    def test_append_upload_required_parameters(self):
        """Test that append_upload handles parameters correctly."""
        method = getattr(self.media_client, "append_upload")
        # Test with missing required parameters - mock the request to avoid network calls
        with patch.object(self.client, "session") as mock_session:
            # Mock a 400 response (typical for missing required parameters)
            mock_response = Mock()
            mock_response.status_code = 400
            mock_response.json.return_value = {"error": "Missing required parameters"}
            mock_response.raise_for_status.side_effect = Exception("Bad Request")
            mock_session.post.return_value = mock_response
            # Call without required parameters should either raise locally or via server response
            # For generator methods (paginated), we need to iterate to trigger the exception
            import types
            with pytest.raises((TypeError, ValueError, Exception)):
                result = method()
                # Check if it's a generator (paginated method)
                if isinstance(result, types.GeneratorType):
                    # For generators, exception is raised when iterating
                    next(result)


    def test_append_upload_response_structure(self):
        """Test append_upload response structure validation."""
        with patch.object(self.client, "session") as mock_session:
            # Create mock response with expected structure
            mock_response_data = {
                "data": None,
            }
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = mock_response_data
            mock_response.raise_for_status.return_value = None
            mock_session.post.return_value = mock_response
            # Prepare minimal valid parameters
            kwargs = {}
            kwargs["id"] = "test"
            # Add request body if required
            # Import and create proper request model instance
            from xdk.media.models import AppendUploadRequest
            # Create instance with minimal valid data (empty instance should work for most cases)
            kwargs["body"] = AppendUploadRequest()
            # Call method and verify response structure
            method = getattr(self.media_client, "append_upload")
            result = method(**kwargs)
            # Verify response object has expected attributes
            # Optional field - just check it doesn't cause errors if accessed
            try:
                getattr(result, "data", None)
            except Exception as e:
                pytest.fail(
                    f"Accessing optional field 'data' should not cause errors: {e}"
                )


    def test_get_analytics_request_structure(self):
        """Test get_analytics request structure."""
        # Mock the session to capture request details
        with patch.object(self.client, "session") as mock_session:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {
                "data": None,
            }
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare test parameters
            kwargs = {}
            # Add required parameters
            kwargs["media_keys"] = ["test_item"]
            kwargs["end_time"] = "test_end_time"
            kwargs["start_time"] = "test_start_time"
            kwargs["granularity"] = "test_granularity"
            # Add request body if required
            # Call the method
            try:
                method = getattr(self.media_client, "get_analytics")
                # Check if this might be a streaming operation by inspecting return type
                import types
                import inspect
                sig = inspect.signature(method)
                return_annotation = str(sig.return_annotation)
                might_be_streaming = (
                    "Generator" in return_annotation or "Iterator" in return_annotation
                )
                # Set up streaming mock if it might be streaming (before calling method)
                if might_be_streaming:
                    mock_streaming_response = Mock()
                    mock_streaming_response.status_code = 200
                    mock_streaming_response.raise_for_status.return_value = None
                    # Make it a proper context manager
                    mock_streaming_response.__enter__ = Mock(
                        return_value=mock_streaming_response
                    )
                    mock_streaming_response.__exit__ = Mock(return_value=None)
                    # Set up iter_content to return an iterator that yields test data
                    # iter_content with decode_unicode=True returns strings, not bytes
                    test_data = '{"data": "test"}\n'
                    # iter_content is called as a method, so we need to make it return an iterator
                    mock_streaming_response.iter_content = Mock(
                        side_effect=lambda *args, **kwargs: iter([test_data])
                    )
                    # Make session.get return the context manager
                    mock_session.get.return_value = mock_streaming_response
                result = method(**kwargs)
                # Check if this is actually a streaming operation (returns Generator)
                is_streaming = isinstance(result, types.GeneratorType)
                if is_streaming:
                    # Consume the generator to trigger the HTTP request
                    # The HTTP request happens when entering the 'with' block inside the generator
                    # We need to actually iterate to trigger the request
                    try:
                        # Try to get first item - this will trigger the HTTP request
                        # The 'with' statement inside the generator will call session.get()
                        next(result)
                    except StopIteration:
                        # Generator exhausted immediately - request was still made
                        pass
                    except (
                        requests.exceptions.RequestException,
                        json.JSONDecodeError,
                        AttributeError,
                        ValueError,
                    ) as e:
                        # These exceptions can occur during streaming (request errors, JSON parsing, etc.)
                        # The request should still have been attempted
                        pass
                    # Don't catch other exceptions - if there's an error during setup (before the request),
                    # we want to know about it, and the request verification below will fail appropriately
                # Verify the request was made
                # For streaming operations, the request happens when entering the 'with' block
                # which occurs when we call next() on the generator
                mock_session.get.assert_called_once()
                # Verify request structure
                call_args = mock_session.get.call_args
                # Check URL structure
                called_url = (
                    call_args[0][0] if call_args[0] else call_args[1].get("url", "")
                )
                expected_path = "/2/media/analytics"
                assert expected_path.replace("{", "").replace(
                    "}", ""
                ) in called_url or any(
                    param in called_url for param in ["test_", "42"]
                ), f"URL should contain path template elements: {called_url}"
                # Verify response structure
                if is_streaming:
                    # For streaming, verify we got a generator
                    assert isinstance(
                        result, types.GeneratorType
                    ), "Streaming method should return a generator"
                else:
                    # For regular operations, verify we got a result
                    assert result is not None, "Method should return a result"
            except Exception as e:
                pytest.fail(f"Contract test failed for get_analytics: {e}")


    def test_get_analytics_required_parameters(self):
        """Test that get_analytics handles parameters correctly."""
        method = getattr(self.media_client, "get_analytics")
        # Test with missing required parameters - mock the request to avoid network calls
        with patch.object(self.client, "session") as mock_session:
            # Mock a 400 response (typical for missing required parameters)
            mock_response = Mock()
            mock_response.status_code = 400
            mock_response.json.return_value = {"error": "Missing required parameters"}
            mock_response.raise_for_status.side_effect = Exception("Bad Request")
            mock_session.get.return_value = mock_response
            # Call without required parameters should either raise locally or via server response
            # For generator methods (paginated), we need to iterate to trigger the exception
            import types
            with pytest.raises((TypeError, ValueError, Exception)):
                result = method()
                # Check if it's a generator (paginated method)
                if isinstance(result, types.GeneratorType):
                    # For generators, exception is raised when iterating
                    next(result)


    def test_get_analytics_response_structure(self):
        """Test get_analytics response structure validation."""
        with patch.object(self.client, "session") as mock_session:
            # Create mock response with expected structure
            mock_response_data = {
                "data": None,
            }
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = mock_response_data
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare minimal valid parameters
            kwargs = {}
            kwargs["media_keys"] = ["test"]
            kwargs["end_time"] = "test_value"
            kwargs["start_time"] = "test_value"
            kwargs["granularity"] = "test_value"
            # Add request body if required
            # Call method and verify response structure
            method = getattr(self.media_client, "get_analytics")
            result = method(**kwargs)
            # Verify response object has expected attributes
            # Optional field - just check it doesn't cause errors if accessed
            try:
                getattr(result, "data", None)
            except Exception as e:
                pytest.fail(
                    f"Accessing optional field 'data' should not cause errors: {e}"
                )


    def test_create_metadata_request_structure(self):
        """Test create_metadata request structure."""
        # Mock the session to capture request details
        with patch.object(self.client, "session") as mock_session:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {
                "data": None,
            }
            mock_response.raise_for_status.return_value = None
            mock_session.post.return_value = mock_response
            # Prepare test parameters
            kwargs = {}
            # Add required parameters
            # Add request body if required
            # Import and create proper request model instance
            from xdk.media.models import CreateMetadataRequest
            # Create instance with minimal valid data (empty instance should work for most cases)
            kwargs["body"] = CreateMetadataRequest()
            # Call the method
            try:
                method = getattr(self.media_client, "create_metadata")
                # Check if this might be a streaming operation by inspecting return type
                import types
                import inspect
                sig = inspect.signature(method)
                return_annotation = str(sig.return_annotation)
                might_be_streaming = (
                    "Generator" in return_annotation or "Iterator" in return_annotation
                )
                # Set up streaming mock if it might be streaming (before calling method)
                if might_be_streaming:
                    mock_streaming_response = Mock()
                    mock_streaming_response.status_code = 200
                    mock_streaming_response.raise_for_status.return_value = None
                    # Make it a proper context manager
                    mock_streaming_response.__enter__ = Mock(
                        return_value=mock_streaming_response
                    )
                    mock_streaming_response.__exit__ = Mock(return_value=None)
                    # Set up iter_content to return an iterator that yields test data
                    # iter_content with decode_unicode=True returns strings, not bytes
                    test_data = '{"data": "test"}\n'
                    # iter_content is called as a method, so we need to make it return an iterator
                    mock_streaming_response.iter_content = Mock(
                        side_effect=lambda *args, **kwargs: iter([test_data])
                    )
                    # Make session.get return the context manager
                    mock_session.post.return_value = mock_streaming_response
                result = method(**kwargs)
                # Check if this is actually a streaming operation (returns Generator)
                is_streaming = isinstance(result, types.GeneratorType)
                if is_streaming:
                    # Consume the generator to trigger the HTTP request
                    # The HTTP request happens when entering the 'with' block inside the generator
                    # We need to actually iterate to trigger the request
                    try:
                        # Try to get first item - this will trigger the HTTP request
                        # The 'with' statement inside the generator will call session.get()
                        next(result)
                    except StopIteration:
                        # Generator exhausted immediately - request was still made
                        pass
                    except (
                        requests.exceptions.RequestException,
                        json.JSONDecodeError,
                        AttributeError,
                        ValueError,
                    ) as e:
                        # These exceptions can occur during streaming (request errors, JSON parsing, etc.)
                        # The request should still have been attempted
                        pass
                    # Don't catch other exceptions - if there's an error during setup (before the request),
                    # we want to know about it, and the request verification below will fail appropriately
                # Verify the request was made
                # For streaming operations, the request happens when entering the 'with' block
                # which occurs when we call next() on the generator
                mock_session.post.assert_called_once()
                # Verify request structure
                call_args = mock_session.post.call_args
                # Check URL structure
                called_url = (
                    call_args[0][0] if call_args[0] else call_args[1].get("url", "")
                )
                expected_path = "/2/media/metadata"
                assert expected_path.replace("{", "").replace(
                    "}", ""
                ) in called_url or any(
                    param in called_url for param in ["test_", "42"]
                ), f"URL should contain path template elements: {called_url}"
                # Verify response structure
                if is_streaming:
                    # For streaming, verify we got a generator
                    assert isinstance(
                        result, types.GeneratorType
                    ), "Streaming method should return a generator"
                else:
                    # For regular operations, verify we got a result
                    assert result is not None, "Method should return a result"
            except Exception as e:
                pytest.fail(f"Contract test failed for create_metadata: {e}")


    def test_create_metadata_required_parameters(self):
        """Test that create_metadata handles parameters correctly."""
        method = getattr(self.media_client, "create_metadata")
        # Test with missing required parameters - mock the request to avoid network calls
        with patch.object(self.client, "session") as mock_session:
            # Mock a 400 response (typical for missing required parameters)
            mock_response = Mock()
            mock_response.status_code = 400
            mock_response.json.return_value = {"error": "Missing required parameters"}
            mock_response.raise_for_status.side_effect = Exception("Bad Request")
            mock_session.post.return_value = mock_response
            # Call without required parameters should either raise locally or via server response
            # For generator methods (paginated), we need to iterate to trigger the exception
            import types
            with pytest.raises((TypeError, ValueError, Exception)):
                result = method()
                # Check if it's a generator (paginated method)
                if isinstance(result, types.GeneratorType):
                    # For generators, exception is raised when iterating
                    next(result)


    def test_create_metadata_response_structure(self):
        """Test create_metadata response structure validation."""
        with patch.object(self.client, "session") as mock_session:
            # Create mock response with expected structure
            mock_response_data = {
                "data": None,
            }
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = mock_response_data
            mock_response.raise_for_status.return_value = None
            mock_session.post.return_value = mock_response
            # Prepare minimal valid parameters
            kwargs = {}
            # Add request body if required
            # Import and create proper request model instance
            from xdk.media.models import CreateMetadataRequest
            # Create instance with minimal valid data (empty instance should work for most cases)
            kwargs["body"] = CreateMetadataRequest()
            # Call method and verify response structure
            method = getattr(self.media_client, "create_metadata")
            result = method(**kwargs)
            # Verify response object has expected attributes
            # Optional field - just check it doesn't cause errors if accessed
            try:
                getattr(result, "data", None)
            except Exception as e:
                pytest.fail(
                    f"Accessing optional field 'data' should not cause errors: {e}"
                )
