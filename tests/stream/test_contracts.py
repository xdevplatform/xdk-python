# AUTO-GENERATED FILE - DO NOT EDIT
# This file was automatically generated by the XDK build tool.
# Any manual changes will be overwritten on the next generation.
"""
Auto-generated contract tests for {"class_name": "Stream", "display_name": "stream", "import_name": "stream", "original": ["stream"], "property_name": "stream"} client.

This module contains tests that validate the request/response contracts
of the {"class_name": "Stream", "display_name": "stream", "import_name": "stream", "original": ["stream"], "property_name": "stream"} client against the OpenAPI specification.

Generated automatically - do not edit manually.
"""

import pytest
import json
import requests
from unittest.mock import Mock, patch
from xdk.stream.client import StreamClient
from xdk import Client


class TestStreamContracts:
    """Test the API contracts of StreamClient."""


    def setup_class(self):
        """Set up test fixtures."""
        # Provide all authentication types for comprehensive test coverage
        # Tests mock the session, so actual HTTP requests won't be made
        from xdk.oauth1_auth import OAuth1
        oauth1 = OAuth1(
            api_key="test_api_key",
            api_secret="test_api_secret",
            callback="http://localhost:8080/callback",
            access_token="test_access_token",
            access_token_secret="test_access_token_secret",
        )
        self.client = Client(
            base_url="https://api.example.com",
            bearer_token="test_bearer_token",
            access_token="test_access_token",
            auth=oauth1,
        )
        self.stream_client = getattr(self.client, "stream")


    def test_posts_firehose_pt_request_structure(self):
        """Test posts_firehose_pt request structure."""
        # Mock the session to capture request details
        with patch.object(self.client, "session") as mock_session:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {}
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare test parameters
            kwargs = {}
            # Add required parameters
            kwargs["partition"] = 42
            # Add request body if required
            # Call the method
            try:
                method = getattr(self.stream_client, "posts_firehose_pt")
                # Check if this is a true streaming operation (has stream_config parameter)
                import types
                import inspect
                sig = inspect.signature(method)
                has_stream_config_param = "stream_config" in sig.parameters
                # Set up streaming mock only for actual streaming operations
                if has_stream_config_param:
                    mock_streaming_response = Mock()
                    mock_streaming_response.status_code = 200
                    mock_streaming_response.raise_for_status.return_value = None
                    # Make it a proper context manager
                    mock_streaming_response.__enter__ = Mock(
                        return_value=mock_streaming_response
                    )
                    mock_streaming_response.__exit__ = Mock(return_value=None)
                    # Set up iter_content to return an iterator that yields test data then stops
                    test_data = '{"data": "test"}\n'
                    mock_streaming_response.iter_content = Mock(
                        side_effect=lambda *args, **kw: iter([test_data])
                    )
                    # First call returns mock response, second call raises to prevent infinite reconnect loop
                    from xdk.streaming import StreamError, StreamErrorType
                    mock_session.get.side_effect = [
                        mock_streaming_response,
                        StreamError(
                            "Test complete", StreamErrorType.AUTHENTICATION_ERROR
                        ),
                    ]
                    # Pass stream_config with max_retries=0 to exit quickly on error
                    from xdk.streaming import StreamConfig
                    kwargs["stream_config"] = StreamConfig(max_retries=0)
                result = method(**kwargs)
                # Check if result is a generator (streaming or paginated)
                is_generator = isinstance(result, types.GeneratorType)
                is_streaming = has_stream_config_param and is_generator
                if is_generator:
                    # Consume the generator to trigger the HTTP request
                    # For both streaming and paginated methods, request happens on iteration
                    try:
                        # Try to get first item - this will trigger the HTTP request
                        next(result)
                    except StopIteration:
                        # Generator exhausted immediately - request was still made
                        pass
                    except (
                        requests.exceptions.RequestException,
                        json.JSONDecodeError,
                        AttributeError,
                        ValueError,
                    ) as e:
                        # These exceptions can occur during streaming/pagination
                        pass
                    except Exception as e:
                        # Accept validation errors - we're testing request structure, not response parsing
                        # Also accept streaming errors
                        err_str = str(e).lower()
                        err_type = type(e).__name__
                        if (
                            "validation" in err_str
                            or "ValidationError" in err_type
                            or "PydanticUserError" in err_type
                            or "Max retries" in str(e)
                            or "StreamError" in err_type
                            or "not fully defined" in err_str
                        ):
                            pass
                        else:
                            raise
                # Verify the request was made
                if is_streaming:
                    # Streaming methods may be called twice (first success, then error to stop reconnect loop)
                    assert mock_session.get.call_count >= 1
                else:
                    mock_session.get.assert_called_once()
                # Verify request structure
                call_args = mock_session.get.call_args
                # Check URL structure
                called_url = (
                    call_args[0][0] if call_args[0] else call_args[1].get("url", "")
                )
                expected_path = "/2/tweets/firehose/stream/lang/pt"
                assert expected_path.replace("{", "").replace(
                    "}", ""
                ) in called_url or any(
                    param in called_url for param in ["test_", "42"]
                ), f"URL should contain path template elements: {called_url}"
                # Verify response structure
                if is_streaming:
                    # For streaming, verify we got a generator
                    assert isinstance(
                        result, types.GeneratorType
                    ), "Streaming method should return a generator"
                else:
                    # For regular operations, verify we got a result
                    assert result is not None, "Method should return a result"
            except Exception as e:
                # Accept validation errors - we're testing request structure, not response parsing
                err_str = str(e).lower()
                err_type = type(e).__name__
                if (
                    "validation" in err_str
                    or "ValidationError" in err_type
                    or "PydanticUserError" in err_type
                    or "not fully defined" in err_str
                ):
                    # Validation error is acceptable - request was made, just response parsing failed
                    mock_session.get.assert_called_once()
                else:
                    pytest.fail(f"Contract test failed for posts_firehose_pt: {e}")


    def test_posts_firehose_pt_required_parameters(self):
        """Test that posts_firehose_pt handles parameters correctly."""
        method = getattr(self.stream_client, "posts_firehose_pt")
        # Test with missing required parameters - mock the request to avoid network calls
        with patch.object(self.client, "session") as mock_session:
            # Mock a 400 response (typical for missing required parameters)
            mock_response = Mock()
            mock_response.status_code = 400
            mock_response.json.return_value = {"error": "Missing required parameters"}
            mock_response.raise_for_status.side_effect = Exception("Bad Request")
            mock_session.get.return_value = mock_response
            # Call without required parameters should either raise locally or via server response
            # For generator methods (paginated), we need to iterate to trigger the exception
            import types
            with pytest.raises((TypeError, ValueError, Exception)):
                result = method()
                # Check if it's a generator (paginated method)
                if isinstance(result, types.GeneratorType):
                    # For generators, exception is raised when iterating
                    next(result)


    def test_posts_firehose_pt_response_structure(self):
        """Test posts_firehose_pt response structure validation."""
        with patch.object(self.client, "session") as mock_session:
            # Create mock response with expected structure
            mock_response_data = {}
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = mock_response_data
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare minimal valid parameters
            kwargs = {}
            kwargs["partition"] = 1
            # Add request body if required
            # Call method and verify response structure
            method = getattr(self.stream_client, "posts_firehose_pt")
            result = method(**kwargs)
            # Verify response object has expected attributes
            # Optional field - just check it doesn't cause errors if accessed
            try:
                getattr(result, "data", None)
            except Exception as e:
                pytest.fail(
                    f"Accessing optional field 'data' should not cause errors: {e}"
                )


    def test_likes_compliance_request_structure(self):
        """Test likes_compliance request structure."""
        # Mock the session to capture request details
        with patch.object(self.client, "session") as mock_session:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {}
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare test parameters
            kwargs = {}
            # Add required parameters
            # Add request body if required
            # Call the method
            try:
                method = getattr(self.stream_client, "likes_compliance")
                # Check if this is a true streaming operation (has stream_config parameter)
                import types
                import inspect
                sig = inspect.signature(method)
                has_stream_config_param = "stream_config" in sig.parameters
                # Set up streaming mock only for actual streaming operations
                if has_stream_config_param:
                    mock_streaming_response = Mock()
                    mock_streaming_response.status_code = 200
                    mock_streaming_response.raise_for_status.return_value = None
                    # Make it a proper context manager
                    mock_streaming_response.__enter__ = Mock(
                        return_value=mock_streaming_response
                    )
                    mock_streaming_response.__exit__ = Mock(return_value=None)
                    # Set up iter_content to return an iterator that yields test data then stops
                    test_data = '{"data": "test"}\n'
                    mock_streaming_response.iter_content = Mock(
                        side_effect=lambda *args, **kw: iter([test_data])
                    )
                    # First call returns mock response, second call raises to prevent infinite reconnect loop
                    from xdk.streaming import StreamError, StreamErrorType
                    mock_session.get.side_effect = [
                        mock_streaming_response,
                        StreamError(
                            "Test complete", StreamErrorType.AUTHENTICATION_ERROR
                        ),
                    ]
                    # Pass stream_config with max_retries=0 to exit quickly on error
                    from xdk.streaming import StreamConfig
                    kwargs["stream_config"] = StreamConfig(max_retries=0)
                result = method(**kwargs)
                # Check if result is a generator (streaming or paginated)
                is_generator = isinstance(result, types.GeneratorType)
                is_streaming = has_stream_config_param and is_generator
                if is_generator:
                    # Consume the generator to trigger the HTTP request
                    # For both streaming and paginated methods, request happens on iteration
                    try:
                        # Try to get first item - this will trigger the HTTP request
                        next(result)
                    except StopIteration:
                        # Generator exhausted immediately - request was still made
                        pass
                    except (
                        requests.exceptions.RequestException,
                        json.JSONDecodeError,
                        AttributeError,
                        ValueError,
                    ) as e:
                        # These exceptions can occur during streaming/pagination
                        pass
                    except Exception as e:
                        # Accept validation errors - we're testing request structure, not response parsing
                        # Also accept streaming errors
                        err_str = str(e).lower()
                        err_type = type(e).__name__
                        if (
                            "validation" in err_str
                            or "ValidationError" in err_type
                            or "PydanticUserError" in err_type
                            or "Max retries" in str(e)
                            or "StreamError" in err_type
                            or "not fully defined" in err_str
                        ):
                            pass
                        else:
                            raise
                # Verify the request was made
                if is_streaming:
                    # Streaming methods may be called twice (first success, then error to stop reconnect loop)
                    assert mock_session.get.call_count >= 1
                else:
                    mock_session.get.assert_called_once()
                # Verify request structure
                call_args = mock_session.get.call_args
                # Check URL structure
                called_url = (
                    call_args[0][0] if call_args[0] else call_args[1].get("url", "")
                )
                expected_path = "/2/likes/compliance/stream"
                assert expected_path.replace("{", "").replace(
                    "}", ""
                ) in called_url or any(
                    param in called_url for param in ["test_", "42"]
                ), f"URL should contain path template elements: {called_url}"
                # Verify response structure
                if is_streaming:
                    # For streaming, verify we got a generator
                    assert isinstance(
                        result, types.GeneratorType
                    ), "Streaming method should return a generator"
                else:
                    # For regular operations, verify we got a result
                    assert result is not None, "Method should return a result"
            except Exception as e:
                # Accept validation errors - we're testing request structure, not response parsing
                err_str = str(e).lower()
                err_type = type(e).__name__
                if (
                    "validation" in err_str
                    or "ValidationError" in err_type
                    or "PydanticUserError" in err_type
                    or "not fully defined" in err_str
                ):
                    # Validation error is acceptable - request was made, just response parsing failed
                    mock_session.get.assert_called_once()
                else:
                    pytest.fail(f"Contract test failed for likes_compliance: {e}")


    def test_likes_compliance_required_parameters(self):
        """Test that likes_compliance handles parameters correctly."""
        method = getattr(self.stream_client, "likes_compliance")
        # No required parameters, method should be callable without args
        with patch.object(self.client, "session") as mock_session:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {}
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            try:
                method()
            except Exception as e:
                pytest.fail(f"Method with no required params should be callable: {e}")


    def test_likes_compliance_response_structure(self):
        """Test likes_compliance response structure validation."""
        with patch.object(self.client, "session") as mock_session:
            # Create mock response with expected structure
            mock_response_data = {}
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = mock_response_data
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare minimal valid parameters
            kwargs = {}
            # Add request body if required
            # Call method and verify response structure
            method = getattr(self.stream_client, "likes_compliance")
            result = method(**kwargs)
            # Verify response object has expected attributes
            # Optional field - just check it doesn't cause errors if accessed
            try:
                getattr(result, "data", None)
            except Exception as e:
                pytest.fail(
                    f"Accessing optional field 'data' should not cause errors: {e}"
                )


    def test_get_rules_request_structure(self):
        """Test get_rules request structure."""
        # Mock the session to capture request details
        with patch.object(self.client, "session") as mock_session:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {}
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare test parameters
            kwargs = {}
            # Add required parameters
            # Add request body if required
            # Call the method
            try:
                method = getattr(self.stream_client, "get_rules")
                # Check if this is a true streaming operation (has stream_config parameter)
                import types
                import inspect
                sig = inspect.signature(method)
                has_stream_config_param = "stream_config" in sig.parameters
                # Set up streaming mock only for actual streaming operations
                if has_stream_config_param:
                    mock_streaming_response = Mock()
                    mock_streaming_response.status_code = 200
                    mock_streaming_response.raise_for_status.return_value = None
                    # Make it a proper context manager
                    mock_streaming_response.__enter__ = Mock(
                        return_value=mock_streaming_response
                    )
                    mock_streaming_response.__exit__ = Mock(return_value=None)
                    # Set up iter_content to return an iterator that yields test data then stops
                    test_data = '{"data": "test"}\n'
                    mock_streaming_response.iter_content = Mock(
                        side_effect=lambda *args, **kw: iter([test_data])
                    )
                    # First call returns mock response, second call raises to prevent infinite reconnect loop
                    from xdk.streaming import StreamError, StreamErrorType
                    mock_session.get.side_effect = [
                        mock_streaming_response,
                        StreamError(
                            "Test complete", StreamErrorType.AUTHENTICATION_ERROR
                        ),
                    ]
                    # Pass stream_config with max_retries=0 to exit quickly on error
                    from xdk.streaming import StreamConfig
                    kwargs["stream_config"] = StreamConfig(max_retries=0)
                result = method(**kwargs)
                # Check if result is a generator (streaming or paginated)
                is_generator = isinstance(result, types.GeneratorType)
                is_streaming = has_stream_config_param and is_generator
                if is_generator:
                    # Consume the generator to trigger the HTTP request
                    # For both streaming and paginated methods, request happens on iteration
                    try:
                        # Try to get first item - this will trigger the HTTP request
                        next(result)
                    except StopIteration:
                        # Generator exhausted immediately - request was still made
                        pass
                    except (
                        requests.exceptions.RequestException,
                        json.JSONDecodeError,
                        AttributeError,
                        ValueError,
                    ) as e:
                        # These exceptions can occur during streaming/pagination
                        pass
                    except Exception as e:
                        # Accept validation errors - we're testing request structure, not response parsing
                        # Also accept streaming errors
                        err_str = str(e).lower()
                        err_type = type(e).__name__
                        if (
                            "validation" in err_str
                            or "ValidationError" in err_type
                            or "PydanticUserError" in err_type
                            or "Max retries" in str(e)
                            or "StreamError" in err_type
                            or "not fully defined" in err_str
                        ):
                            pass
                        else:
                            raise
                # Verify the request was made
                if is_streaming:
                    # Streaming methods may be called twice (first success, then error to stop reconnect loop)
                    assert mock_session.get.call_count >= 1
                else:
                    mock_session.get.assert_called_once()
                # Verify request structure
                call_args = mock_session.get.call_args
                # Check URL structure
                called_url = (
                    call_args[0][0] if call_args[0] else call_args[1].get("url", "")
                )
                expected_path = "/2/tweets/search/stream/rules"
                assert expected_path.replace("{", "").replace(
                    "}", ""
                ) in called_url or any(
                    param in called_url for param in ["test_", "42"]
                ), f"URL should contain path template elements: {called_url}"
                # Verify response structure
                if is_streaming:
                    # For streaming, verify we got a generator
                    assert isinstance(
                        result, types.GeneratorType
                    ), "Streaming method should return a generator"
                else:
                    # For regular operations, verify we got a result
                    assert result is not None, "Method should return a result"
            except Exception as e:
                # Accept validation errors - we're testing request structure, not response parsing
                err_str = str(e).lower()
                err_type = type(e).__name__
                if (
                    "validation" in err_str
                    or "ValidationError" in err_type
                    or "PydanticUserError" in err_type
                    or "not fully defined" in err_str
                ):
                    # Validation error is acceptable - request was made, just response parsing failed
                    mock_session.get.assert_called_once()
                else:
                    pytest.fail(f"Contract test failed for get_rules: {e}")


    def test_get_rules_required_parameters(self):
        """Test that get_rules handles parameters correctly."""
        method = getattr(self.stream_client, "get_rules")
        # No required parameters, method should be callable without args
        with patch.object(self.client, "session") as mock_session:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {}
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            try:
                method()
            except Exception as e:
                pytest.fail(f"Method with no required params should be callable: {e}")


    def test_get_rules_response_structure(self):
        """Test get_rules response structure validation."""
        with patch.object(self.client, "session") as mock_session:
            # Create mock response with expected structure
            mock_response_data = {}
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = mock_response_data
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare minimal valid parameters
            kwargs = {}
            # Add request body if required
            # Call method and verify response structure
            method = getattr(self.stream_client, "get_rules")
            result = method(**kwargs)
            # Verify response object has expected attributes
            # Optional field - just check it doesn't cause errors if accessed
            try:
                getattr(result, "data", None)
            except Exception as e:
                pytest.fail(
                    f"Accessing optional field 'data' should not cause errors: {e}"
                )


    def test_update_rules_request_structure(self):
        """Test update_rules request structure."""
        # Mock the session to capture request details
        with patch.object(self.client, "session") as mock_session:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {}
            mock_response.raise_for_status.return_value = None
            mock_session.post.return_value = mock_response
            # Prepare test parameters
            kwargs = {}
            # Add required parameters
            # Add request body if required
            # Import and create proper request model instance
            from xdk.stream.models import UpdateRulesRequest
            # Rebuild model to resolve forward references before instantiation
            try:
                UpdateRulesRequest.model_rebuild()
            except Exception:
                pass  # Model may already be fully defined
            # Create instance with required fields (using dummy values for testing)
            required_kwargs = {}
            for field_name, field_info in UpdateRulesRequest.model_fields.items():
                if field_info.is_required():
                    annotation = (
                        str(field_info.annotation) if field_info.annotation else "str"
                    )
                    if "int" in annotation.lower():
                        required_kwargs[field_name] = 42
                    elif "bool" in annotation.lower():
                        required_kwargs[field_name] = True
                    elif "list" in annotation.lower() or "List" in annotation:
                        required_kwargs[field_name] = []
                    elif "dict" in annotation.lower() or "Dict" in annotation:
                        required_kwargs[field_name] = {}
                    else:
                        required_kwargs[field_name] = "test_value"
            kwargs["body"] = UpdateRulesRequest(**required_kwargs)
            # Call the method
            try:
                method = getattr(self.stream_client, "update_rules")
                # Check if this is a true streaming operation (has stream_config parameter)
                import types
                import inspect
                sig = inspect.signature(method)
                has_stream_config_param = "stream_config" in sig.parameters
                # Set up streaming mock only for actual streaming operations
                if has_stream_config_param:
                    mock_streaming_response = Mock()
                    mock_streaming_response.status_code = 200
                    mock_streaming_response.raise_for_status.return_value = None
                    # Make it a proper context manager
                    mock_streaming_response.__enter__ = Mock(
                        return_value=mock_streaming_response
                    )
                    mock_streaming_response.__exit__ = Mock(return_value=None)
                    # Set up iter_content to return an iterator that yields test data then stops
                    test_data = '{"data": "test"}\n'
                    mock_streaming_response.iter_content = Mock(
                        side_effect=lambda *args, **kw: iter([test_data])
                    )
                    # First call returns mock response, second call raises to prevent infinite reconnect loop
                    from xdk.streaming import StreamError, StreamErrorType
                    mock_session.post.side_effect = [
                        mock_streaming_response,
                        StreamError(
                            "Test complete", StreamErrorType.AUTHENTICATION_ERROR
                        ),
                    ]
                    # Pass stream_config with max_retries=0 to exit quickly on error
                    from xdk.streaming import StreamConfig
                    kwargs["stream_config"] = StreamConfig(max_retries=0)
                result = method(**kwargs)
                # Check if result is a generator (streaming or paginated)
                is_generator = isinstance(result, types.GeneratorType)
                is_streaming = has_stream_config_param and is_generator
                if is_generator:
                    # Consume the generator to trigger the HTTP request
                    # For both streaming and paginated methods, request happens on iteration
                    try:
                        # Try to get first item - this will trigger the HTTP request
                        next(result)
                    except StopIteration:
                        # Generator exhausted immediately - request was still made
                        pass
                    except (
                        requests.exceptions.RequestException,
                        json.JSONDecodeError,
                        AttributeError,
                        ValueError,
                    ) as e:
                        # These exceptions can occur during streaming/pagination
                        pass
                    except Exception as e:
                        # Accept validation errors - we're testing request structure, not response parsing
                        # Also accept streaming errors
                        err_str = str(e).lower()
                        err_type = type(e).__name__
                        if (
                            "validation" in err_str
                            or "ValidationError" in err_type
                            or "PydanticUserError" in err_type
                            or "Max retries" in str(e)
                            or "StreamError" in err_type
                            or "not fully defined" in err_str
                        ):
                            pass
                        else:
                            raise
                # Verify the request was made
                if is_streaming:
                    # Streaming methods may be called twice (first success, then error to stop reconnect loop)
                    assert mock_session.post.call_count >= 1
                else:
                    mock_session.post.assert_called_once()
                # Verify request structure
                call_args = mock_session.post.call_args
                # Check URL structure
                called_url = (
                    call_args[0][0] if call_args[0] else call_args[1].get("url", "")
                )
                expected_path = "/2/tweets/search/stream/rules"
                assert expected_path.replace("{", "").replace(
                    "}", ""
                ) in called_url or any(
                    param in called_url for param in ["test_", "42"]
                ), f"URL should contain path template elements: {called_url}"
                # Verify response structure
                if is_streaming:
                    # For streaming, verify we got a generator
                    assert isinstance(
                        result, types.GeneratorType
                    ), "Streaming method should return a generator"
                else:
                    # For regular operations, verify we got a result
                    assert result is not None, "Method should return a result"
            except Exception as e:
                # Accept validation errors - we're testing request structure, not response parsing
                err_str = str(e).lower()
                err_type = type(e).__name__
                if (
                    "validation" in err_str
                    or "ValidationError" in err_type
                    or "PydanticUserError" in err_type
                    or "not fully defined" in err_str
                ):
                    # Validation error is acceptable - request was made, just response parsing failed
                    mock_session.post.assert_called_once()
                else:
                    pytest.fail(f"Contract test failed for update_rules: {e}")


    def test_update_rules_required_parameters(self):
        """Test that update_rules handles parameters correctly."""
        method = getattr(self.stream_client, "update_rules")
        # Test with missing required parameters - mock the request to avoid network calls
        with patch.object(self.client, "session") as mock_session:
            # Mock a 400 response (typical for missing required parameters)
            mock_response = Mock()
            mock_response.status_code = 400
            mock_response.json.return_value = {"error": "Missing required parameters"}
            mock_response.raise_for_status.side_effect = Exception("Bad Request")
            mock_session.post.return_value = mock_response
            # Call without required parameters should either raise locally or via server response
            # For generator methods (paginated), we need to iterate to trigger the exception
            import types
            with pytest.raises((TypeError, ValueError, Exception)):
                result = method()
                # Check if it's a generator (paginated method)
                if isinstance(result, types.GeneratorType):
                    # For generators, exception is raised when iterating
                    next(result)


    def test_update_rules_response_structure(self):
        """Test update_rules response structure validation."""
        with patch.object(self.client, "session") as mock_session:
            # Create mock response with expected structure
            mock_response_data = {}
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = mock_response_data
            mock_response.raise_for_status.return_value = None
            mock_session.post.return_value = mock_response
            # Prepare minimal valid parameters
            kwargs = {}
            # Add request body if required
            # Import and create proper request model instance
            from xdk.stream.models import UpdateRulesRequest
            # Rebuild model to resolve forward references before instantiation
            try:
                UpdateRulesRequest.model_rebuild()
            except Exception:
                pass  # Model may already be fully defined
            # Create instance with required fields (using dummy values for testing)
            required_kwargs = {}
            for field_name, field_info in UpdateRulesRequest.model_fields.items():
                if field_info.is_required():
                    annotation = (
                        str(field_info.annotation) if field_info.annotation else "str"
                    )
                    if "int" in annotation.lower():
                        required_kwargs[field_name] = 42
                    elif "bool" in annotation.lower():
                        required_kwargs[field_name] = True
                    elif "list" in annotation.lower() or "List" in annotation:
                        required_kwargs[field_name] = []
                    elif "dict" in annotation.lower() or "Dict" in annotation:
                        required_kwargs[field_name] = {}
                    else:
                        required_kwargs[field_name] = "test_value"
            kwargs["body"] = UpdateRulesRequest(**required_kwargs)
            # Call method and verify response structure
            method = getattr(self.stream_client, "update_rules")
            result = method(**kwargs)
            # Verify response object has expected attributes
            # Optional field - just check it doesn't cause errors if accessed
            try:
                getattr(result, "data", None)
            except Exception as e:
                pytest.fail(
                    f"Accessing optional field 'data' should not cause errors: {e}"
                )


    def test_posts_firehose_ko_request_structure(self):
        """Test posts_firehose_ko request structure."""
        # Mock the session to capture request details
        with patch.object(self.client, "session") as mock_session:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {}
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare test parameters
            kwargs = {}
            # Add required parameters
            kwargs["partition"] = 42
            # Add request body if required
            # Call the method
            try:
                method = getattr(self.stream_client, "posts_firehose_ko")
                # Check if this is a true streaming operation (has stream_config parameter)
                import types
                import inspect
                sig = inspect.signature(method)
                has_stream_config_param = "stream_config" in sig.parameters
                # Set up streaming mock only for actual streaming operations
                if has_stream_config_param:
                    mock_streaming_response = Mock()
                    mock_streaming_response.status_code = 200
                    mock_streaming_response.raise_for_status.return_value = None
                    # Make it a proper context manager
                    mock_streaming_response.__enter__ = Mock(
                        return_value=mock_streaming_response
                    )
                    mock_streaming_response.__exit__ = Mock(return_value=None)
                    # Set up iter_content to return an iterator that yields test data then stops
                    test_data = '{"data": "test"}\n'
                    mock_streaming_response.iter_content = Mock(
                        side_effect=lambda *args, **kw: iter([test_data])
                    )
                    # First call returns mock response, second call raises to prevent infinite reconnect loop
                    from xdk.streaming import StreamError, StreamErrorType
                    mock_session.get.side_effect = [
                        mock_streaming_response,
                        StreamError(
                            "Test complete", StreamErrorType.AUTHENTICATION_ERROR
                        ),
                    ]
                    # Pass stream_config with max_retries=0 to exit quickly on error
                    from xdk.streaming import StreamConfig
                    kwargs["stream_config"] = StreamConfig(max_retries=0)
                result = method(**kwargs)
                # Check if result is a generator (streaming or paginated)
                is_generator = isinstance(result, types.GeneratorType)
                is_streaming = has_stream_config_param and is_generator
                if is_generator:
                    # Consume the generator to trigger the HTTP request
                    # For both streaming and paginated methods, request happens on iteration
                    try:
                        # Try to get first item - this will trigger the HTTP request
                        next(result)
                    except StopIteration:
                        # Generator exhausted immediately - request was still made
                        pass
                    except (
                        requests.exceptions.RequestException,
                        json.JSONDecodeError,
                        AttributeError,
                        ValueError,
                    ) as e:
                        # These exceptions can occur during streaming/pagination
                        pass
                    except Exception as e:
                        # Accept validation errors - we're testing request structure, not response parsing
                        # Also accept streaming errors
                        err_str = str(e).lower()
                        err_type = type(e).__name__
                        if (
                            "validation" in err_str
                            or "ValidationError" in err_type
                            or "PydanticUserError" in err_type
                            or "Max retries" in str(e)
                            or "StreamError" in err_type
                            or "not fully defined" in err_str
                        ):
                            pass
                        else:
                            raise
                # Verify the request was made
                if is_streaming:
                    # Streaming methods may be called twice (first success, then error to stop reconnect loop)
                    assert mock_session.get.call_count >= 1
                else:
                    mock_session.get.assert_called_once()
                # Verify request structure
                call_args = mock_session.get.call_args
                # Check URL structure
                called_url = (
                    call_args[0][0] if call_args[0] else call_args[1].get("url", "")
                )
                expected_path = "/2/tweets/firehose/stream/lang/ko"
                assert expected_path.replace("{", "").replace(
                    "}", ""
                ) in called_url or any(
                    param in called_url for param in ["test_", "42"]
                ), f"URL should contain path template elements: {called_url}"
                # Verify response structure
                if is_streaming:
                    # For streaming, verify we got a generator
                    assert isinstance(
                        result, types.GeneratorType
                    ), "Streaming method should return a generator"
                else:
                    # For regular operations, verify we got a result
                    assert result is not None, "Method should return a result"
            except Exception as e:
                # Accept validation errors - we're testing request structure, not response parsing
                err_str = str(e).lower()
                err_type = type(e).__name__
                if (
                    "validation" in err_str
                    or "ValidationError" in err_type
                    or "PydanticUserError" in err_type
                    or "not fully defined" in err_str
                ):
                    # Validation error is acceptable - request was made, just response parsing failed
                    mock_session.get.assert_called_once()
                else:
                    pytest.fail(f"Contract test failed for posts_firehose_ko: {e}")


    def test_posts_firehose_ko_required_parameters(self):
        """Test that posts_firehose_ko handles parameters correctly."""
        method = getattr(self.stream_client, "posts_firehose_ko")
        # Test with missing required parameters - mock the request to avoid network calls
        with patch.object(self.client, "session") as mock_session:
            # Mock a 400 response (typical for missing required parameters)
            mock_response = Mock()
            mock_response.status_code = 400
            mock_response.json.return_value = {"error": "Missing required parameters"}
            mock_response.raise_for_status.side_effect = Exception("Bad Request")
            mock_session.get.return_value = mock_response
            # Call without required parameters should either raise locally or via server response
            # For generator methods (paginated), we need to iterate to trigger the exception
            import types
            with pytest.raises((TypeError, ValueError, Exception)):
                result = method()
                # Check if it's a generator (paginated method)
                if isinstance(result, types.GeneratorType):
                    # For generators, exception is raised when iterating
                    next(result)


    def test_posts_firehose_ko_response_structure(self):
        """Test posts_firehose_ko response structure validation."""
        with patch.object(self.client, "session") as mock_session:
            # Create mock response with expected structure
            mock_response_data = {}
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = mock_response_data
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare minimal valid parameters
            kwargs = {}
            kwargs["partition"] = 1
            # Add request body if required
            # Call method and verify response structure
            method = getattr(self.stream_client, "posts_firehose_ko")
            result = method(**kwargs)
            # Verify response object has expected attributes
            # Optional field - just check it doesn't cause errors if accessed
            try:
                getattr(result, "data", None)
            except Exception as e:
                pytest.fail(
                    f"Accessing optional field 'data' should not cause errors: {e}"
                )


    def test_users_compliance_request_structure(self):
        """Test users_compliance request structure."""
        # Mock the session to capture request details
        with patch.object(self.client, "session") as mock_session:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {}
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare test parameters
            kwargs = {}
            # Add required parameters
            kwargs["partition"] = 42
            # Add request body if required
            # Call the method
            try:
                method = getattr(self.stream_client, "users_compliance")
                # Check if this is a true streaming operation (has stream_config parameter)
                import types
                import inspect
                sig = inspect.signature(method)
                has_stream_config_param = "stream_config" in sig.parameters
                # Set up streaming mock only for actual streaming operations
                if has_stream_config_param:
                    mock_streaming_response = Mock()
                    mock_streaming_response.status_code = 200
                    mock_streaming_response.raise_for_status.return_value = None
                    # Make it a proper context manager
                    mock_streaming_response.__enter__ = Mock(
                        return_value=mock_streaming_response
                    )
                    mock_streaming_response.__exit__ = Mock(return_value=None)
                    # Set up iter_content to return an iterator that yields test data then stops
                    test_data = '{"data": "test"}\n'
                    mock_streaming_response.iter_content = Mock(
                        side_effect=lambda *args, **kw: iter([test_data])
                    )
                    # First call returns mock response, second call raises to prevent infinite reconnect loop
                    from xdk.streaming import StreamError, StreamErrorType
                    mock_session.get.side_effect = [
                        mock_streaming_response,
                        StreamError(
                            "Test complete", StreamErrorType.AUTHENTICATION_ERROR
                        ),
                    ]
                    # Pass stream_config with max_retries=0 to exit quickly on error
                    from xdk.streaming import StreamConfig
                    kwargs["stream_config"] = StreamConfig(max_retries=0)
                result = method(**kwargs)
                # Check if result is a generator (streaming or paginated)
                is_generator = isinstance(result, types.GeneratorType)
                is_streaming = has_stream_config_param and is_generator
                if is_generator:
                    # Consume the generator to trigger the HTTP request
                    # For both streaming and paginated methods, request happens on iteration
                    try:
                        # Try to get first item - this will trigger the HTTP request
                        next(result)
                    except StopIteration:
                        # Generator exhausted immediately - request was still made
                        pass
                    except (
                        requests.exceptions.RequestException,
                        json.JSONDecodeError,
                        AttributeError,
                        ValueError,
                    ) as e:
                        # These exceptions can occur during streaming/pagination
                        pass
                    except Exception as e:
                        # Accept validation errors - we're testing request structure, not response parsing
                        # Also accept streaming errors
                        err_str = str(e).lower()
                        err_type = type(e).__name__
                        if (
                            "validation" in err_str
                            or "ValidationError" in err_type
                            or "PydanticUserError" in err_type
                            or "Max retries" in str(e)
                            or "StreamError" in err_type
                            or "not fully defined" in err_str
                        ):
                            pass
                        else:
                            raise
                # Verify the request was made
                if is_streaming:
                    # Streaming methods may be called twice (first success, then error to stop reconnect loop)
                    assert mock_session.get.call_count >= 1
                else:
                    mock_session.get.assert_called_once()
                # Verify request structure
                call_args = mock_session.get.call_args
                # Check URL structure
                called_url = (
                    call_args[0][0] if call_args[0] else call_args[1].get("url", "")
                )
                expected_path = "/2/users/compliance/stream"
                assert expected_path.replace("{", "").replace(
                    "}", ""
                ) in called_url or any(
                    param in called_url for param in ["test_", "42"]
                ), f"URL should contain path template elements: {called_url}"
                # Verify response structure
                if is_streaming:
                    # For streaming, verify we got a generator
                    assert isinstance(
                        result, types.GeneratorType
                    ), "Streaming method should return a generator"
                else:
                    # For regular operations, verify we got a result
                    assert result is not None, "Method should return a result"
            except Exception as e:
                # Accept validation errors - we're testing request structure, not response parsing
                err_str = str(e).lower()
                err_type = type(e).__name__
                if (
                    "validation" in err_str
                    or "ValidationError" in err_type
                    or "PydanticUserError" in err_type
                    or "not fully defined" in err_str
                ):
                    # Validation error is acceptable - request was made, just response parsing failed
                    mock_session.get.assert_called_once()
                else:
                    pytest.fail(f"Contract test failed for users_compliance: {e}")


    def test_users_compliance_required_parameters(self):
        """Test that users_compliance handles parameters correctly."""
        method = getattr(self.stream_client, "users_compliance")
        # Test with missing required parameters - mock the request to avoid network calls
        with patch.object(self.client, "session") as mock_session:
            # Mock a 400 response (typical for missing required parameters)
            mock_response = Mock()
            mock_response.status_code = 400
            mock_response.json.return_value = {"error": "Missing required parameters"}
            mock_response.raise_for_status.side_effect = Exception("Bad Request")
            mock_session.get.return_value = mock_response
            # Call without required parameters should either raise locally or via server response
            # For generator methods (paginated), we need to iterate to trigger the exception
            import types
            with pytest.raises((TypeError, ValueError, Exception)):
                result = method()
                # Check if it's a generator (paginated method)
                if isinstance(result, types.GeneratorType):
                    # For generators, exception is raised when iterating
                    next(result)


    def test_users_compliance_response_structure(self):
        """Test users_compliance response structure validation."""
        with patch.object(self.client, "session") as mock_session:
            # Create mock response with expected structure
            mock_response_data = {}
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = mock_response_data
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare minimal valid parameters
            kwargs = {}
            kwargs["partition"] = 1
            # Add request body if required
            # Call method and verify response structure
            method = getattr(self.stream_client, "users_compliance")
            result = method(**kwargs)
            # Verify response object has expected attributes
            # Optional field - just check it doesn't cause errors if accessed
            try:
                getattr(result, "data", None)
            except Exception as e:
                pytest.fail(
                    f"Accessing optional field 'data' should not cause errors: {e}"
                )


    def test_get_rule_counts_request_structure(self):
        """Test get_rule_counts request structure."""
        # Mock the session to capture request details
        with patch.object(self.client, "session") as mock_session:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {}
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare test parameters
            kwargs = {}
            # Add required parameters
            # Add request body if required
            # Call the method
            try:
                method = getattr(self.stream_client, "get_rule_counts")
                # Check if this is a true streaming operation (has stream_config parameter)
                import types
                import inspect
                sig = inspect.signature(method)
                has_stream_config_param = "stream_config" in sig.parameters
                # Set up streaming mock only for actual streaming operations
                if has_stream_config_param:
                    mock_streaming_response = Mock()
                    mock_streaming_response.status_code = 200
                    mock_streaming_response.raise_for_status.return_value = None
                    # Make it a proper context manager
                    mock_streaming_response.__enter__ = Mock(
                        return_value=mock_streaming_response
                    )
                    mock_streaming_response.__exit__ = Mock(return_value=None)
                    # Set up iter_content to return an iterator that yields test data then stops
                    test_data = '{"data": "test"}\n'
                    mock_streaming_response.iter_content = Mock(
                        side_effect=lambda *args, **kw: iter([test_data])
                    )
                    # First call returns mock response, second call raises to prevent infinite reconnect loop
                    from xdk.streaming import StreamError, StreamErrorType
                    mock_session.get.side_effect = [
                        mock_streaming_response,
                        StreamError(
                            "Test complete", StreamErrorType.AUTHENTICATION_ERROR
                        ),
                    ]
                    # Pass stream_config with max_retries=0 to exit quickly on error
                    from xdk.streaming import StreamConfig
                    kwargs["stream_config"] = StreamConfig(max_retries=0)
                result = method(**kwargs)
                # Check if result is a generator (streaming or paginated)
                is_generator = isinstance(result, types.GeneratorType)
                is_streaming = has_stream_config_param and is_generator
                if is_generator:
                    # Consume the generator to trigger the HTTP request
                    # For both streaming and paginated methods, request happens on iteration
                    try:
                        # Try to get first item - this will trigger the HTTP request
                        next(result)
                    except StopIteration:
                        # Generator exhausted immediately - request was still made
                        pass
                    except (
                        requests.exceptions.RequestException,
                        json.JSONDecodeError,
                        AttributeError,
                        ValueError,
                    ) as e:
                        # These exceptions can occur during streaming/pagination
                        pass
                    except Exception as e:
                        # Accept validation errors - we're testing request structure, not response parsing
                        # Also accept streaming errors
                        err_str = str(e).lower()
                        err_type = type(e).__name__
                        if (
                            "validation" in err_str
                            or "ValidationError" in err_type
                            or "PydanticUserError" in err_type
                            or "Max retries" in str(e)
                            or "StreamError" in err_type
                            or "not fully defined" in err_str
                        ):
                            pass
                        else:
                            raise
                # Verify the request was made
                if is_streaming:
                    # Streaming methods may be called twice (first success, then error to stop reconnect loop)
                    assert mock_session.get.call_count >= 1
                else:
                    mock_session.get.assert_called_once()
                # Verify request structure
                call_args = mock_session.get.call_args
                # Check URL structure
                called_url = (
                    call_args[0][0] if call_args[0] else call_args[1].get("url", "")
                )
                expected_path = "/2/tweets/search/stream/rules/counts"
                assert expected_path.replace("{", "").replace(
                    "}", ""
                ) in called_url or any(
                    param in called_url for param in ["test_", "42"]
                ), f"URL should contain path template elements: {called_url}"
                # Verify response structure
                if is_streaming:
                    # For streaming, verify we got a generator
                    assert isinstance(
                        result, types.GeneratorType
                    ), "Streaming method should return a generator"
                else:
                    # For regular operations, verify we got a result
                    assert result is not None, "Method should return a result"
            except Exception as e:
                # Accept validation errors - we're testing request structure, not response parsing
                err_str = str(e).lower()
                err_type = type(e).__name__
                if (
                    "validation" in err_str
                    or "ValidationError" in err_type
                    or "PydanticUserError" in err_type
                    or "not fully defined" in err_str
                ):
                    # Validation error is acceptable - request was made, just response parsing failed
                    mock_session.get.assert_called_once()
                else:
                    pytest.fail(f"Contract test failed for get_rule_counts: {e}")


    def test_get_rule_counts_required_parameters(self):
        """Test that get_rule_counts handles parameters correctly."""
        method = getattr(self.stream_client, "get_rule_counts")
        # No required parameters, method should be callable without args
        with patch.object(self.client, "session") as mock_session:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {}
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            try:
                method()
            except Exception as e:
                pytest.fail(f"Method with no required params should be callable: {e}")


    def test_get_rule_counts_response_structure(self):
        """Test get_rule_counts response structure validation."""
        with patch.object(self.client, "session") as mock_session:
            # Create mock response with expected structure
            mock_response_data = {}
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = mock_response_data
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare minimal valid parameters
            kwargs = {}
            # Add request body if required
            # Call method and verify response structure
            method = getattr(self.stream_client, "get_rule_counts")
            result = method(**kwargs)
            # Verify response object has expected attributes
            # Optional field - just check it doesn't cause errors if accessed
            try:
                getattr(result, "data", None)
            except Exception as e:
                pytest.fail(
                    f"Accessing optional field 'data' should not cause errors: {e}"
                )


    def test_likes_sample10_request_structure(self):
        """Test likes_sample10 request structure."""
        # Mock the session to capture request details
        with patch.object(self.client, "session") as mock_session:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {}
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare test parameters
            kwargs = {}
            # Add required parameters
            kwargs["partition"] = 42
            # Add request body if required
            # Call the method
            try:
                method = getattr(self.stream_client, "likes_sample10")
                # Check if this is a true streaming operation (has stream_config parameter)
                import types
                import inspect
                sig = inspect.signature(method)
                has_stream_config_param = "stream_config" in sig.parameters
                # Set up streaming mock only for actual streaming operations
                if has_stream_config_param:
                    mock_streaming_response = Mock()
                    mock_streaming_response.status_code = 200
                    mock_streaming_response.raise_for_status.return_value = None
                    # Make it a proper context manager
                    mock_streaming_response.__enter__ = Mock(
                        return_value=mock_streaming_response
                    )
                    mock_streaming_response.__exit__ = Mock(return_value=None)
                    # Set up iter_content to return an iterator that yields test data then stops
                    test_data = '{"data": "test"}\n'
                    mock_streaming_response.iter_content = Mock(
                        side_effect=lambda *args, **kw: iter([test_data])
                    )
                    # First call returns mock response, second call raises to prevent infinite reconnect loop
                    from xdk.streaming import StreamError, StreamErrorType
                    mock_session.get.side_effect = [
                        mock_streaming_response,
                        StreamError(
                            "Test complete", StreamErrorType.AUTHENTICATION_ERROR
                        ),
                    ]
                    # Pass stream_config with max_retries=0 to exit quickly on error
                    from xdk.streaming import StreamConfig
                    kwargs["stream_config"] = StreamConfig(max_retries=0)
                result = method(**kwargs)
                # Check if result is a generator (streaming or paginated)
                is_generator = isinstance(result, types.GeneratorType)
                is_streaming = has_stream_config_param and is_generator
                if is_generator:
                    # Consume the generator to trigger the HTTP request
                    # For both streaming and paginated methods, request happens on iteration
                    try:
                        # Try to get first item - this will trigger the HTTP request
                        next(result)
                    except StopIteration:
                        # Generator exhausted immediately - request was still made
                        pass
                    except (
                        requests.exceptions.RequestException,
                        json.JSONDecodeError,
                        AttributeError,
                        ValueError,
                    ) as e:
                        # These exceptions can occur during streaming/pagination
                        pass
                    except Exception as e:
                        # Accept validation errors - we're testing request structure, not response parsing
                        # Also accept streaming errors
                        err_str = str(e).lower()
                        err_type = type(e).__name__
                        if (
                            "validation" in err_str
                            or "ValidationError" in err_type
                            or "PydanticUserError" in err_type
                            or "Max retries" in str(e)
                            or "StreamError" in err_type
                            or "not fully defined" in err_str
                        ):
                            pass
                        else:
                            raise
                # Verify the request was made
                if is_streaming:
                    # Streaming methods may be called twice (first success, then error to stop reconnect loop)
                    assert mock_session.get.call_count >= 1
                else:
                    mock_session.get.assert_called_once()
                # Verify request structure
                call_args = mock_session.get.call_args
                # Check URL structure
                called_url = (
                    call_args[0][0] if call_args[0] else call_args[1].get("url", "")
                )
                expected_path = "/2/likes/sample10/stream"
                assert expected_path.replace("{", "").replace(
                    "}", ""
                ) in called_url or any(
                    param in called_url for param in ["test_", "42"]
                ), f"URL should contain path template elements: {called_url}"
                # Verify response structure
                if is_streaming:
                    # For streaming, verify we got a generator
                    assert isinstance(
                        result, types.GeneratorType
                    ), "Streaming method should return a generator"
                else:
                    # For regular operations, verify we got a result
                    assert result is not None, "Method should return a result"
            except Exception as e:
                # Accept validation errors - we're testing request structure, not response parsing
                err_str = str(e).lower()
                err_type = type(e).__name__
                if (
                    "validation" in err_str
                    or "ValidationError" in err_type
                    or "PydanticUserError" in err_type
                    or "not fully defined" in err_str
                ):
                    # Validation error is acceptable - request was made, just response parsing failed
                    mock_session.get.assert_called_once()
                else:
                    pytest.fail(f"Contract test failed for likes_sample10: {e}")


    def test_likes_sample10_required_parameters(self):
        """Test that likes_sample10 handles parameters correctly."""
        method = getattr(self.stream_client, "likes_sample10")
        # Test with missing required parameters - mock the request to avoid network calls
        with patch.object(self.client, "session") as mock_session:
            # Mock a 400 response (typical for missing required parameters)
            mock_response = Mock()
            mock_response.status_code = 400
            mock_response.json.return_value = {"error": "Missing required parameters"}
            mock_response.raise_for_status.side_effect = Exception("Bad Request")
            mock_session.get.return_value = mock_response
            # Call without required parameters should either raise locally or via server response
            # For generator methods (paginated), we need to iterate to trigger the exception
            import types
            with pytest.raises((TypeError, ValueError, Exception)):
                result = method()
                # Check if it's a generator (paginated method)
                if isinstance(result, types.GeneratorType):
                    # For generators, exception is raised when iterating
                    next(result)


    def test_likes_sample10_response_structure(self):
        """Test likes_sample10 response structure validation."""
        with patch.object(self.client, "session") as mock_session:
            # Create mock response with expected structure
            mock_response_data = {}
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = mock_response_data
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare minimal valid parameters
            kwargs = {}
            kwargs["partition"] = 1
            # Add request body if required
            # Call method and verify response structure
            method = getattr(self.stream_client, "likes_sample10")
            result = method(**kwargs)
            # Verify response object has expected attributes
            # Optional field - just check it doesn't cause errors if accessed
            try:
                getattr(result, "data", None)
            except Exception as e:
                pytest.fail(
                    f"Accessing optional field 'data' should not cause errors: {e}"
                )


    def test_posts_firehose_en_request_structure(self):
        """Test posts_firehose_en request structure."""
        # Mock the session to capture request details
        with patch.object(self.client, "session") as mock_session:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {}
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare test parameters
            kwargs = {}
            # Add required parameters
            kwargs["partition"] = 42
            # Add request body if required
            # Call the method
            try:
                method = getattr(self.stream_client, "posts_firehose_en")
                # Check if this is a true streaming operation (has stream_config parameter)
                import types
                import inspect
                sig = inspect.signature(method)
                has_stream_config_param = "stream_config" in sig.parameters
                # Set up streaming mock only for actual streaming operations
                if has_stream_config_param:
                    mock_streaming_response = Mock()
                    mock_streaming_response.status_code = 200
                    mock_streaming_response.raise_for_status.return_value = None
                    # Make it a proper context manager
                    mock_streaming_response.__enter__ = Mock(
                        return_value=mock_streaming_response
                    )
                    mock_streaming_response.__exit__ = Mock(return_value=None)
                    # Set up iter_content to return an iterator that yields test data then stops
                    test_data = '{"data": "test"}\n'
                    mock_streaming_response.iter_content = Mock(
                        side_effect=lambda *args, **kw: iter([test_data])
                    )
                    # First call returns mock response, second call raises to prevent infinite reconnect loop
                    from xdk.streaming import StreamError, StreamErrorType
                    mock_session.get.side_effect = [
                        mock_streaming_response,
                        StreamError(
                            "Test complete", StreamErrorType.AUTHENTICATION_ERROR
                        ),
                    ]
                    # Pass stream_config with max_retries=0 to exit quickly on error
                    from xdk.streaming import StreamConfig
                    kwargs["stream_config"] = StreamConfig(max_retries=0)
                result = method(**kwargs)
                # Check if result is a generator (streaming or paginated)
                is_generator = isinstance(result, types.GeneratorType)
                is_streaming = has_stream_config_param and is_generator
                if is_generator:
                    # Consume the generator to trigger the HTTP request
                    # For both streaming and paginated methods, request happens on iteration
                    try:
                        # Try to get first item - this will trigger the HTTP request
                        next(result)
                    except StopIteration:
                        # Generator exhausted immediately - request was still made
                        pass
                    except (
                        requests.exceptions.RequestException,
                        json.JSONDecodeError,
                        AttributeError,
                        ValueError,
                    ) as e:
                        # These exceptions can occur during streaming/pagination
                        pass
                    except Exception as e:
                        # Accept validation errors - we're testing request structure, not response parsing
                        # Also accept streaming errors
                        err_str = str(e).lower()
                        err_type = type(e).__name__
                        if (
                            "validation" in err_str
                            or "ValidationError" in err_type
                            or "PydanticUserError" in err_type
                            or "Max retries" in str(e)
                            or "StreamError" in err_type
                            or "not fully defined" in err_str
                        ):
                            pass
                        else:
                            raise
                # Verify the request was made
                if is_streaming:
                    # Streaming methods may be called twice (first success, then error to stop reconnect loop)
                    assert mock_session.get.call_count >= 1
                else:
                    mock_session.get.assert_called_once()
                # Verify request structure
                call_args = mock_session.get.call_args
                # Check URL structure
                called_url = (
                    call_args[0][0] if call_args[0] else call_args[1].get("url", "")
                )
                expected_path = "/2/tweets/firehose/stream/lang/en"
                assert expected_path.replace("{", "").replace(
                    "}", ""
                ) in called_url or any(
                    param in called_url for param in ["test_", "42"]
                ), f"URL should contain path template elements: {called_url}"
                # Verify response structure
                if is_streaming:
                    # For streaming, verify we got a generator
                    assert isinstance(
                        result, types.GeneratorType
                    ), "Streaming method should return a generator"
                else:
                    # For regular operations, verify we got a result
                    assert result is not None, "Method should return a result"
            except Exception as e:
                # Accept validation errors - we're testing request structure, not response parsing
                err_str = str(e).lower()
                err_type = type(e).__name__
                if (
                    "validation" in err_str
                    or "ValidationError" in err_type
                    or "PydanticUserError" in err_type
                    or "not fully defined" in err_str
                ):
                    # Validation error is acceptable - request was made, just response parsing failed
                    mock_session.get.assert_called_once()
                else:
                    pytest.fail(f"Contract test failed for posts_firehose_en: {e}")


    def test_posts_firehose_en_required_parameters(self):
        """Test that posts_firehose_en handles parameters correctly."""
        method = getattr(self.stream_client, "posts_firehose_en")
        # Test with missing required parameters - mock the request to avoid network calls
        with patch.object(self.client, "session") as mock_session:
            # Mock a 400 response (typical for missing required parameters)
            mock_response = Mock()
            mock_response.status_code = 400
            mock_response.json.return_value = {"error": "Missing required parameters"}
            mock_response.raise_for_status.side_effect = Exception("Bad Request")
            mock_session.get.return_value = mock_response
            # Call without required parameters should either raise locally or via server response
            # For generator methods (paginated), we need to iterate to trigger the exception
            import types
            with pytest.raises((TypeError, ValueError, Exception)):
                result = method()
                # Check if it's a generator (paginated method)
                if isinstance(result, types.GeneratorType):
                    # For generators, exception is raised when iterating
                    next(result)


    def test_posts_firehose_en_response_structure(self):
        """Test posts_firehose_en response structure validation."""
        with patch.object(self.client, "session") as mock_session:
            # Create mock response with expected structure
            mock_response_data = {}
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = mock_response_data
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare minimal valid parameters
            kwargs = {}
            kwargs["partition"] = 1
            # Add request body if required
            # Call method and verify response structure
            method = getattr(self.stream_client, "posts_firehose_en")
            result = method(**kwargs)
            # Verify response object has expected attributes
            # Optional field - just check it doesn't cause errors if accessed
            try:
                getattr(result, "data", None)
            except Exception as e:
                pytest.fail(
                    f"Accessing optional field 'data' should not cause errors: {e}"
                )


    def test_posts_request_structure(self):
        """Test posts request structure."""
        # Mock the session to capture request details
        with patch.object(self.client, "session") as mock_session:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {}
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare test parameters
            kwargs = {}
            # Add required parameters
            # Add request body if required
            # Call the method
            try:
                method = getattr(self.stream_client, "posts")
                # Check if this is a true streaming operation (has stream_config parameter)
                import types
                import inspect
                sig = inspect.signature(method)
                has_stream_config_param = "stream_config" in sig.parameters
                # Set up streaming mock only for actual streaming operations
                if has_stream_config_param:
                    mock_streaming_response = Mock()
                    mock_streaming_response.status_code = 200
                    mock_streaming_response.raise_for_status.return_value = None
                    # Make it a proper context manager
                    mock_streaming_response.__enter__ = Mock(
                        return_value=mock_streaming_response
                    )
                    mock_streaming_response.__exit__ = Mock(return_value=None)
                    # Set up iter_content to return an iterator that yields test data then stops
                    test_data = '{"data": "test"}\n'
                    mock_streaming_response.iter_content = Mock(
                        side_effect=lambda *args, **kw: iter([test_data])
                    )
                    # First call returns mock response, second call raises to prevent infinite reconnect loop
                    from xdk.streaming import StreamError, StreamErrorType
                    mock_session.get.side_effect = [
                        mock_streaming_response,
                        StreamError(
                            "Test complete", StreamErrorType.AUTHENTICATION_ERROR
                        ),
                    ]
                    # Pass stream_config with max_retries=0 to exit quickly on error
                    from xdk.streaming import StreamConfig
                    kwargs["stream_config"] = StreamConfig(max_retries=0)
                result = method(**kwargs)
                # Check if result is a generator (streaming or paginated)
                is_generator = isinstance(result, types.GeneratorType)
                is_streaming = has_stream_config_param and is_generator
                if is_generator:
                    # Consume the generator to trigger the HTTP request
                    # For both streaming and paginated methods, request happens on iteration
                    try:
                        # Try to get first item - this will trigger the HTTP request
                        next(result)
                    except StopIteration:
                        # Generator exhausted immediately - request was still made
                        pass
                    except (
                        requests.exceptions.RequestException,
                        json.JSONDecodeError,
                        AttributeError,
                        ValueError,
                    ) as e:
                        # These exceptions can occur during streaming/pagination
                        pass
                    except Exception as e:
                        # Accept validation errors - we're testing request structure, not response parsing
                        # Also accept streaming errors
                        err_str = str(e).lower()
                        err_type = type(e).__name__
                        if (
                            "validation" in err_str
                            or "ValidationError" in err_type
                            or "PydanticUserError" in err_type
                            or "Max retries" in str(e)
                            or "StreamError" in err_type
                            or "not fully defined" in err_str
                        ):
                            pass
                        else:
                            raise
                # Verify the request was made
                if is_streaming:
                    # Streaming methods may be called twice (first success, then error to stop reconnect loop)
                    assert mock_session.get.call_count >= 1
                else:
                    mock_session.get.assert_called_once()
                # Verify request structure
                call_args = mock_session.get.call_args
                # Check URL structure
                called_url = (
                    call_args[0][0] if call_args[0] else call_args[1].get("url", "")
                )
                expected_path = "/2/tweets/search/stream"
                assert expected_path.replace("{", "").replace(
                    "}", ""
                ) in called_url or any(
                    param in called_url for param in ["test_", "42"]
                ), f"URL should contain path template elements: {called_url}"
                # Verify response structure
                if is_streaming:
                    # For streaming, verify we got a generator
                    assert isinstance(
                        result, types.GeneratorType
                    ), "Streaming method should return a generator"
                else:
                    # For regular operations, verify we got a result
                    assert result is not None, "Method should return a result"
            except Exception as e:
                # Accept validation errors - we're testing request structure, not response parsing
                err_str = str(e).lower()
                err_type = type(e).__name__
                if (
                    "validation" in err_str
                    or "ValidationError" in err_type
                    or "PydanticUserError" in err_type
                    or "not fully defined" in err_str
                ):
                    # Validation error is acceptable - request was made, just response parsing failed
                    mock_session.get.assert_called_once()
                else:
                    pytest.fail(f"Contract test failed for posts: {e}")


    def test_posts_required_parameters(self):
        """Test that posts handles parameters correctly."""
        method = getattr(self.stream_client, "posts")
        # No required parameters, method should be callable without args
        with patch.object(self.client, "session") as mock_session:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {}
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            try:
                method()
            except Exception as e:
                pytest.fail(f"Method with no required params should be callable: {e}")


    def test_posts_response_structure(self):
        """Test posts response structure validation."""
        with patch.object(self.client, "session") as mock_session:
            # Create mock response with expected structure
            mock_response_data = {}
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = mock_response_data
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare minimal valid parameters
            kwargs = {}
            # Add request body if required
            # Call method and verify response structure
            method = getattr(self.stream_client, "posts")
            result = method(**kwargs)
            # Verify response object has expected attributes
            # Optional field - just check it doesn't cause errors if accessed
            try:
                getattr(result, "data", None)
            except Exception as e:
                pytest.fail(
                    f"Accessing optional field 'data' should not cause errors: {e}"
                )


    def test_posts_compliance_request_structure(self):
        """Test posts_compliance request structure."""
        # Mock the session to capture request details
        with patch.object(self.client, "session") as mock_session:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {}
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare test parameters
            kwargs = {}
            # Add required parameters
            kwargs["partition"] = 42
            # Add request body if required
            # Call the method
            try:
                method = getattr(self.stream_client, "posts_compliance")
                # Check if this is a true streaming operation (has stream_config parameter)
                import types
                import inspect
                sig = inspect.signature(method)
                has_stream_config_param = "stream_config" in sig.parameters
                # Set up streaming mock only for actual streaming operations
                if has_stream_config_param:
                    mock_streaming_response = Mock()
                    mock_streaming_response.status_code = 200
                    mock_streaming_response.raise_for_status.return_value = None
                    # Make it a proper context manager
                    mock_streaming_response.__enter__ = Mock(
                        return_value=mock_streaming_response
                    )
                    mock_streaming_response.__exit__ = Mock(return_value=None)
                    # Set up iter_content to return an iterator that yields test data then stops
                    test_data = '{"data": "test"}\n'
                    mock_streaming_response.iter_content = Mock(
                        side_effect=lambda *args, **kw: iter([test_data])
                    )
                    # First call returns mock response, second call raises to prevent infinite reconnect loop
                    from xdk.streaming import StreamError, StreamErrorType
                    mock_session.get.side_effect = [
                        mock_streaming_response,
                        StreamError(
                            "Test complete", StreamErrorType.AUTHENTICATION_ERROR
                        ),
                    ]
                    # Pass stream_config with max_retries=0 to exit quickly on error
                    from xdk.streaming import StreamConfig
                    kwargs["stream_config"] = StreamConfig(max_retries=0)
                result = method(**kwargs)
                # Check if result is a generator (streaming or paginated)
                is_generator = isinstance(result, types.GeneratorType)
                is_streaming = has_stream_config_param and is_generator
                if is_generator:
                    # Consume the generator to trigger the HTTP request
                    # For both streaming and paginated methods, request happens on iteration
                    try:
                        # Try to get first item - this will trigger the HTTP request
                        next(result)
                    except StopIteration:
                        # Generator exhausted immediately - request was still made
                        pass
                    except (
                        requests.exceptions.RequestException,
                        json.JSONDecodeError,
                        AttributeError,
                        ValueError,
                    ) as e:
                        # These exceptions can occur during streaming/pagination
                        pass
                    except Exception as e:
                        # Accept validation errors - we're testing request structure, not response parsing
                        # Also accept streaming errors
                        err_str = str(e).lower()
                        err_type = type(e).__name__
                        if (
                            "validation" in err_str
                            or "ValidationError" in err_type
                            or "PydanticUserError" in err_type
                            or "Max retries" in str(e)
                            or "StreamError" in err_type
                            or "not fully defined" in err_str
                        ):
                            pass
                        else:
                            raise
                # Verify the request was made
                if is_streaming:
                    # Streaming methods may be called twice (first success, then error to stop reconnect loop)
                    assert mock_session.get.call_count >= 1
                else:
                    mock_session.get.assert_called_once()
                # Verify request structure
                call_args = mock_session.get.call_args
                # Check URL structure
                called_url = (
                    call_args[0][0] if call_args[0] else call_args[1].get("url", "")
                )
                expected_path = "/2/tweets/compliance/stream"
                assert expected_path.replace("{", "").replace(
                    "}", ""
                ) in called_url or any(
                    param in called_url for param in ["test_", "42"]
                ), f"URL should contain path template elements: {called_url}"
                # Verify response structure
                if is_streaming:
                    # For streaming, verify we got a generator
                    assert isinstance(
                        result, types.GeneratorType
                    ), "Streaming method should return a generator"
                else:
                    # For regular operations, verify we got a result
                    assert result is not None, "Method should return a result"
            except Exception as e:
                # Accept validation errors - we're testing request structure, not response parsing
                err_str = str(e).lower()
                err_type = type(e).__name__
                if (
                    "validation" in err_str
                    or "ValidationError" in err_type
                    or "PydanticUserError" in err_type
                    or "not fully defined" in err_str
                ):
                    # Validation error is acceptable - request was made, just response parsing failed
                    mock_session.get.assert_called_once()
                else:
                    pytest.fail(f"Contract test failed for posts_compliance: {e}")


    def test_posts_compliance_required_parameters(self):
        """Test that posts_compliance handles parameters correctly."""
        method = getattr(self.stream_client, "posts_compliance")
        # Test with missing required parameters - mock the request to avoid network calls
        with patch.object(self.client, "session") as mock_session:
            # Mock a 400 response (typical for missing required parameters)
            mock_response = Mock()
            mock_response.status_code = 400
            mock_response.json.return_value = {"error": "Missing required parameters"}
            mock_response.raise_for_status.side_effect = Exception("Bad Request")
            mock_session.get.return_value = mock_response
            # Call without required parameters should either raise locally or via server response
            # For generator methods (paginated), we need to iterate to trigger the exception
            import types
            with pytest.raises((TypeError, ValueError, Exception)):
                result = method()
                # Check if it's a generator (paginated method)
                if isinstance(result, types.GeneratorType):
                    # For generators, exception is raised when iterating
                    next(result)


    def test_posts_compliance_response_structure(self):
        """Test posts_compliance response structure validation."""
        with patch.object(self.client, "session") as mock_session:
            # Create mock response with expected structure
            mock_response_data = {}
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = mock_response_data
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare minimal valid parameters
            kwargs = {}
            kwargs["partition"] = 1
            # Add request body if required
            # Call method and verify response structure
            method = getattr(self.stream_client, "posts_compliance")
            result = method(**kwargs)
            # Verify response object has expected attributes
            # Optional field - just check it doesn't cause errors if accessed
            try:
                getattr(result, "data", None)
            except Exception as e:
                pytest.fail(
                    f"Accessing optional field 'data' should not cause errors: {e}"
                )


    def test_posts_firehose_request_structure(self):
        """Test posts_firehose request structure."""
        # Mock the session to capture request details
        with patch.object(self.client, "session") as mock_session:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {}
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare test parameters
            kwargs = {}
            # Add required parameters
            kwargs["partition"] = 42
            # Add request body if required
            # Call the method
            try:
                method = getattr(self.stream_client, "posts_firehose")
                # Check if this is a true streaming operation (has stream_config parameter)
                import types
                import inspect
                sig = inspect.signature(method)
                has_stream_config_param = "stream_config" in sig.parameters
                # Set up streaming mock only for actual streaming operations
                if has_stream_config_param:
                    mock_streaming_response = Mock()
                    mock_streaming_response.status_code = 200
                    mock_streaming_response.raise_for_status.return_value = None
                    # Make it a proper context manager
                    mock_streaming_response.__enter__ = Mock(
                        return_value=mock_streaming_response
                    )
                    mock_streaming_response.__exit__ = Mock(return_value=None)
                    # Set up iter_content to return an iterator that yields test data then stops
                    test_data = '{"data": "test"}\n'
                    mock_streaming_response.iter_content = Mock(
                        side_effect=lambda *args, **kw: iter([test_data])
                    )
                    # First call returns mock response, second call raises to prevent infinite reconnect loop
                    from xdk.streaming import StreamError, StreamErrorType
                    mock_session.get.side_effect = [
                        mock_streaming_response,
                        StreamError(
                            "Test complete", StreamErrorType.AUTHENTICATION_ERROR
                        ),
                    ]
                    # Pass stream_config with max_retries=0 to exit quickly on error
                    from xdk.streaming import StreamConfig
                    kwargs["stream_config"] = StreamConfig(max_retries=0)
                result = method(**kwargs)
                # Check if result is a generator (streaming or paginated)
                is_generator = isinstance(result, types.GeneratorType)
                is_streaming = has_stream_config_param and is_generator
                if is_generator:
                    # Consume the generator to trigger the HTTP request
                    # For both streaming and paginated methods, request happens on iteration
                    try:
                        # Try to get first item - this will trigger the HTTP request
                        next(result)
                    except StopIteration:
                        # Generator exhausted immediately - request was still made
                        pass
                    except (
                        requests.exceptions.RequestException,
                        json.JSONDecodeError,
                        AttributeError,
                        ValueError,
                    ) as e:
                        # These exceptions can occur during streaming/pagination
                        pass
                    except Exception as e:
                        # Accept validation errors - we're testing request structure, not response parsing
                        # Also accept streaming errors
                        err_str = str(e).lower()
                        err_type = type(e).__name__
                        if (
                            "validation" in err_str
                            or "ValidationError" in err_type
                            or "PydanticUserError" in err_type
                            or "Max retries" in str(e)
                            or "StreamError" in err_type
                            or "not fully defined" in err_str
                        ):
                            pass
                        else:
                            raise
                # Verify the request was made
                if is_streaming:
                    # Streaming methods may be called twice (first success, then error to stop reconnect loop)
                    assert mock_session.get.call_count >= 1
                else:
                    mock_session.get.assert_called_once()
                # Verify request structure
                call_args = mock_session.get.call_args
                # Check URL structure
                called_url = (
                    call_args[0][0] if call_args[0] else call_args[1].get("url", "")
                )
                expected_path = "/2/tweets/firehose/stream"
                assert expected_path.replace("{", "").replace(
                    "}", ""
                ) in called_url or any(
                    param in called_url for param in ["test_", "42"]
                ), f"URL should contain path template elements: {called_url}"
                # Verify response structure
                if is_streaming:
                    # For streaming, verify we got a generator
                    assert isinstance(
                        result, types.GeneratorType
                    ), "Streaming method should return a generator"
                else:
                    # For regular operations, verify we got a result
                    assert result is not None, "Method should return a result"
            except Exception as e:
                # Accept validation errors - we're testing request structure, not response parsing
                err_str = str(e).lower()
                err_type = type(e).__name__
                if (
                    "validation" in err_str
                    or "ValidationError" in err_type
                    or "PydanticUserError" in err_type
                    or "not fully defined" in err_str
                ):
                    # Validation error is acceptable - request was made, just response parsing failed
                    mock_session.get.assert_called_once()
                else:
                    pytest.fail(f"Contract test failed for posts_firehose: {e}")


    def test_posts_firehose_required_parameters(self):
        """Test that posts_firehose handles parameters correctly."""
        method = getattr(self.stream_client, "posts_firehose")
        # Test with missing required parameters - mock the request to avoid network calls
        with patch.object(self.client, "session") as mock_session:
            # Mock a 400 response (typical for missing required parameters)
            mock_response = Mock()
            mock_response.status_code = 400
            mock_response.json.return_value = {"error": "Missing required parameters"}
            mock_response.raise_for_status.side_effect = Exception("Bad Request")
            mock_session.get.return_value = mock_response
            # Call without required parameters should either raise locally or via server response
            # For generator methods (paginated), we need to iterate to trigger the exception
            import types
            with pytest.raises((TypeError, ValueError, Exception)):
                result = method()
                # Check if it's a generator (paginated method)
                if isinstance(result, types.GeneratorType):
                    # For generators, exception is raised when iterating
                    next(result)


    def test_posts_firehose_response_structure(self):
        """Test posts_firehose response structure validation."""
        with patch.object(self.client, "session") as mock_session:
            # Create mock response with expected structure
            mock_response_data = {}
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = mock_response_data
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare minimal valid parameters
            kwargs = {}
            kwargs["partition"] = 1
            # Add request body if required
            # Call method and verify response structure
            method = getattr(self.stream_client, "posts_firehose")
            result = method(**kwargs)
            # Verify response object has expected attributes
            # Optional field - just check it doesn't cause errors if accessed
            try:
                getattr(result, "data", None)
            except Exception as e:
                pytest.fail(
                    f"Accessing optional field 'data' should not cause errors: {e}"
                )


    def test_posts_sample10_request_structure(self):
        """Test posts_sample10 request structure."""
        # Mock the session to capture request details
        with patch.object(self.client, "session") as mock_session:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {}
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare test parameters
            kwargs = {}
            # Add required parameters
            kwargs["partition"] = 42
            # Add request body if required
            # Call the method
            try:
                method = getattr(self.stream_client, "posts_sample10")
                # Check if this is a true streaming operation (has stream_config parameter)
                import types
                import inspect
                sig = inspect.signature(method)
                has_stream_config_param = "stream_config" in sig.parameters
                # Set up streaming mock only for actual streaming operations
                if has_stream_config_param:
                    mock_streaming_response = Mock()
                    mock_streaming_response.status_code = 200
                    mock_streaming_response.raise_for_status.return_value = None
                    # Make it a proper context manager
                    mock_streaming_response.__enter__ = Mock(
                        return_value=mock_streaming_response
                    )
                    mock_streaming_response.__exit__ = Mock(return_value=None)
                    # Set up iter_content to return an iterator that yields test data then stops
                    test_data = '{"data": "test"}\n'
                    mock_streaming_response.iter_content = Mock(
                        side_effect=lambda *args, **kw: iter([test_data])
                    )
                    # First call returns mock response, second call raises to prevent infinite reconnect loop
                    from xdk.streaming import StreamError, StreamErrorType
                    mock_session.get.side_effect = [
                        mock_streaming_response,
                        StreamError(
                            "Test complete", StreamErrorType.AUTHENTICATION_ERROR
                        ),
                    ]
                    # Pass stream_config with max_retries=0 to exit quickly on error
                    from xdk.streaming import StreamConfig
                    kwargs["stream_config"] = StreamConfig(max_retries=0)
                result = method(**kwargs)
                # Check if result is a generator (streaming or paginated)
                is_generator = isinstance(result, types.GeneratorType)
                is_streaming = has_stream_config_param and is_generator
                if is_generator:
                    # Consume the generator to trigger the HTTP request
                    # For both streaming and paginated methods, request happens on iteration
                    try:
                        # Try to get first item - this will trigger the HTTP request
                        next(result)
                    except StopIteration:
                        # Generator exhausted immediately - request was still made
                        pass
                    except (
                        requests.exceptions.RequestException,
                        json.JSONDecodeError,
                        AttributeError,
                        ValueError,
                    ) as e:
                        # These exceptions can occur during streaming/pagination
                        pass
                    except Exception as e:
                        # Accept validation errors - we're testing request structure, not response parsing
                        # Also accept streaming errors
                        err_str = str(e).lower()
                        err_type = type(e).__name__
                        if (
                            "validation" in err_str
                            or "ValidationError" in err_type
                            or "PydanticUserError" in err_type
                            or "Max retries" in str(e)
                            or "StreamError" in err_type
                            or "not fully defined" in err_str
                        ):
                            pass
                        else:
                            raise
                # Verify the request was made
                if is_streaming:
                    # Streaming methods may be called twice (first success, then error to stop reconnect loop)
                    assert mock_session.get.call_count >= 1
                else:
                    mock_session.get.assert_called_once()
                # Verify request structure
                call_args = mock_session.get.call_args
                # Check URL structure
                called_url = (
                    call_args[0][0] if call_args[0] else call_args[1].get("url", "")
                )
                expected_path = "/2/tweets/sample10/stream"
                assert expected_path.replace("{", "").replace(
                    "}", ""
                ) in called_url or any(
                    param in called_url for param in ["test_", "42"]
                ), f"URL should contain path template elements: {called_url}"
                # Verify response structure
                if is_streaming:
                    # For streaming, verify we got a generator
                    assert isinstance(
                        result, types.GeneratorType
                    ), "Streaming method should return a generator"
                else:
                    # For regular operations, verify we got a result
                    assert result is not None, "Method should return a result"
            except Exception as e:
                # Accept validation errors - we're testing request structure, not response parsing
                err_str = str(e).lower()
                err_type = type(e).__name__
                if (
                    "validation" in err_str
                    or "ValidationError" in err_type
                    or "PydanticUserError" in err_type
                    or "not fully defined" in err_str
                ):
                    # Validation error is acceptable - request was made, just response parsing failed
                    mock_session.get.assert_called_once()
                else:
                    pytest.fail(f"Contract test failed for posts_sample10: {e}")


    def test_posts_sample10_required_parameters(self):
        """Test that posts_sample10 handles parameters correctly."""
        method = getattr(self.stream_client, "posts_sample10")
        # Test with missing required parameters - mock the request to avoid network calls
        with patch.object(self.client, "session") as mock_session:
            # Mock a 400 response (typical for missing required parameters)
            mock_response = Mock()
            mock_response.status_code = 400
            mock_response.json.return_value = {"error": "Missing required parameters"}
            mock_response.raise_for_status.side_effect = Exception("Bad Request")
            mock_session.get.return_value = mock_response
            # Call without required parameters should either raise locally or via server response
            # For generator methods (paginated), we need to iterate to trigger the exception
            import types
            with pytest.raises((TypeError, ValueError, Exception)):
                result = method()
                # Check if it's a generator (paginated method)
                if isinstance(result, types.GeneratorType):
                    # For generators, exception is raised when iterating
                    next(result)


    def test_posts_sample10_response_structure(self):
        """Test posts_sample10 response structure validation."""
        with patch.object(self.client, "session") as mock_session:
            # Create mock response with expected structure
            mock_response_data = {}
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = mock_response_data
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare minimal valid parameters
            kwargs = {}
            kwargs["partition"] = 1
            # Add request body if required
            # Call method and verify response structure
            method = getattr(self.stream_client, "posts_sample10")
            result = method(**kwargs)
            # Verify response object has expected attributes
            # Optional field - just check it doesn't cause errors if accessed
            try:
                getattr(result, "data", None)
            except Exception as e:
                pytest.fail(
                    f"Accessing optional field 'data' should not cause errors: {e}"
                )


    def test_posts_sample_request_structure(self):
        """Test posts_sample request structure."""
        # Mock the session to capture request details
        with patch.object(self.client, "session") as mock_session:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {}
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare test parameters
            kwargs = {}
            # Add required parameters
            # Add request body if required
            # Call the method
            try:
                method = getattr(self.stream_client, "posts_sample")
                # Check if this is a true streaming operation (has stream_config parameter)
                import types
                import inspect
                sig = inspect.signature(method)
                has_stream_config_param = "stream_config" in sig.parameters
                # Set up streaming mock only for actual streaming operations
                if has_stream_config_param:
                    mock_streaming_response = Mock()
                    mock_streaming_response.status_code = 200
                    mock_streaming_response.raise_for_status.return_value = None
                    # Make it a proper context manager
                    mock_streaming_response.__enter__ = Mock(
                        return_value=mock_streaming_response
                    )
                    mock_streaming_response.__exit__ = Mock(return_value=None)
                    # Set up iter_content to return an iterator that yields test data then stops
                    test_data = '{"data": "test"}\n'
                    mock_streaming_response.iter_content = Mock(
                        side_effect=lambda *args, **kw: iter([test_data])
                    )
                    # First call returns mock response, second call raises to prevent infinite reconnect loop
                    from xdk.streaming import StreamError, StreamErrorType
                    mock_session.get.side_effect = [
                        mock_streaming_response,
                        StreamError(
                            "Test complete", StreamErrorType.AUTHENTICATION_ERROR
                        ),
                    ]
                    # Pass stream_config with max_retries=0 to exit quickly on error
                    from xdk.streaming import StreamConfig
                    kwargs["stream_config"] = StreamConfig(max_retries=0)
                result = method(**kwargs)
                # Check if result is a generator (streaming or paginated)
                is_generator = isinstance(result, types.GeneratorType)
                is_streaming = has_stream_config_param and is_generator
                if is_generator:
                    # Consume the generator to trigger the HTTP request
                    # For both streaming and paginated methods, request happens on iteration
                    try:
                        # Try to get first item - this will trigger the HTTP request
                        next(result)
                    except StopIteration:
                        # Generator exhausted immediately - request was still made
                        pass
                    except (
                        requests.exceptions.RequestException,
                        json.JSONDecodeError,
                        AttributeError,
                        ValueError,
                    ) as e:
                        # These exceptions can occur during streaming/pagination
                        pass
                    except Exception as e:
                        # Accept validation errors - we're testing request structure, not response parsing
                        # Also accept streaming errors
                        err_str = str(e).lower()
                        err_type = type(e).__name__
                        if (
                            "validation" in err_str
                            or "ValidationError" in err_type
                            or "PydanticUserError" in err_type
                            or "Max retries" in str(e)
                            or "StreamError" in err_type
                            or "not fully defined" in err_str
                        ):
                            pass
                        else:
                            raise
                # Verify the request was made
                if is_streaming:
                    # Streaming methods may be called twice (first success, then error to stop reconnect loop)
                    assert mock_session.get.call_count >= 1
                else:
                    mock_session.get.assert_called_once()
                # Verify request structure
                call_args = mock_session.get.call_args
                # Check URL structure
                called_url = (
                    call_args[0][0] if call_args[0] else call_args[1].get("url", "")
                )
                expected_path = "/2/tweets/sample/stream"
                assert expected_path.replace("{", "").replace(
                    "}", ""
                ) in called_url or any(
                    param in called_url for param in ["test_", "42"]
                ), f"URL should contain path template elements: {called_url}"
                # Verify response structure
                if is_streaming:
                    # For streaming, verify we got a generator
                    assert isinstance(
                        result, types.GeneratorType
                    ), "Streaming method should return a generator"
                else:
                    # For regular operations, verify we got a result
                    assert result is not None, "Method should return a result"
            except Exception as e:
                # Accept validation errors - we're testing request structure, not response parsing
                err_str = str(e).lower()
                err_type = type(e).__name__
                if (
                    "validation" in err_str
                    or "ValidationError" in err_type
                    or "PydanticUserError" in err_type
                    or "not fully defined" in err_str
                ):
                    # Validation error is acceptable - request was made, just response parsing failed
                    mock_session.get.assert_called_once()
                else:
                    pytest.fail(f"Contract test failed for posts_sample: {e}")


    def test_posts_sample_required_parameters(self):
        """Test that posts_sample handles parameters correctly."""
        method = getattr(self.stream_client, "posts_sample")
        # No required parameters, method should be callable without args
        with patch.object(self.client, "session") as mock_session:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {}
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            try:
                method()
            except Exception as e:
                pytest.fail(f"Method with no required params should be callable: {e}")


    def test_posts_sample_response_structure(self):
        """Test posts_sample response structure validation."""
        with patch.object(self.client, "session") as mock_session:
            # Create mock response with expected structure
            mock_response_data = {}
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = mock_response_data
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare minimal valid parameters
            kwargs = {}
            # Add request body if required
            # Call method and verify response structure
            method = getattr(self.stream_client, "posts_sample")
            result = method(**kwargs)
            # Verify response object has expected attributes
            # Optional field - just check it doesn't cause errors if accessed
            try:
                getattr(result, "data", None)
            except Exception as e:
                pytest.fail(
                    f"Accessing optional field 'data' should not cause errors: {e}"
                )


    def test_likes_firehose_request_structure(self):
        """Test likes_firehose request structure."""
        # Mock the session to capture request details
        with patch.object(self.client, "session") as mock_session:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {}
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare test parameters
            kwargs = {}
            # Add required parameters
            kwargs["partition"] = 42
            # Add request body if required
            # Call the method
            try:
                method = getattr(self.stream_client, "likes_firehose")
                # Check if this is a true streaming operation (has stream_config parameter)
                import types
                import inspect
                sig = inspect.signature(method)
                has_stream_config_param = "stream_config" in sig.parameters
                # Set up streaming mock only for actual streaming operations
                if has_stream_config_param:
                    mock_streaming_response = Mock()
                    mock_streaming_response.status_code = 200
                    mock_streaming_response.raise_for_status.return_value = None
                    # Make it a proper context manager
                    mock_streaming_response.__enter__ = Mock(
                        return_value=mock_streaming_response
                    )
                    mock_streaming_response.__exit__ = Mock(return_value=None)
                    # Set up iter_content to return an iterator that yields test data then stops
                    test_data = '{"data": "test"}\n'
                    mock_streaming_response.iter_content = Mock(
                        side_effect=lambda *args, **kw: iter([test_data])
                    )
                    # First call returns mock response, second call raises to prevent infinite reconnect loop
                    from xdk.streaming import StreamError, StreamErrorType
                    mock_session.get.side_effect = [
                        mock_streaming_response,
                        StreamError(
                            "Test complete", StreamErrorType.AUTHENTICATION_ERROR
                        ),
                    ]
                    # Pass stream_config with max_retries=0 to exit quickly on error
                    from xdk.streaming import StreamConfig
                    kwargs["stream_config"] = StreamConfig(max_retries=0)
                result = method(**kwargs)
                # Check if result is a generator (streaming or paginated)
                is_generator = isinstance(result, types.GeneratorType)
                is_streaming = has_stream_config_param and is_generator
                if is_generator:
                    # Consume the generator to trigger the HTTP request
                    # For both streaming and paginated methods, request happens on iteration
                    try:
                        # Try to get first item - this will trigger the HTTP request
                        next(result)
                    except StopIteration:
                        # Generator exhausted immediately - request was still made
                        pass
                    except (
                        requests.exceptions.RequestException,
                        json.JSONDecodeError,
                        AttributeError,
                        ValueError,
                    ) as e:
                        # These exceptions can occur during streaming/pagination
                        pass
                    except Exception as e:
                        # Accept validation errors - we're testing request structure, not response parsing
                        # Also accept streaming errors
                        err_str = str(e).lower()
                        err_type = type(e).__name__
                        if (
                            "validation" in err_str
                            or "ValidationError" in err_type
                            or "PydanticUserError" in err_type
                            or "Max retries" in str(e)
                            or "StreamError" in err_type
                            or "not fully defined" in err_str
                        ):
                            pass
                        else:
                            raise
                # Verify the request was made
                if is_streaming:
                    # Streaming methods may be called twice (first success, then error to stop reconnect loop)
                    assert mock_session.get.call_count >= 1
                else:
                    mock_session.get.assert_called_once()
                # Verify request structure
                call_args = mock_session.get.call_args
                # Check URL structure
                called_url = (
                    call_args[0][0] if call_args[0] else call_args[1].get("url", "")
                )
                expected_path = "/2/likes/firehose/stream"
                assert expected_path.replace("{", "").replace(
                    "}", ""
                ) in called_url or any(
                    param in called_url for param in ["test_", "42"]
                ), f"URL should contain path template elements: {called_url}"
                # Verify response structure
                if is_streaming:
                    # For streaming, verify we got a generator
                    assert isinstance(
                        result, types.GeneratorType
                    ), "Streaming method should return a generator"
                else:
                    # For regular operations, verify we got a result
                    assert result is not None, "Method should return a result"
            except Exception as e:
                # Accept validation errors - we're testing request structure, not response parsing
                err_str = str(e).lower()
                err_type = type(e).__name__
                if (
                    "validation" in err_str
                    or "ValidationError" in err_type
                    or "PydanticUserError" in err_type
                    or "not fully defined" in err_str
                ):
                    # Validation error is acceptable - request was made, just response parsing failed
                    mock_session.get.assert_called_once()
                else:
                    pytest.fail(f"Contract test failed for likes_firehose: {e}")


    def test_likes_firehose_required_parameters(self):
        """Test that likes_firehose handles parameters correctly."""
        method = getattr(self.stream_client, "likes_firehose")
        # Test with missing required parameters - mock the request to avoid network calls
        with patch.object(self.client, "session") as mock_session:
            # Mock a 400 response (typical for missing required parameters)
            mock_response = Mock()
            mock_response.status_code = 400
            mock_response.json.return_value = {"error": "Missing required parameters"}
            mock_response.raise_for_status.side_effect = Exception("Bad Request")
            mock_session.get.return_value = mock_response
            # Call without required parameters should either raise locally or via server response
            # For generator methods (paginated), we need to iterate to trigger the exception
            import types
            with pytest.raises((TypeError, ValueError, Exception)):
                result = method()
                # Check if it's a generator (paginated method)
                if isinstance(result, types.GeneratorType):
                    # For generators, exception is raised when iterating
                    next(result)


    def test_likes_firehose_response_structure(self):
        """Test likes_firehose response structure validation."""
        with patch.object(self.client, "session") as mock_session:
            # Create mock response with expected structure
            mock_response_data = {}
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = mock_response_data
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare minimal valid parameters
            kwargs = {}
            kwargs["partition"] = 1
            # Add request body if required
            # Call method and verify response structure
            method = getattr(self.stream_client, "likes_firehose")
            result = method(**kwargs)
            # Verify response object has expected attributes
            # Optional field - just check it doesn't cause errors if accessed
            try:
                getattr(result, "data", None)
            except Exception as e:
                pytest.fail(
                    f"Accessing optional field 'data' should not cause errors: {e}"
                )


    def test_posts_firehose_ja_request_structure(self):
        """Test posts_firehose_ja request structure."""
        # Mock the session to capture request details
        with patch.object(self.client, "session") as mock_session:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {}
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare test parameters
            kwargs = {}
            # Add required parameters
            kwargs["partition"] = 42
            # Add request body if required
            # Call the method
            try:
                method = getattr(self.stream_client, "posts_firehose_ja")
                # Check if this is a true streaming operation (has stream_config parameter)
                import types
                import inspect
                sig = inspect.signature(method)
                has_stream_config_param = "stream_config" in sig.parameters
                # Set up streaming mock only for actual streaming operations
                if has_stream_config_param:
                    mock_streaming_response = Mock()
                    mock_streaming_response.status_code = 200
                    mock_streaming_response.raise_for_status.return_value = None
                    # Make it a proper context manager
                    mock_streaming_response.__enter__ = Mock(
                        return_value=mock_streaming_response
                    )
                    mock_streaming_response.__exit__ = Mock(return_value=None)
                    # Set up iter_content to return an iterator that yields test data then stops
                    test_data = '{"data": "test"}\n'
                    mock_streaming_response.iter_content = Mock(
                        side_effect=lambda *args, **kw: iter([test_data])
                    )
                    # First call returns mock response, second call raises to prevent infinite reconnect loop
                    from xdk.streaming import StreamError, StreamErrorType
                    mock_session.get.side_effect = [
                        mock_streaming_response,
                        StreamError(
                            "Test complete", StreamErrorType.AUTHENTICATION_ERROR
                        ),
                    ]
                    # Pass stream_config with max_retries=0 to exit quickly on error
                    from xdk.streaming import StreamConfig
                    kwargs["stream_config"] = StreamConfig(max_retries=0)
                result = method(**kwargs)
                # Check if result is a generator (streaming or paginated)
                is_generator = isinstance(result, types.GeneratorType)
                is_streaming = has_stream_config_param and is_generator
                if is_generator:
                    # Consume the generator to trigger the HTTP request
                    # For both streaming and paginated methods, request happens on iteration
                    try:
                        # Try to get first item - this will trigger the HTTP request
                        next(result)
                    except StopIteration:
                        # Generator exhausted immediately - request was still made
                        pass
                    except (
                        requests.exceptions.RequestException,
                        json.JSONDecodeError,
                        AttributeError,
                        ValueError,
                    ) as e:
                        # These exceptions can occur during streaming/pagination
                        pass
                    except Exception as e:
                        # Accept validation errors - we're testing request structure, not response parsing
                        # Also accept streaming errors
                        err_str = str(e).lower()
                        err_type = type(e).__name__
                        if (
                            "validation" in err_str
                            or "ValidationError" in err_type
                            or "PydanticUserError" in err_type
                            or "Max retries" in str(e)
                            or "StreamError" in err_type
                            or "not fully defined" in err_str
                        ):
                            pass
                        else:
                            raise
                # Verify the request was made
                if is_streaming:
                    # Streaming methods may be called twice (first success, then error to stop reconnect loop)
                    assert mock_session.get.call_count >= 1
                else:
                    mock_session.get.assert_called_once()
                # Verify request structure
                call_args = mock_session.get.call_args
                # Check URL structure
                called_url = (
                    call_args[0][0] if call_args[0] else call_args[1].get("url", "")
                )
                expected_path = "/2/tweets/firehose/stream/lang/ja"
                assert expected_path.replace("{", "").replace(
                    "}", ""
                ) in called_url or any(
                    param in called_url for param in ["test_", "42"]
                ), f"URL should contain path template elements: {called_url}"
                # Verify response structure
                if is_streaming:
                    # For streaming, verify we got a generator
                    assert isinstance(
                        result, types.GeneratorType
                    ), "Streaming method should return a generator"
                else:
                    # For regular operations, verify we got a result
                    assert result is not None, "Method should return a result"
            except Exception as e:
                # Accept validation errors - we're testing request structure, not response parsing
                err_str = str(e).lower()
                err_type = type(e).__name__
                if (
                    "validation" in err_str
                    or "ValidationError" in err_type
                    or "PydanticUserError" in err_type
                    or "not fully defined" in err_str
                ):
                    # Validation error is acceptable - request was made, just response parsing failed
                    mock_session.get.assert_called_once()
                else:
                    pytest.fail(f"Contract test failed for posts_firehose_ja: {e}")


    def test_posts_firehose_ja_required_parameters(self):
        """Test that posts_firehose_ja handles parameters correctly."""
        method = getattr(self.stream_client, "posts_firehose_ja")
        # Test with missing required parameters - mock the request to avoid network calls
        with patch.object(self.client, "session") as mock_session:
            # Mock a 400 response (typical for missing required parameters)
            mock_response = Mock()
            mock_response.status_code = 400
            mock_response.json.return_value = {"error": "Missing required parameters"}
            mock_response.raise_for_status.side_effect = Exception("Bad Request")
            mock_session.get.return_value = mock_response
            # Call without required parameters should either raise locally or via server response
            # For generator methods (paginated), we need to iterate to trigger the exception
            import types
            with pytest.raises((TypeError, ValueError, Exception)):
                result = method()
                # Check if it's a generator (paginated method)
                if isinstance(result, types.GeneratorType):
                    # For generators, exception is raised when iterating
                    next(result)


    def test_posts_firehose_ja_response_structure(self):
        """Test posts_firehose_ja response structure validation."""
        with patch.object(self.client, "session") as mock_session:
            # Create mock response with expected structure
            mock_response_data = {}
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = mock_response_data
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare minimal valid parameters
            kwargs = {}
            kwargs["partition"] = 1
            # Add request body if required
            # Call method and verify response structure
            method = getattr(self.stream_client, "posts_firehose_ja")
            result = method(**kwargs)
            # Verify response object has expected attributes
            # Optional field - just check it doesn't cause errors if accessed
            try:
                getattr(result, "data", None)
            except Exception as e:
                pytest.fail(
                    f"Accessing optional field 'data' should not cause errors: {e}"
                )


    def test_labels_compliance_request_structure(self):
        """Test labels_compliance request structure."""
        # Mock the session to capture request details
        with patch.object(self.client, "session") as mock_session:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {}
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare test parameters
            kwargs = {}
            # Add required parameters
            # Add request body if required
            # Call the method
            try:
                method = getattr(self.stream_client, "labels_compliance")
                # Check if this is a true streaming operation (has stream_config parameter)
                import types
                import inspect
                sig = inspect.signature(method)
                has_stream_config_param = "stream_config" in sig.parameters
                # Set up streaming mock only for actual streaming operations
                if has_stream_config_param:
                    mock_streaming_response = Mock()
                    mock_streaming_response.status_code = 200
                    mock_streaming_response.raise_for_status.return_value = None
                    # Make it a proper context manager
                    mock_streaming_response.__enter__ = Mock(
                        return_value=mock_streaming_response
                    )
                    mock_streaming_response.__exit__ = Mock(return_value=None)
                    # Set up iter_content to return an iterator that yields test data then stops
                    test_data = '{"data": "test"}\n'
                    mock_streaming_response.iter_content = Mock(
                        side_effect=lambda *args, **kw: iter([test_data])
                    )
                    # First call returns mock response, second call raises to prevent infinite reconnect loop
                    from xdk.streaming import StreamError, StreamErrorType
                    mock_session.get.side_effect = [
                        mock_streaming_response,
                        StreamError(
                            "Test complete", StreamErrorType.AUTHENTICATION_ERROR
                        ),
                    ]
                    # Pass stream_config with max_retries=0 to exit quickly on error
                    from xdk.streaming import StreamConfig
                    kwargs["stream_config"] = StreamConfig(max_retries=0)
                result = method(**kwargs)
                # Check if result is a generator (streaming or paginated)
                is_generator = isinstance(result, types.GeneratorType)
                is_streaming = has_stream_config_param and is_generator
                if is_generator:
                    # Consume the generator to trigger the HTTP request
                    # For both streaming and paginated methods, request happens on iteration
                    try:
                        # Try to get first item - this will trigger the HTTP request
                        next(result)
                    except StopIteration:
                        # Generator exhausted immediately - request was still made
                        pass
                    except (
                        requests.exceptions.RequestException,
                        json.JSONDecodeError,
                        AttributeError,
                        ValueError,
                    ) as e:
                        # These exceptions can occur during streaming/pagination
                        pass
                    except Exception as e:
                        # Accept validation errors - we're testing request structure, not response parsing
                        # Also accept streaming errors
                        err_str = str(e).lower()
                        err_type = type(e).__name__
                        if (
                            "validation" in err_str
                            or "ValidationError" in err_type
                            or "PydanticUserError" in err_type
                            or "Max retries" in str(e)
                            or "StreamError" in err_type
                            or "not fully defined" in err_str
                        ):
                            pass
                        else:
                            raise
                # Verify the request was made
                if is_streaming:
                    # Streaming methods may be called twice (first success, then error to stop reconnect loop)
                    assert mock_session.get.call_count >= 1
                else:
                    mock_session.get.assert_called_once()
                # Verify request structure
                call_args = mock_session.get.call_args
                # Check URL structure
                called_url = (
                    call_args[0][0] if call_args[0] else call_args[1].get("url", "")
                )
                expected_path = "/2/tweets/label/stream"
                assert expected_path.replace("{", "").replace(
                    "}", ""
                ) in called_url or any(
                    param in called_url for param in ["test_", "42"]
                ), f"URL should contain path template elements: {called_url}"
                # Verify response structure
                if is_streaming:
                    # For streaming, verify we got a generator
                    assert isinstance(
                        result, types.GeneratorType
                    ), "Streaming method should return a generator"
                else:
                    # For regular operations, verify we got a result
                    assert result is not None, "Method should return a result"
            except Exception as e:
                # Accept validation errors - we're testing request structure, not response parsing
                err_str = str(e).lower()
                err_type = type(e).__name__
                if (
                    "validation" in err_str
                    or "ValidationError" in err_type
                    or "PydanticUserError" in err_type
                    or "not fully defined" in err_str
                ):
                    # Validation error is acceptable - request was made, just response parsing failed
                    mock_session.get.assert_called_once()
                else:
                    pytest.fail(f"Contract test failed for labels_compliance: {e}")


    def test_labels_compliance_required_parameters(self):
        """Test that labels_compliance handles parameters correctly."""
        method = getattr(self.stream_client, "labels_compliance")
        # No required parameters, method should be callable without args
        with patch.object(self.client, "session") as mock_session:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {}
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            try:
                method()
            except Exception as e:
                pytest.fail(f"Method with no required params should be callable: {e}")


    def test_labels_compliance_response_structure(self):
        """Test labels_compliance response structure validation."""
        with patch.object(self.client, "session") as mock_session:
            # Create mock response with expected structure
            mock_response_data = {}
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = mock_response_data
            mock_response.raise_for_status.return_value = None
            mock_session.get.return_value = mock_response
            # Prepare minimal valid parameters
            kwargs = {}
            # Add request body if required
            # Call method and verify response structure
            method = getattr(self.stream_client, "labels_compliance")
            result = method(**kwargs)
            # Verify response object has expected attributes
            # Optional field - just check it doesn't cause errors if accessed
            try:
                getattr(result, "data", None)
            except Exception as e:
                pytest.fail(
                    f"Accessing optional field 'data' should not cause errors: {e}"
                )
